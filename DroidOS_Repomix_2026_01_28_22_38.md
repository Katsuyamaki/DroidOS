This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/.gradle/**, **/build/**, **/.idea/**, **/.git/**, **/*.iml, **/local.properties, **/*.properties, **/gradlew*, **/gradle/wrapper/**, **/*.pro, **/*.jar, **/*.aar, **/*.png, **/*.webp, **/*.jpg, **/*.svg, **/captures/**, **/build_log.txt, **/assets/dictionary.txt, **/assets/dictionary**.txt, **/*Repomix*.md, **/restore*.md, **/GEMINI.md, **/res/drawable*/**, **/res/mipmap*/**, **/res/values*/**, **/res/font/**, **/CHANGELOG.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.claude/
  settings.local.json
Cover-Screen-Launcher/
  app/
    src/
      main/
        aidl/
          com/
            example/
              quadrantlauncher/
                IShellService.aidl
                IShellService.aidl.minimize
        java/
          com/
            example/
              quadrantlauncher/
                AppPreferences.kt
                FloatingLauncherService.kt
                IconPickerActivity.kt
                MainActivity.kt
                MenuActivity.kt
                PermissionActivity.kt
                QuadrantActivity.kt
                ShellUserService.kt
                ShizukuBinder.java
                ShizukuHelper.kt
                SplitActivity.kt
                TriSplitActivity.kt
        res/
          layout/
            activity_main.xml
            activity_menu.xml
            activity_permissions.xml
            activity_quadrant.xml
            activity_split.xml
            activity_tri_split.xml
            item_app_rofi.xml
            item_custom_mod.xml
            item_custom_resolution.xml
            item_dpi_custom.xml
            item_font_size.xml
            item_height_setting.xml
            item_icon_setting.xml
            item_keybind.xml
            item_layout_option.xml
            item_margin_setting.xml
            item_profile_rich.xml
            item_selected_app.xml
            item_simple_text.xml
            item_visual_queue_app.xml
            item_width_setting.xml
            layout_bubble.xml
            layout_key_picker.xml
            layout_rofi_drawer.xml
            layout_visual_queue.xml
            list_item_app.xml
          xml/
            accessibility_service_config.xml
            backup_rules.xml
            data_extraction_rules.xml
        AndroidManifest.xml
    .gitignore
    build.gradle.kts
  gradle/
    libs.versions.toml
  .gitignore
  build.gradle.kts
  gradlew
  gradlew.bat
  multidex-keep.txt
  README.md
  settings.gradle.kts
Cover-Screen-Trackpad/
  app/
    src/
      main/
        aidl/
          com/
            example/
              coverscreentester/
                IShellService.aidl
        assets/
          clean_dict_with_nvim.lua
          clean_dictionary.py
          sanitize_dict.py
        java/
          com/
            example/
              coverscreentester/
                DockInputMethodService.kt
                InterAppCommandReceiver.kt
                KeyboardActivity.kt
                KeyboardManager.kt
                KeyboardOverlay.kt
                KeyboardPickerActivity.kt
                KeyboardUtils.kt
                KeyboardView.kt
                MainActivity.kt
                ManualAdjustActivity.kt
                NullInputMethodService.kt
                OverlayService.kt
                PredictionEngine.kt
                ProfilesActivity.kt
                SettingsActivity.kt
                ShellUserService.kt
                ShizukuBinder.java
                ShizukuInputHandler.kt
                SwipeTrailView.kt
                TrackpadMenuAdapter.kt
                TrackpadMenuManager.kt
                TrackpadPrefs.kt
                TrackpadService.kt
        res/
          layout/
            activity_keyboard.xml
            activity_main.xml
            activity_manual_adjust.xml
            activity_menu.xml
            activity_profiles.xml
            activity_settings.xml
            item_dpi_custom.xml
            item_trackpad_menu.xml
            layout_dock_popup.xml
            layout_input_dock.xml
            layout_trackpad_bubble.xml
            layout_trackpad_drawer.xml
            layout_trackpad.xml
            service_overlay.xml
          menu/
            dock_menu.xml
          xml/
            accessibility_service_config.xml
            backup_rules.xml
            data_extraction_rules.xml
            method.xml
        AndroidManifest.xml
        AndroidManifest.xml.update
    .gitignore
    build.gradle.kts
  gradle/
    libs.versions.toml
  .gitignore
  build.gradle.kts
  gradlew
  gradlew.bat
  README.md
  settings.gradle.kts
.gitignore
README.md
```

# Files

## File: Cover-Screen-Launcher/app/src/main/aidl/com/example/quadrantlauncher/IShellService.aidl.minimize
```
package com.example.quadrantlauncher;

interface IShellService {
    void forceStop(String packageName);
    void runCommand(String command);
    void setScreenOff(int displayIndex, boolean turnOff);
    void repositionTask(String packageName, int left, int top, int right, int bottom);
    List<String> getVisiblePackages(int displayId);
    List<String> getWindowLayouts(int displayId);
    List<String> getAllRunningPackages();
    int getTaskId(String packageName);
    void moveTaskToBack(int taskId);
    void setSystemBrightness(int brightness);
    int getSystemBrightness();
    float getSystemBrightnessFloat();
    void setAutoBrightness(boolean enabled);
    boolean isAutoBrightness();
    boolean setBrightnessViaDisplayManager(int displayId, float brightness);
    void setBrightness(int value);
}
```

## File: Cover-Screen-Launcher/app/src/main/java/com/example/quadrantlauncher/IconPickerActivity.kt
```kotlin
package com.example.quadrantlauncher

import android.app.Activity
import android.content.Intent
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.result.contract.ActivityResultContracts

class IconPickerActivity : ComponentActivity() {

    private val pickImage = registerForActivityResult(ActivityResultContracts.OpenDocument()) { uri ->
        if (uri != null) {
            try {
                // Persist permission so we can read this after reboot
                contentResolver.takePersistableUriPermission(
                    uri, 
                    Intent.FLAG_GRANT_READ_URI_PERMISSION
                )
                AppPreferences.saveIconUri(this, uri.toString())
                
                // Notify Service to update
                sendBroadcast(Intent("com.example.quadrantlauncher.UPDATE_ICON"))
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
        finish()
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Invisible activity
        
        try {
            pickImage.launch(arrayOf("image/*"))
        } catch (e: Exception) {
            finish()
        }
    }
}
```

## File: Cover-Screen-Launcher/app/src/main/java/com/example/quadrantlauncher/MenuActivity.kt
```kotlin
package com.example.quadrantlauncher

import android.app.Activity
import android.content.Intent
import android.graphics.Color
import android.os.Bundle
import android.view.Gravity
import android.widget.Button
import android.widget.ImageButton
import android.widget.LinearLayout
import android.widget.TextView
import android.widget.Toast
import android.view.ViewGroup.LayoutParams.MATCH_PARENT
import android.view.ViewGroup.LayoutParams.WRAP_CONTENT
import rikka.shizuku.Shizuku

class MenuActivity : Activity(), Shizuku.OnRequestPermissionResultListener {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // --- NEW: PERMISSION CHECK LANDING PAGE LOGIC ---
        if (!hasRequiredPermissions()) {
            val intent = Intent(this, PermissionActivity::class.java)
            startActivity(intent)
            finish() // Close MenuActivity so user can't go back without perms
            return
        }
        // ------------------------------------------------

        // 1. Shizuku Permission Check (Existing logic can remain or be removed as double-check)
        checkShizukuPermission() 

        // 2. Main Layout Container (Dark Theme)
        val mainLayout = LinearLayout(this).apply {
            orientation = LinearLayout.VERTICAL
            layoutParams = LinearLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT)
            setPadding(40, 60, 40, 40)
            setBackgroundColor(Color.parseColor("#1E1E1E")) // Dark Background
            gravity = Gravity.TOP
        }

        // --- TITLE HEADER ---
        val headerText = TextView(this).apply {
            text = "CoverScreen Launcher"
            textSize = 22f
            setTextColor(Color.LTGRAY)
            gravity = Gravity.CENTER_HORIZONTAL
            layoutParams = LinearLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT).apply {
                bottomMargin = 50
            }
        }
        mainLayout.addView(headerText)

        // --- PROFILE ROW (Horizontal: Text + Save Icon) ---
        val profileRow = LinearLayout(this).apply {
            orientation = LinearLayout.HORIZONTAL
            layoutParams = LinearLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT).apply {
                bottomMargin = 60
            }
            gravity = Gravity.CENTER_VERTICAL
            // Add a subtle background to the row to make it distinct
            setBackgroundColor(Color.parseColor("#2D2D2D"))
            setPadding(20, 20, 20, 20)
        }

        // Profile Text (Left side)
        val profileText = TextView(this).apply {
            text = "Current: Default" 
            textSize = 18f
            setTextColor(Color.WHITE)
            // Weight 1 pushes the icon to the far right. 
            // Change to 0 and WRAP_CONTENT if you want icon immediately next to text.
            layoutParams = LinearLayout.LayoutParams(0, WRAP_CONTENT, 1f) 
        }

        // Save Icon (Right side)
        val saveBtn = ImageButton(this).apply {
            setImageResource(android.R.drawable.ic_menu_save)
            setBackgroundColor(Color.TRANSPARENT) // Transparent bg
            setColorFilter(Color.CYAN) // Cyan tint to make it pop
            setPadding(20, 0, 0, 0)
            setOnClickListener {
                Toast.makeText(this@MenuActivity, "Profile Saved (Placeholder)", Toast.LENGTH_SHORT).show()
                // TODO: Connect to AppPreferences.saveProfile logic
            }
        }

        profileRow.addView(profileText)
        profileRow.addView(saveBtn)
        mainLayout.addView(profileRow)

        // --- LAUNCHER BUTTONS ---
        
        // Button 1: 4-Quadrant
        val btnQuad = Button(this).apply {
            text = "Launch 4-Quadrant"
            setTextColor(Color.WHITE)
            setBackgroundColor(Color.parseColor("#444444"))
            layoutParams = LinearLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT).apply {
                bottomMargin = 30
            }
            setOnClickListener {
                launchActivity(QuadrantActivity::class.java)
            }
        }

        // Button 2: Split-Screen
        val btnSplit = Button(this).apply {
            text = "Launch Split-Screen"
            setTextColor(Color.WHITE)
            setBackgroundColor(Color.parseColor("#444444"))
            layoutParams = LinearLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT)
            setOnClickListener {
                launchActivity(TriSplitActivity::class.java)
            }
        }

        mainLayout.addView(btnQuad)
        mainLayout.addView(btnSplit)

        setContentView(mainLayout)
    }

    // Helper function to check all required permissions
    private fun hasRequiredPermissions(): Boolean {
        val hasOverlay = android.provider.Settings.canDrawOverlays(this)
        val hasShizuku = try { 
            rikka.shizuku.Shizuku.checkSelfPermission() == android.content.pm.PackageManager.PERMISSION_GRANTED 
        } catch(e: Exception) { false }
        
        val hasNotif = if (android.os.Build.VERSION.SDK_INT >= 33) {
            checkSelfPermission(android.Manifest.permission.POST_NOTIFICATIONS) == android.content.pm.PackageManager.PERMISSION_GRANTED
        } else true

        return hasOverlay && hasShizuku && hasNotif
    }

    private fun checkShizukuPermission() {
        if (Shizuku.isPreV11() || Shizuku.getVersion() < 11) {
            // Shizuku not running
        } else if (Shizuku.checkSelfPermission() != android.content.pm.PackageManager.PERMISSION_GRANTED) {
            Shizuku.requestPermission(0)
            Shizuku.addRequestPermissionResultListener(this)
        }
    }

    private fun launchActivity(cls: Class<*>) {
        try {
            val intent = Intent(this, cls)
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            startActivity(intent)
        } catch (e: Exception) {
            Toast.makeText(this, "Error: ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }

    override fun onRequestPermissionResult(requestCode: Int, grantResult: Int) {
        if (grantResult == android.content.pm.PackageManager.PERMISSION_GRANTED) {
            Toast.makeText(this, "Shizuku Granted", Toast.LENGTH_SHORT).show()
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        Shizuku.removeRequestPermissionResultListener(this)
    }
}
```

## File: Cover-Screen-Launcher/app/src/main/java/com/example/quadrantlauncher/QuadrantActivity.kt
```kotlin
package com.example.quadrantlauncher

import android.app.Activity
import android.app.ActivityOptions
import android.content.Intent
import android.content.pm.PackageManager
import android.graphics.Rect
import android.os.Bundle
import android.util.Log
import android.widget.Button
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import rikka.shizuku.Shizuku

class QuadrantActivity : AppCompatActivity() {

    companion object {
        const val Q1_KEY = "Q1_PACKAGE"
        const val Q2_KEY = "Q2_PACKAGE"
        const val Q3_KEY = "Q3_PACKAGE"
        const val Q4_KEY = "Q4_PACKAGE"
    }

    private var q1Package: String? = null
    private var q2Package: String? = null
    private var q3Package: String? = null
    private var q4Package: String? = null

    private lateinit var q1Button: Button
    private lateinit var q2Button: Button
    private lateinit var q3Button: Button
    private lateinit var q4Button: Button
    private lateinit var launchButton: Button

    private var currentQuadrant = -1
    private var hasShizukuPermission = false

    private val REQUEST_PERMISSION_RESULT_LISTENER =
        Shizuku.OnRequestPermissionResultListener { requestCode, grantResult ->
            if (requestCode == ShizukuHelper.SHIZUKU_PERMISSION_REQUEST_CODE) {
                hasShizukuPermission = grantResult == PackageManager.PERMISSION_GRANTED
                checkShizukuPermission() // Update status
            }
        }

    private val appSelectLauncher = registerForActivityResult(
        ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == Activity.RESULT_OK) {
            val packageName = result.data?.getStringExtra(MainActivity.SELECTED_APP_PACKAGE)
            if (packageName != null) {
                val simple = AppPreferences.getSimpleName(packageName)
                when (currentQuadrant) {
                    1 -> {
                        q1Package = packageName
                        q1Button.text = "Q1: $simple"
                        AppPreferences.savePackage(this, Q1_KEY, packageName)
                    }
                    2 -> {
                        q2Package = packageName
                        q2Button.text = "Q2: $simple"
                        AppPreferences.savePackage(this, Q2_KEY, packageName)
                    }
                    3 -> {
                        q3Package = packageName
                        q3Button.text = "Q3: $simple"
                        AppPreferences.savePackage(this, Q3_KEY, packageName)
                    }
                    4 -> {
                        q4Package = packageName
                        q4Button.text = "Q4: $simple"
                        AppPreferences.savePackage(this, Q4_KEY, packageName)
                    }
                }
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Shizuku.addRequestPermissionResultListener(REQUEST_PERMISSION_RESULT_LISTENER)
        setContentView(R.layout.activity_quadrant)

        q1Button = findViewById(R.id.q1_button)
        q2Button = findViewById(R.id.q2_button)
        q3Button = findViewById(R.id.q3_button)
        q4Button = findViewById(R.id.q4_button)
        launchButton = findViewById(R.id.launch_button)

        loadSavedApps()

        q1Button.setOnClickListener { currentQuadrant = 1; launchAppPicker() }
        q2Button.setOnClickListener { currentQuadrant = 2; launchAppPicker() }
        q3Button.setOnClickListener { currentQuadrant = 3; launchAppPicker() }
        q4Button.setOnClickListener { currentQuadrant = 4; launchAppPicker() }

        launchButton.setOnClickListener {
            if (q1Package != null && q2Package != null &&
                q3Package != null && q4Package != null) {
                launchQuadrantApps()
            } else {
                Toast.makeText(this, "Select all 4 apps.", Toast.LENGTH_SHORT).show()
            }
        }
        checkShizukuPermission()
    }

    private fun loadSavedApps() {
        q1Package = AppPreferences.loadPackage(this, Q1_KEY)
        q1Button.text = "Q1: ${AppPreferences.getSimpleName(q1Package)}"
        q2Package = AppPreferences.loadPackage(this, Q2_KEY)
        q2Button.text = "Q2: ${AppPreferences.getSimpleName(q2Package)}"
        q3Package = AppPreferences.loadPackage(this, Q3_KEY)
        q3Button.text = "Q3: ${AppPreferences.getSimpleName(q3Package)}"
        q4Package = AppPreferences.loadPackage(this, Q4_KEY)
        q4Button.text = "Q4: ${AppPreferences.getSimpleName(q4Package)}"
    }

    override fun onDestroy() {
        super.onDestroy()
        Shizuku.removeRequestPermissionResultListener(REQUEST_PERMISSION_RESULT_LISTENER)
    }

    private fun checkShizukuPermission() {
        if (ShizukuHelper.isShizukuAvailable()) {
            if (ShizukuHelper.hasPermission()) {
                hasShizukuPermission = true
            } else {
                ShizukuHelper.requestPermission()
            }
        }
    }

    private fun launchAppPicker() {
        appSelectLauncher.launch(Intent(this, MainActivity::class.java))
    }

    private fun launchQuadrantApps() {
        val metrics = windowManager.maximumWindowMetrics
        val w = metrics.bounds.width()
        val h = metrics.bounds.height()

        val q1 = Rect(0, 0, w / 2, h / 2)
        val q2 = Rect(w / 2, 0, w, h / 2)
        val q3 = Rect(0, h / 2, w / 2, h)
        val q4 = Rect(w / 2, h / 2, w, h)

        // Kill all first (Synchronously wait for shell command)
        if (hasShizukuPermission) {
            // Launch in background thread to avoid freezing UI if kill takes time
            Thread {
                ShizukuHelper.killApp(q1Package!!)
                ShizukuHelper.killApp(q2Package!!)
                ShizukuHelper.killApp(q3Package!!)
                ShizukuHelper.killApp(q4Package!!)
                
                // IMPORTANT: Wait for OS to clean up windows
                try { Thread.sleep(400) } catch (e: InterruptedException) {}

                // Back to UI thread to launch
                runOnUiThread {
                    launchAppIntent(q1Package!!, q1)
                    launchAppIntent(q2Package!!, q2)
                    launchAppIntent(q3Package!!, q3)
                    launchAppIntent(q4Package!!, q4)
                }
            }.start()
        } else {
            // Fallback (wont work well for moving windows)
            launchAppIntent(q1Package!!, q1)
            launchAppIntent(q2Package!!, q2)
            launchAppIntent(q3Package!!, q3)
            launchAppIntent(q4Package!!, q4)
        }
    }

    private fun launchAppIntent(packageName: String, bounds: Rect) {
        try {
            val intent = packageManager.getLaunchIntentForPackage(packageName)
            if (intent == null) return

            // CLEAR_TOP helps reset the task state
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)
            
            val options = ActivityOptions.makeBasic().setLaunchBounds(bounds)
            startActivity(intent, options.toBundle())
        } catch (e: Exception) {
            Log.e("Quadrant", "Launch failed for $packageName", e)
        }
    }
}
```

## File: Cover-Screen-Launcher/app/src/main/java/com/example/quadrantlauncher/ShizukuBinder.java
```java
package com.example.quadrantlauncher;

import android.content.ComponentName;
import android.content.ServiceConnection;
import rikka.shizuku.Shizuku;

public class ShizukuBinder {
    
    public static void bind(ComponentName component, ServiceConnection connection, boolean debug, int version) {
        Shizuku.UserServiceArgs args = new Shizuku.UserServiceArgs(component)
                .processNameSuffix("shell")
                .daemon(false)
                .debuggable(debug)
                .version(version);
        
        Shizuku.bindUserService(args, connection);
    }

    public static void unbind(ComponentName component, ServiceConnection connection) {
        Shizuku.UserServiceArgs args = new Shizuku.UserServiceArgs(component)
                .processNameSuffix("shell")
                .daemon(false);
        
        Shizuku.unbindUserService(args, connection, true); 
    }
}
```

## File: Cover-Screen-Launcher/app/src/main/java/com/example/quadrantlauncher/ShizukuHelper.kt
```kotlin
package com.example.quadrantlauncher

import android.content.pm.PackageManager
import rikka.shizuku.Shizuku
import java.lang.reflect.Method

object ShizukuHelper {
    const val SHIZUKU_PERMISSION_REQUEST_CODE = 1001

    // Reflection to access hidden 'newProcess' method
    private val newProcessMethod: Method by lazy {
        val clazz = Class.forName("rikka.shizuku.Shizuku")
        val method = clazz.getDeclaredMethod(
            "newProcess",
            Array<String>::class.java,
            Array<String>::class.java,
            String::class.java
        )
        method.isAccessible = true
        method
    }

    /**
     * Checks if Shizuku is available (Service bound and version correct).
     */
    fun isShizukuAvailable(): Boolean {
        return try {
            !Shizuku.isPreV11() && Shizuku.getVersion() >= 11
        } catch (e: Exception) {
            false
        }
    }

    /**
     * Checks if we already have the permission.
     */
    fun hasPermission(): Boolean {
        return if (isShizukuAvailable()) {
            try {
                Shizuku.checkSelfPermission() == PackageManager.PERMISSION_GRANTED
            } catch (e: Exception) {
                false
            }
        } else {
            false
        }
    }

    /**
     * Requests permission. Default code used if none provided.
     */
    fun requestPermission(requestCode: Int = SHIZUKU_PERMISSION_REQUEST_CODE) {
        if (isShizukuAvailable()) {
            Shizuku.requestPermission(requestCode)
        }
    }

    /**
     * Executes a generic shell command using Shizuku.
     */
    fun runShellCommand(commandString: String) {
        val command = arrayOf("sh", "-c", commandString)
        val process = newProcessMethod.invoke(null, command, null, null) as Process
        process.waitFor()
    }

    /**
     * Kills the target app to force a window reset.
     */
    fun killApp(packageName: String) {
        runShellCommand("am force-stop $packageName")
    }
}
```

## File: Cover-Screen-Launcher/app/src/main/java/com/example/quadrantlauncher/SplitActivity.kt
```kotlin
package com.example.quadrantlauncher

import android.app.Activity
import android.app.ActivityOptions
import android.content.ComponentName
import android.content.Intent
import android.content.ServiceConnection
import android.content.pm.PackageManager
import android.graphics.Rect
import android.os.Bundle
import android.os.IBinder
import android.util.Log
import android.widget.Button
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import rikka.shizuku.Shizuku

class SplitActivity : AppCompatActivity() {

    companion object {
        const val SPLIT1_KEY = "SPLIT1_PACKAGE"
        const val SPLIT2_KEY = "SPLIT2_PACKAGE"
        const val TAG = "SplitActivity"
    }

    private var app1Package: String? = null
    private var app2Package: String? = null
    private lateinit var app1Button: Button
    private lateinit var app2Button: Button
    private lateinit var launchButton: Button
    
    private var currentApp = -1
    private var shellService: IShellService? = null
    private var isBound = false

    // Connection to the Shell Service (Running inside Shizuku)
    private val userServiceConnection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, binder: IBinder?) {
            Log.i(TAG, "Shizuku Service Connected")
            shellService = IShellService.Stub.asInterface(binder)
            isBound = true
            launchButton.text = "LAUNCH SPLIT (Ready)"
        }

        override fun onServiceDisconnected(name: ComponentName?) {
            Log.w(TAG, "Shizuku Service Disconnected")
            shellService = null
            isBound = false
            launchButton.text = "LAUNCH SPLIT (Disconnected)"
        }
    }

    // Listener 1: When Shizuku itself starts/connects
    private val binderReceivedListener = Shizuku.OnBinderReceivedListener {
        checkShizukuStatus()
    }

    // Listener 2: When user grants permission
    private val requestPermissionResultListener = Shizuku.OnRequestPermissionResultListener { _, grantResult ->
        checkShizukuStatus()
    }

    private val appSelectLauncher = registerForActivityResult(
        ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == Activity.RESULT_OK) {
            val pkg = result.data?.getStringExtra(MainActivity.SELECTED_APP_PACKAGE)
            if (pkg != null) {
                val simple = AppPreferences.getSimpleName(pkg)
                if (currentApp == 1) {
                    app1Package = pkg
                    app1Button.text = "App 1: $simple"
                    AppPreferences.savePackage(this, SPLIT1_KEY, pkg)
                } else if (currentApp == 2) {
                    app2Package = pkg
                    app2Button.text = "App 2: $simple"
                    AppPreferences.savePackage(this, SPLIT2_KEY, pkg)
                }
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_split)

        app1Button = findViewById(R.id.app1_button)
        app2Button = findViewById(R.id.app2_button)
        launchButton = findViewById(R.id.launch_button_split)
        
        loadSavedApps()

        app1Button.setOnClickListener { currentApp = 1; launchAppPicker() }
        app2Button.setOnClickListener { currentApp = 2; launchAppPicker() }

        launchButton.setOnClickListener {
            if (app1Package != null && app2Package != null) {
                launchSplitApps()
            } else {
                Toast.makeText(this, "Select two apps.", Toast.LENGTH_SHORT).show()
            }
        }

        // Add Listeners
        Shizuku.addBinderReceivedListener(binderReceivedListener)
        Shizuku.addRequestPermissionResultListener(requestPermissionResultListener)
        
        // Initial Check
        checkShizukuStatus()
    }

    private fun checkShizukuStatus() {
        if (Shizuku.getBinder() == null) {
            // Shizuku not attached yet
            launchButton.text = "Waiting for Shizuku..."
            return
        }

        if (Shizuku.checkSelfPermission() == PackageManager.PERMISSION_GRANTED) {
            bindShizukuService()
        } else {
            launchButton.text = "Requesting Permission..."
            Shizuku.requestPermission(0)
        }
    }

    private fun bindShizukuService() {
        if (isBound) return
        
        try {
            val component = ComponentName(packageName, ShellUserService::class.java.name)
            // VERSION CODE 1 (Matches BuildConfig.VERSION_CODE usually)
            ShizukuBinder.bind(component, userServiceConnection, true, 1)
            launchButton.text = "Binding..."
        } catch (e: Exception) {
            Log.e(TAG, "Bind Failed", e)
            launchButton.text = "Bind Failed"
        }
    }

    private fun loadSavedApps() {
        app1Package = AppPreferences.loadPackage(this, SPLIT1_KEY)
        app1Button.text = "App 1: ${AppPreferences.getSimpleName(app1Package)}"
        app2Package = AppPreferences.loadPackage(this, SPLIT2_KEY)
        app2Button.text = "App 2: ${AppPreferences.getSimpleName(app2Package)}"
    }

    override fun onDestroy() {
        super.onDestroy()
        Shizuku.removeBinderReceivedListener(binderReceivedListener)
        Shizuku.removeRequestPermissionResultListener(requestPermissionResultListener)
        
        if (isBound) {
            val component = ComponentName(packageName, ShellUserService::class.java.name)
            ShizukuBinder.unbind(component, userServiceConnection)
            isBound = false
        }
    }

    private fun launchAppPicker() {
        appSelectLauncher.launch(Intent(this, MainActivity::class.java))
    }

    private fun launchSplitApps() {
        val metrics = windowManager.maximumWindowMetrics
        val w = metrics.bounds.width()
        val h = metrics.bounds.height()
        val left = Rect(0, 0, w / 2, h)
        val right = Rect(w / 2, 0, w, h)

        if (isBound && shellService != null) {
            launchButton.text = "LAUNCHING..."
            Thread {
                try {
                    shellService?.forceStop(app1Package)
                    shellService?.forceStop(app2Package)
                    Thread.sleep(400)
                    runOnUiThread {
                        launchApp(app1Package!!, left)
                        launchApp(app2Package!!, right)
                        launchButton.text = "LAUNCH SPLIT"
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Remote Call Failed", e)
                }
            }.start()
        } else {
            Toast.makeText(this, "Shizuku NOT READY. Launching anyway.", Toast.LENGTH_LONG).show()
            checkShizukuStatus() // Try connecting again
            launchApp(app1Package!!, left)
            launchApp(app2Package!!, right)
        }
    }

    private fun launchApp(packageName: String, bounds: Rect) {
        try {
            val intent = packageManager.getLaunchIntentForPackage(packageName)
            if (intent == null) return
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)
            val options = ActivityOptions.makeBasic().setLaunchBounds(bounds)
            startActivity(intent, options.toBundle())
        } catch (e: Exception) {
            Log.e(TAG, "Launch error", e)
        }
    }
}
```

## File: Cover-Screen-Launcher/app/src/main/java/com/example/quadrantlauncher/TriSplitActivity.kt
```kotlin
package com.example.quadrantlauncher

import android.app.Activity
import android.app.ActivityOptions
import android.content.Intent
import android.content.pm.PackageManager
import android.graphics.Rect
import android.os.Bundle
import android.util.Log
import android.widget.Button
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import rikka.shizuku.Shizuku

class TriSplitActivity : AppCompatActivity() {

    companion object {
        const val TRI1_KEY = "TRI1_PACKAGE"
        const val TRI2_KEY = "TRI2_PACKAGE"
        const val TRI3_KEY = "TRI3_PACKAGE"
    }

    private var app1Package: String? = null
    private var app2Package: String? = null
    private var app3Package: String? = null

    private lateinit var app1Button: Button
    private lateinit var app2Button: Button
    private lateinit var app3Button: Button
    private lateinit var launchButton: Button

    private var currentApp = -1
    private var hasShizukuPermission = false

    private val REQUEST_PERMISSION_RESULT_LISTENER =
        Shizuku.OnRequestPermissionResultListener { requestCode, grantResult ->
            if (requestCode == ShizukuHelper.SHIZUKU_PERMISSION_REQUEST_CODE) {
                hasShizukuPermission = grantResult == PackageManager.PERMISSION_GRANTED
                checkShizukuPermission()
            }
        }

    private val appSelectLauncher = registerForActivityResult(
        ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == Activity.RESULT_OK) {
            val pkg = result.data?.getStringExtra(MainActivity.SELECTED_APP_PACKAGE)
            if (pkg != null) {
                val simple = AppPreferences.getSimpleName(pkg)
                when (currentApp) {
                    1 -> {
                        app1Package = pkg
                        app1Button.text = "App 1: $simple"
                        AppPreferences.savePackage(this, TRI1_KEY, pkg)
                    }
                    2 -> {
                        app2Package = pkg
                        app2Button.text = "App 2: $simple"
                        AppPreferences.savePackage(this, TRI2_KEY, pkg)
                    }
                    3 -> {
                        app3Package = pkg
                        app3Button.text = "App 3: $simple"
                        AppPreferences.savePackage(this, TRI3_KEY, pkg)
                    }
                }
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Shizuku.addRequestPermissionResultListener(REQUEST_PERMISSION_RESULT_LISTENER)
        setContentView(R.layout.activity_tri_split)

        app1Button = findViewById(R.id.app1_button_tri)
        app2Button = findViewById(R.id.app2_button_tri)
        app3Button = findViewById(R.id.app3_button_tri)
        launchButton = findViewById(R.id.launch_button_tri_split)

        loadSavedApps()

        app1Button.setOnClickListener { currentApp = 1; pickApp() }
        app2Button.setOnClickListener { currentApp = 2; pickApp() }
        app3Button.setOnClickListener { currentApp = 3; pickApp() }

        launchButton.setOnClickListener {
            if (app1Package != null && app2Package != null && app3Package != null) {
                launchSplitApps()
            } else {
                Toast.makeText(this, "Select three apps.", Toast.LENGTH_SHORT).show()
            }
        }
        checkShizukuPermission()
    }

    private fun loadSavedApps() {
        app1Package = AppPreferences.loadPackage(this, TRI1_KEY)
        app1Button.text = "App 1: ${AppPreferences.getSimpleName(app1Package)}"
        app2Package = AppPreferences.loadPackage(this, TRI2_KEY)
        app2Button.text = "App 2: ${AppPreferences.getSimpleName(app2Package)}"
        app3Package = AppPreferences.loadPackage(this, TRI3_KEY)
        app3Button.text = "App 3: ${AppPreferences.getSimpleName(app3Package)}"
    }

    override fun onDestroy() {
        super.onDestroy()
        Shizuku.removeRequestPermissionResultListener(REQUEST_PERMISSION_RESULT_LISTENER)
    }

    private fun checkShizukuPermission() {
        if (ShizukuHelper.isShizukuAvailable()) {
            if (ShizukuHelper.hasPermission()) {
                hasShizukuPermission = true
            } else {
                ShizukuHelper.requestPermission()
            }
        }
    }

    private fun pickApp() {
        appSelectLauncher.launch(Intent(this, MainActivity::class.java))
    }

    private fun launchSplitApps() {
        val metrics = windowManager.maximumWindowMetrics
        val w = metrics.bounds.width()
        val h = metrics.bounds.height()
        val colWidth = w / 3

        val left = Rect(0, 0, colWidth, h)
        val middle = Rect(colWidth, 0, colWidth * 2, h)
        val right = Rect(colWidth * 2, 0, w, h)

        if (hasShizukuPermission) {
            Thread {
                ShizukuHelper.killApp(app1Package!!)
                ShizukuHelper.killApp(app2Package!!)
                ShizukuHelper.killApp(app3Package!!)
                try { Thread.sleep(400) } catch (e: InterruptedException) {}
                runOnUiThread {
                    launchAppIntent(app1Package!!, left)
                    launchAppIntent(app2Package!!, middle)
                    launchAppIntent(app3Package!!, right)
                }
            }.start()
        } else {
            launchAppIntent(app1Package!!, left)
            launchAppIntent(app2Package!!, middle)
            launchAppIntent(app3Package!!, right)
        }
    }

    private fun launchAppIntent(packageName: String, bounds: Rect) {
        try {
            val intent = packageManager.getLaunchIntentForPackage(packageName)
            if (intent == null) return

            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)
            val options = ActivityOptions.makeBasic().setLaunchBounds(bounds)
            startActivity(intent, options.toBundle())
        } catch (e: Exception) {
            Log.e("TriSplitActivity", "Failed to launch $packageName", e)
        }
    }
}
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/activity_main.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:background="#121212">

    <com.google.android.material.tabs.TabLayout
        android:id="@+id/tab_layout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="#1E1E1E"
        app:tabTextColor="#AAAAAA"
        app:tabSelectedTextColor="#FFFFFF"
        app:tabIndicatorColor="#3DDC84"
        app:tabMode="fixed"
        app:tabGravity="fill">
        <com.google.android.material.tabs.TabItem
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Favorites" />
        <com.google.android.material.tabs.TabItem
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Search" />
        <com.google.android.material.tabs.TabItem
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="All Apps" />
    </com.google.android.material.tabs.TabLayout>

    <EditText
        android:id="@+id/search_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="Search Apps..."
        android:textColor="#FFFFFF"
        android:textColorHint="#888888"
        android:padding="12dp"
        android:layout_margin="8dp"
        android:background="@android:drawable/editbox_background"
        android:drawableStart="@android:drawable/ic_menu_search"
        android:drawablePadding="8dp"
        android:singleLine="true"
        android:visibility="gone" />

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/app_list_recycler_view"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:clipToPadding="false"
            android:paddingBottom="16dp"/>

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/az_recycler_view"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:background="#333333"
            android:visibility="gone" />
            
        <TextView
            android:id="@+id/empty_view"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:text="No apps found"
            android:visibility="gone"
            android:textSize="18sp"
            android:textColor="#AAAAAA"/>

    </FrameLayout>

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/activity_split.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/root_layout_split"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp"
    tools:context=".SplitActivity">

    <Button
        android:id="@+id/app1_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Select App 1 (Left)" />

    <Button
        android:id="@+id/app2_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Select App 2 (Right)" />

    <View
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" />

    <Button
        android:id="@+id/launch_button_split"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="LAUNCH SPLIT"
        style="@style/Widget.AppCompat.Button.Colored" />

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/item_app_rofi.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="10dp"
    android:gravity="center_vertical"
    android:background="@drawable/bg_item_press">

    <ImageView
        android:id="@+id/rofi_app_icon"
        android:layout_width="24dp"
        android:layout_height="24dp"
        android:src="@mipmap/ic_launcher_round"
        android:layout_marginEnd="12dp" />

    <TextView
        android:id="@+id/rofi_app_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:text="App Name"
        android:textColor="#FFFFFF"
        android:textSize="16sp" />

    <ImageView
        android:id="@+id/rofi_app_star"
        android:layout_width="16dp"
        android:layout_height="16dp"
        android:src="@drawable/ic_star_filled"
        android:visibility="gone" />

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/item_custom_resolution.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp"
    android:gravity="center_vertical"
    android:background="@drawable/bg_item_press">

    <EditText
        android:id="@+id/input_res_w"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:hint="W"
        android:inputType="number"
        android:textColor="#FFFFFF"
        android:textColorHint="#888888"
        android:gravity="center"
        android:background="@null"
        android:imeOptions="actionNext"
        android:textSize="16sp"/>

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="x"
        android:textColor="#AAAAAA"
        android:paddingStart="8dp"
        android:paddingEnd="8dp"/>

    <EditText
        android:id="@+id/input_res_h"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:hint="H"
        android:inputType="number"
        android:textColor="#FFFFFF"
        android:textColorHint="#888888"
        android:gravity="center"
        android:background="@null"
        android:imeOptions="actionDone"
        android:textSize="16sp"/>

    <ImageView
        android:id="@+id/btn_save_res"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:padding="10dp"
        android:src="@android:drawable/ic_menu_save"
        android:tint="#00A0E9"
        android:background="?attr/selectableItemBackgroundBorderless"/>

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/item_dpi_custom.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp"
    android:gravity="center_vertical"
    android:background="@drawable/bg_item_press">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="DPI:"
        android:textColor="#888888"
        android:textSize="14sp"
        android:paddingEnd="8dp"/>

    <SeekBar
        android:id="@+id/sb_dpi_slider"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:max="900"
        android:progress="400"
        android:paddingStart="10dp"
        android:paddingEnd="10dp"/>

    <EditText
        android:id="@+id/input_dpi_value"
        android:layout_width="60dp"
        android:layout_height="wrap_content"
        android:inputType="number"
        android:maxLength="3"
        android:text="400"
        android:gravity="center"
        android:textColor="#FFFFFF"
        android:textSize="16sp"
        android:imeOptions="actionDone"
        android:background="@null"/>

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/item_font_size.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp"
    android:gravity="center_vertical"
    android:background="@drawable/bg_item_press">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Font Size:"
        android:textColor="#FFFFFF"
        android:textSize="16sp"
        android:layout_marginEnd="8dp"/>

    <TextView
        android:id="@+id/text_font_value"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:text="16"
        android:textColor="#FFFFFF"
        android:textSize="18sp"/>

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="sp"
        android:textColor="#888888"
        android:textSize="12sp"
        android:paddingEnd="8dp"/>

    <ImageView
        android:id="@+id/btn_font_minus"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:padding="10dp"
        android:src="@android:drawable/ic_input_delete"
        android:tint="#FF5555"
        android:background="?attr/selectableItemBackgroundBorderless"/>

    <ImageView
        android:id="@+id/btn_font_plus"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:padding="10dp"
        android:src="@android:drawable/ic_input_add"
        android:tint="#3DDC84"
        android:background="?attr/selectableItemBackgroundBorderless"/>

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/item_height_setting.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp"
    android:gravity="center_vertical"
    android:background="@drawable/bg_item_press">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Height:"
        android:textColor="#FFFFFF"
        android:textSize="16sp"
        android:layout_marginEnd="8dp"/>

    <TextView
        android:id="@+id/text_height_value"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:text="70"
        android:textColor="#FFFFFF"
        android:textSize="18sp"/>

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="%"
        android:textColor="#888888"
        android:textSize="12sp"
        android:paddingEnd="8dp"/>

    <ImageView
        android:id="@+id/btn_height_minus"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:padding="10dp"
        android:src="@android:drawable/ic_input_delete"
        android:tint="#FF5555"
        android:background="?attr/selectableItemBackgroundBorderless"/>

    <ImageView
        android:id="@+id/btn_height_plus"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:padding="10dp"
        android:src="@android:drawable/ic_input_add"
        android:tint="#3DDC84"
        android:background="?attr/selectableItemBackgroundBorderless"/>

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/item_icon_setting.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="12dp"
    android:gravity="center_vertical"
    android:background="@drawable/bg_item_press">

    <TextView
        android:id="@+id/icon_setting_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:text="Launcher Icon"
        android:textColor="#FFFFFF"
        android:textSize="16sp" />

    <ImageView
        android:id="@+id/icon_setting_preview"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:src="@mipmap/ic_launcher_round"
        android:background="@drawable/bg_item_active"
        android:padding="2dp"
        android:clipToOutline="true"/>

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/item_profile_rich.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="10dp"
    android:layout_marginBottom="4dp"
    android:background="@drawable/bg_item_press">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:layout_marginBottom="4dp">

        <EditText
            android:id="@+id/profile_name_text"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Profile Name"
            android:textColor="#FFFFFF"
            android:textStyle="bold"
            android:textSize="16sp"
            android:background="@null"
            android:singleLine="true"
            android:imeOptions="actionDone"
            android:padding="4dp"
            android:clickable="false"
            android:focusable="false"
            android:longClickable="false"
            android:focusableInTouchMode="false"/>

        <ImageView
            android:id="@+id/btn_save_profile_rich"
            android:layout_width="28dp"
            android:layout_height="28dp"
            android:src="@android:drawable/ic_menu_save"
            android:tint="#00A0E9"
            android:visibility="gone"/>
    </LinearLayout>

    <LinearLayout
        android:id="@+id/profile_icons_container"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginBottom="4dp" />

    <TextView
        android:id="@+id/profile_details_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Details"
        android:textColor="#AAAAAA"
        android:textSize="12sp" />

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/item_width_setting.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp"
    android:gravity="center_vertical"
    android:background="@drawable/bg_item_press">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Width:"
        android:textColor="#FFFFFF"
        android:textSize="16sp"
        android:layout_marginEnd="8dp"/>

    <TextView
        android:id="@+id/text_width_value"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:text="90"
        android:textColor="#FFFFFF"
        android:textSize="18sp"/>

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="%"
        android:textColor="#888888"
        android:textSize="12sp"
        android:paddingEnd="8dp"/>

    <ImageView
        android:id="@+id/btn_width_minus"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:padding="10dp"
        android:src="@android:drawable/ic_input_delete"
        android:tint="#FF5555"
        android:background="?attr/selectableItemBackgroundBorderless"/>

    <ImageView
        android:id="@+id/btn_width_plus"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:padding="10dp"
        android:src="@android:drawable/ic_input_add"
        android:tint="#3DDC84"
        android:background="?attr/selectableItemBackgroundBorderless"/>

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/layout_bubble.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="60dp"
    android:layout_height="60dp"
    android:background="@drawable/bg_bubble"
    android:filterTouchesWhenObscured="false"> 
    
    <ImageView
        android:id="@+id/bubble_icon"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:layout_gravity="center"
        android:src="@mipmap/ic_launcher_round" 
        android:clipToOutline="true"/>
</FrameLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/list_item_app.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="12dp"
    android:gravity="center_vertical"
    android:background="?attr/selectableItemBackground">

    <ImageView
        android:id="@+id/icon_star"
        android:layout_width="24dp"
        android:layout_height="24dp"
        android:src="@drawable/ic_star_border"
        android:layout_marginEnd="16dp"
        android:contentDescription="Favorite Star"
        android:tint="#FFFFFF" />

    <TextView
        android:id="@+id/app_name_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:textSize="18sp"
        android:textColor="#FFFFFF"
        android:text="App Name" />

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/xml/accessibility_service_config.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<accessibility-service xmlns:android="http://schemas.android.com/apk/res/android"
    android:description="@string/accessibility_service_description"
    android:accessibilityEventTypes="typeAllMask"
    android:accessibilityFeedbackType="feedbackGeneric"
    android:notificationTimeout="100"
    android:canRetrieveWindowContent="true"
    android:canPerformGestures="true" 
    android:canRequestFilterKeyEvents="true" 
    android:accessibilityFlags="flagRequestTouchExplorationMode|flagRequestFilterKeyEvents|flagRetrieveInteractiveWindows" />
```

## File: Cover-Screen-Launcher/app/build.gradle.kts
```kotlin
plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
}

android {
    namespace = "com.example.quadrantlauncher"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.katsuyamaki.DroidOSLauncher"
        minSdk = 30
        targetSdk = 34
        versionCode = 3
        versionName = "2.1"

        multiDexEnabled = true
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildFeatures {
        viewBinding = true
        buildConfig = true
        aidl = true
    }

    sourceSets {
        getByName("main") {
            aidl.srcDirs(listOf("src/main/aidl"))
            java.srcDirs(layout.buildDirectory.dir("generated/source/aidl/debug"))
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }
    kotlinOptions {
        jvmTarget = "11"
    }
}

dependencies {
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.appcompat)
    implementation(libs.material)
    implementation(libs.androidx.activity)
    implementation(libs.androidx.constraintlayout)
    
    implementation("dev.rikka.shizuku:api:13.1.5")
    implementation("dev.rikka.shizuku:provider:13.1.5")
    implementation("dev.rikka.shizuku:aidl:13.1.5")
}
```

## File: Cover-Screen-Launcher/.gitignore
```
*.iml
.gradle
/local.properties
/.idea/caches
/.idea/libraries
/.idea/modules.xml
/.idea/workspace.xml
/.idea/navEditor.xml
/.idea/assetWizardSettings.xml
.DS_Store
/build
/captures
.externalNativeBuild
.cxx
local.properties
*.iml
.gradle
/local.properties
/.idea
.DS_Store
/build
/captures
.externalNativeBuild
.cxx
```

## File: Cover-Screen-Launcher/gradlew
```
#!/bin/sh

#
# Copyright  2015 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions $var, ${var}, ${var:-default}, ${var+SET},
#           ${var#prefix}, ${var%suffix}, and $( cmd );
#         * compound commands having a testable exit status, especially case;
#         * various built-in commands including command, set, and ulimit.
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH="\\\"\\\""


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
```

## File: Cover-Screen-Launcher/multidex-keep.txt
```
rikka/shizuku/
```

## File: Cover-Screen-Launcher/README.md
```markdown
# CoverScreen Launcher & Tiling Manager

![Kotlin](https://img.shields.io/badge/Kotlin-2.0-blue.svg) ![Platform](https://img.shields.io/badge/Platform-Android%2014%2B-green.svg) ![Status](https://img.shields.io/badge/Status-Experimental-orange.svg)

**CoverScreen Launcher** is an advanced window manager and app launcher designed primarily for Samsung Galaxy Z Flip devices (and other foldables/external displays). 

It bypasses system restrictions to launch **any** application on the Cover Screen and provides desktop-like window tiling capabilities (Quadrants, Split Screen) that the stock OS does not support. It is also optimized for **AR Glasses** (XREAL, Rokid, Viture) by allowing the phone screen to be turned off while keeping the system running.

##  Key Features

###  Unrestricted Launching
- Bypasses the "Good Lock" / System Allowlist restriction.
- Launches *any* installed application directly on the Cover Screen (Display 1) using ADB Shell commands via Shizuku.

###  Advanced Window Tiling
Android's native split-screen on cover screens is limited. This app forces windows into specific geometries:
- **2 Apps (Side-by-Side):** Perfect vertical split.
- **2 Apps (Top-Bottom):** Horizontal split.
- **3 Apps (Tri-Split):** Evenly divided vertical columns.
- **4 Apps (Quadrant):** A 2x2 grid for maximum multitasking.

###  AR Glasses Mode ("Extinguish")
Designed for users of AR Glasses who use the phone as a computing unit/trackpad:
- **Screen Off, System On:** Turns off the physical display panel (to save battery and heat) without putting the CPU to sleep.
- **Targeted Control:** Can target specific displays (Main vs. Cover).
- **Trackpad Support:** Integrated toggle to reset/launch a specific Trackpad application when executing layouts.

###  Profiles
- Save your favorite app combinations and layout configurations.
- Quickly load specific workspaces (e.g., "Work" with Docs/Chrome, "Social" with Discord/Reddit).

---

##  Prerequisites

This app requires **Shizuku** to function, as it relies on elevated Shell permissions to manage windows and power states.

1.  **Shizuku:** Must be installed and running. [Download Shizuku](https://play.google.com/store/apps/details?id=moe.shizuku.privileged.api)
2.  **Developer Options Enabled:**
    * `Settings > About Phone > Software Information > Tap "Build Number" 7 times`.
3.  **Freeform Windows Enabled:**
    * In Developer Options, enable: **"Force activities to be resizable"**.
    * In Developer Options, enable: **"Enable freeform windows"**.
    * *Recommended:* Reboot device after changing these settings.

---

##  How It Works (Technical)

Standard Android APIs (`startActivity`) are blocked by Samsung on the Cover Screen for unapproved apps. This project uses a hybrid approach:

1.  **The Shotgun Launch:**
    * It attempts a standard API launch (for reliability on the main screen).
    * Simultaneously, it executes an `am start` shell command via Shizuku to force the activity onto `Display 1` (Cover Screen).

2.  **Post-Launch Resize (The "Magic" Fix):**
    * Android 14+ removed the ability to set window bounds during the launch command.
    * This app launches the app first, then scans the system using `dumpsys activity activities` to find the specific **Task ID** of the new window.
    * It then issues an `am task resize [taskId] [rect]` command to snap the window into the desired tile position.

3.  **Extinguish Mode:**
    * Uses Java Reflection to access the hidden `SurfaceControl` or `DisplayControl` system APIs.
    * Calls `setDisplayPowerMode(token, 0)` to cut power to the display panel hardware while leaving the OS active.

---

##  Installation

1.  Clone the repo or download the latest APK (check Releases).
2.  Install the APK on your Samsung Z Flip.
3.  Open **Shizuku** and start the service (via Wireless Debugging or Root).
4.  Open **CoverScreen Launcher** and grant Shizuku permission when prompted.
5.  Grant "Overlay Permission" if prompted (required for the floating menu).

---

##  Usage

1.  **Open the Menu:** Click the floating bubble to open the launcher drawer.
2.  **Select Apps:** Use the search bar to find apps. Click them to add to the launch queue.
3.  **Choose Layout:** Click the "Window" icon and select a layout (e.g., 4-Quadrant).
4.  **Launch:** Click the Green Play button.
    * *Note:* The app will cycle through your selected apps, launching them and then resizing them into position.
5.  **Extinguish (AR Mode):**
    * Go to Settings (Gear Icon).
    * Toggle "Target: Cover Screen".
    * Click the **Power Off** icon next to the toggle.
    * *To Wake:* Press Volume Up or the physical Power button.

---

##  Contributing

Pull requests are welcome!
* **Architecture:** Kotlin, Android Service, AIDL (for Shizuku IPC).
* **Key Files:** `FloatingLauncherService.kt` (Logic), `ShellUserService.kt` (Shizuku Commands).

##  License

[MIT License](LICENSE)
```

## File: Cover-Screen-Launcher/settings.gradle.kts
```kotlin
pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
    }
}
// ... (pluginManagement block is fine)
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
        maven { url = uri("https://www.jitpack.io") }
        maven { url = uri("https://maven.rikka.dev/versioned") }
    }
}
rootProject.name = "CoverScreenLauncher"
include(":app")

// DELETE ALL LINES BELOW THIS ONE
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/KeyboardActivity.kt
```kotlin
package com.example.coverscreentester

import android.app.Activity
import android.content.Intent
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.WindowManager
import android.widget.Button
import android.widget.EditText
import android.widget.TextView
import android.view.View

/**
 * A dedicated Activity to hold Keyboard Focus.
 * We use an Activity instead of a Service Overlay because Android 
 * aggressively kills keyboards attached to non-focusable windows 
 * or inactive displays.
 */
class KeyboardActivity : Activity() {

    private lateinit var inputField: EditText
    private lateinit var statusText: TextView

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Make window transparent
        window.setBackgroundDrawableResource(android.R.color.transparent)
        
        // Ensure we get focus
        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
        window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE or WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE)
        
        setContentView(R.layout.activity_keyboard)

        inputField = findViewById(R.id.et_remote_input)
        statusText = findViewById(R.id.tv_status)
        
        // Dismiss if user taps the transparent top area
        findViewById<View>(R.id.view_touch_dismiss).setOnClickListener {
            finish()
        }

        findViewById<Button>(R.id.btn_close).setOnClickListener {
            finish()
        }

        findViewById<Button>(R.id.btn_clear).setOnClickListener {
            inputField.setText("")
        }

        inputField.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                if (count > 0 && s != null) {
                    val char = s[start]
                    sendCharToService(char)
                }
            }
            override fun afterTextChanged(s: Editable?) {
                // Do NOT clear text automatically. It causes keyboard flicker.
            }
        })
        
        inputField.requestFocus()
    }

    private fun sendCharToService(c: Char) {
        val intent = Intent("INJECT_CHAR")
        intent.setPackage(packageName)
        intent.putExtra("CHAR", c)
        sendBroadcast(intent)
    }
}
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/KeyboardPickerActivity.kt
```kotlin
package com.example.coverscreentester

import android.app.Activity
import android.content.Context
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.view.View
import android.view.inputmethod.InputMethodManager

class KeyboardPickerActivity : Activity() {
    
    private var hasLaunchedPicker = false
    private var pickerWasOpened = false

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Transparent touchable view
        val view = View(this)
        view.setBackgroundColor(0x00000000) 
        view.isClickable = true
        
        // Safety Net: If logic fails, user can tap screen to close
        view.setOnClickListener { finish() }
        setContentView(view)
        
        // Launch picker after window is ready
        Handler(Looper.getMainLooper()).postDelayed({
            if (!isFinishing) launchPicker()
        }, 300)
    }

    private fun launchPicker() {
        if (hasLaunchedPicker) return
        try {
            val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
            imm.showInputMethodPicker()
            hasLaunchedPicker = true
        } catch (e: Exception) {
            e.printStackTrace()
            finish()
        }
    }

    override fun onWindowFocusChanged(hasFocus: Boolean) {
        super.onWindowFocusChanged(hasFocus)
        
        if (hasLaunchedPicker) {
            if (!hasFocus) {
                // We lost focus -> The Picker Dialog is now showing
                pickerWasOpened = true
            } else if (hasFocus && pickerWasOpened) {
                // We regained focus -> The Picker Dialog just closed
                // We are done.
                finish()
            }
        }
    }
}
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/KeyboardUtils.kt
```kotlin
package com.example.coverscreentester

import android.view.KeyEvent

object KeyboardUtils {

    // Special IDs for logic
    const val KEY_SHIFT = -100
    const val KEY_SYM = -101
    const val KEY_SPACE = KeyEvent.KEYCODE_SPACE
    const val KEY_DEL = KeyEvent.KEYCODE_DEL
    const val KEY_ENTER = KeyEvent.KEYCODE_ENTER
    
    // Arrows
    const val KEY_UP = KeyEvent.KEYCODE_DPAD_UP
    const val KEY_DOWN = KeyEvent.KEYCODE_DPAD_DOWN
    const val KEY_LEFT = KeyEvent.KEYCODE_DPAD_LEFT
    const val KEY_RIGHT = KeyEvent.KEYCODE_DPAD_RIGHT

    data class KeyDef(val label: String, val code: Int, val widthWeight: Float = 1.0f)

    val ROW_1_LOWER = listOf(
        KeyDef("q", KeyEvent.KEYCODE_Q), KeyDef("w", KeyEvent.KEYCODE_W), KeyDef("e", KeyEvent.KEYCODE_E),
        KeyDef("r", KeyEvent.KEYCODE_R), KeyDef("t", KeyEvent.KEYCODE_T), KeyDef("y", KeyEvent.KEYCODE_Y),
        KeyDef("u", KeyEvent.KEYCODE_U), KeyDef("i", KeyEvent.KEYCODE_I), KeyDef("o", KeyEvent.KEYCODE_O), KeyDef("p", KeyEvent.KEYCODE_P)
    )
    
    val ROW_2_LOWER = listOf(
        KeyDef("a", KeyEvent.KEYCODE_A), KeyDef("s", KeyEvent.KEYCODE_S), KeyDef("d", KeyEvent.KEYCODE_D),
        KeyDef("f", KeyEvent.KEYCODE_F), KeyDef("g", KeyEvent.KEYCODE_G), KeyDef("h", KeyEvent.KEYCODE_H),
        KeyDef("j", KeyEvent.KEYCODE_J), KeyDef("k", KeyEvent.KEYCODE_K), KeyDef("l", KeyEvent.KEYCODE_L)
    )

    val ROW_3_LOWER = listOf(
        KeyDef("", KEY_SHIFT, 1.5f), KeyDef("z", KeyEvent.KEYCODE_Z), KeyDef("x", KeyEvent.KEYCODE_X),
        KeyDef("c", KeyEvent.KEYCODE_C), KeyDef("v", KeyEvent.KEYCODE_V), KeyDef("b", KeyEvent.KEYCODE_B),
        KeyDef("n", KeyEvent.KEYCODE_N), KeyDef("m", KeyEvent.KEYCODE_M), KeyDef("", KEY_DEL, 1.5f)
    )

    // UPPERCASE 
    val ROW_1_UPPER = ROW_1_LOWER.map { it.copy(label = it.label.uppercase()) }
    val ROW_2_UPPER = ROW_2_LOWER.map { it.copy(label = it.label.uppercase()) }
    val ROW_3_UPPER = ROW_3_LOWER.map { 
        if(it.label.length == 1) it.copy(label = it.label.uppercase()) else it 
    }

    // SYMBOLS
    val ROW_1_SYM = listOf(
        KeyDef("1", KeyEvent.KEYCODE_1), KeyDef("2", KeyEvent.KEYCODE_2), KeyDef("3", KeyEvent.KEYCODE_3),
        KeyDef("4", KeyEvent.KEYCODE_4), KeyDef("5", KeyEvent.KEYCODE_5), KeyDef("6", KeyEvent.KEYCODE_6),
        KeyDef("7", KeyEvent.KEYCODE_7), KeyDef("8", KeyEvent.KEYCODE_8), KeyDef("9", KeyEvent.KEYCODE_9), KeyDef("0", KeyEvent.KEYCODE_0)
    )
    
    val ROW_2_SYM = listOf(
        KeyDef("@", KeyEvent.KEYCODE_AT), KeyDef("#", KeyEvent.KEYCODE_POUND), KeyDef("$", KeyEvent.KEYCODE_4), // $ shares 4 shift usually, but we map roughly
        KeyDef("%", KeyEvent.KEYCODE_5), KeyDef("&", KeyEvent.KEYCODE_7), KeyDef("-", KeyEvent.KEYCODE_MINUS),
        KeyDef("+", KeyEvent.KEYCODE_PLUS), KeyDef("(", KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN), KeyDef(")", KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN)
    )
    
    val ROW_3_SYM = listOf(
        KeyDef("ABC", KEY_SYM, 1.5f), KeyDef("!", KeyEvent.KEYCODE_1), KeyDef("\"", KeyEvent.KEYCODE_APOSTROPHE),
        KeyDef("'", KeyEvent.KEYCODE_APOSTROPHE), KeyDef(":", KeyEvent.KEYCODE_SEMICOLON), KeyDef(";", KeyEvent.KEYCODE_SEMICOLON),
        KeyDef("/", KeyEvent.KEYCODE_SLASH), KeyDef("?", KeyEvent.KEYCODE_SLASH), KeyDef("", KEY_DEL, 1.5f)
    )

    val ROW_4 = listOf(
        KeyDef("?123", KEY_SYM, 1.5f),
        KeyDef(",", KeyEvent.KEYCODE_COMMA),
        KeyDef("SPACE", KEY_SPACE, 4.0f),
        KeyDef(".", KeyEvent.KEYCODE_PERIOD),
        KeyDef("", KEY_ENTER, 1.5f)
    )
    
    val ROW_5_ARROWS = listOf(
        KeyDef("HIDE", -999, 2.0f), // Hide
        KeyDef("", KEY_LEFT),
        KeyDef("", KEY_UP),
        KeyDef("", KEY_DOWN),
        KeyDef("", KEY_RIGHT)
    )
}
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/ManualAdjustActivity.kt
```kotlin
package com.example.coverscreentester

import android.app.Activity
import android.content.Intent
import android.graphics.Color
import android.os.Bundle
import android.widget.Button
import android.widget.TextView
import android.widget.Toast

class ManualAdjustActivity : Activity() {

    private var isMoveMode = true
    private var isKeyboardTarget = false
    private val STEP_SIZE = 10

    private lateinit var textMode: TextView
    private lateinit var btnToggle: Button
    private lateinit var btnToggleTarget: Button

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_manual_adjust)

        textMode = findViewById(R.id.text_mode)
        btnToggle = findViewById(R.id.btn_toggle_mode)
        btnToggleTarget = findViewById(R.id.btn_toggle_target)

        updateModeUI()

        btnToggle.setOnClickListener {
            isMoveMode = !isMoveMode
            updateModeUI()
        }

        btnToggleTarget.setOnClickListener {
            isKeyboardTarget = !isKeyboardTarget
            updateModeUI()
        }

        findViewById<Button>(R.id.btn_up).setOnClickListener { sendAdjust(0, -STEP_SIZE) }
        findViewById<Button>(R.id.btn_down).setOnClickListener { sendAdjust(0, STEP_SIZE) }
        findViewById<Button>(R.id.btn_left).setOnClickListener { sendAdjust(-STEP_SIZE, 0) }
        findViewById<Button>(R.id.btn_right).setOnClickListener { sendAdjust(STEP_SIZE, 0) }

        // RESET BUTTON
        findViewById<Button>(R.id.btn_center).setOnClickListener {
            val targetStr = if (isKeyboardTarget) "KEYBOARD" else "TRACKPAD"
            Toast.makeText(this, "Resetting $targetStr", Toast.LENGTH_SHORT).show()

            val intent = Intent(this, OverlayService::class.java)
            intent.action = "RESET_POSITION"
            intent.putExtra("TARGET", targetStr)
            startService(intent)
        }

        // ROTATE BUTTON
        findViewById<Button>(R.id.btn_rotate).setOnClickListener {
            val targetStr = if (isKeyboardTarget) "KEYBOARD" else "TRACKPAD"
            val intent = Intent(this, OverlayService::class.java)
            intent.action = "ROTATE"
            intent.putExtra("TARGET", targetStr)
            startService(intent)
        }

        findViewById<Button>(R.id.btn_back).setOnClickListener { finish() }
    }

    private fun updateModeUI() {
        val targetText = if (isKeyboardTarget) "KEYBOARD" else "TRACKPAD"
        val actionText = if (isMoveMode) "POSITION" else "SIZE"

        textMode.text = "$targetText: $actionText"

        if (isKeyboardTarget) {
            textMode.setTextColor(Color.MAGENTA)
            btnToggleTarget.text = "Target: KEYBOARD"
        } else {
            textMode.setTextColor(if (isMoveMode) Color.GREEN else Color.CYAN)
            btnToggleTarget.text = "Target: TRACKPAD"
        }

        btnToggle.text = if (isMoveMode) "Mode: Position" else "Mode: Size"
    }

    private fun sendAdjust(xChange: Int, yChange: Int) {
        val intent = Intent(this, OverlayService::class.java)
        intent.action = "MANUAL_ADJUST"
        intent.putExtra("TARGET", if (isKeyboardTarget) "KEYBOARD" else "TRACKPAD")

        if (isMoveMode) {
            intent.putExtra("DX", xChange)
            intent.putExtra("DY", yChange)
        } else {
            intent.putExtra("DW", xChange)
            intent.putExtra("DH", yChange)
        }
        startService(intent)
    }
}
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/ProfilesActivity.kt
```kotlin
package com.example.coverscreentester

import android.app.Activity
import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.util.DisplayMetrics
import android.view.Gravity
import android.view.ViewGroup
import android.widget.Button
import android.widget.TextView
import android.widget.Toast

class ProfilesActivity : Activity() {

    private lateinit var tvStats: TextView
    private lateinit var tvList: TextView
    private lateinit var btnSave: Button
    private lateinit var btnReset: Button
    private lateinit var btnClose: Button

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_profiles)

        // FORCE WINDOW SIZE
        try {
            val dm = resources.displayMetrics
            val targetWidth = (450 * dm.density).toInt().coerceAtMost(dm.widthPixels)
            window.setLayout(targetWidth, ViewGroup.LayoutParams.MATCH_PARENT)
            window.setGravity(Gravity.CENTER)
        } catch (e: Exception) {}

        tvStats = findViewById(R.id.tvCurrentStats)
        tvList = findViewById(R.id.tvProfileList)
        btnSave = findViewById(R.id.btnSaveCurrent)
        btnReset = findViewById(R.id.btnResetCurrent)
        btnClose = findViewById(R.id.btnClose)

        refreshUI()

        btnSave.setOnClickListener {
            val intent = Intent(this, OverlayService::class.java)
            intent.action = "SAVE_LAYOUT"
            startService(intent)
            Toast.makeText(this, "Saved for this Aspect Ratio!", Toast.LENGTH_SHORT).show()
            tvList.postDelayed({ refreshUI() }, 500)
        }

        btnReset.setOnClickListener {
            val intent = Intent(this, OverlayService::class.java)
            intent.action = "DELETE_PROFILE"
            startService(intent)
            Toast.makeText(this, "Profile Deleted. Resetting...", Toast.LENGTH_SHORT).show()
            tvList.postDelayed({ refreshUI() }, 500)
        }

        btnClose.setOnClickListener { finish() }
    }

    private fun refreshUI() {
        val metrics = DisplayMetrics()
        windowManager.defaultDisplay.getRealMetrics(metrics)
        
        val width = metrics.widthPixels.toFloat()
        val height = metrics.heightPixels.toFloat()
        val ratio = width / height
        val ratioKey = String.format("%.1f", ratio)
        
        tvStats.text = "Ratio: $ratioKey\nRes: ${metrics.widthPixels} x ${metrics.heightPixels}\nDensity: ${metrics.density}"

        val prefs = getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
        val allEntries = prefs.all
        val sb = StringBuilder()
        
        val foundProfiles = HashSet<String>()
        
        for (key in allEntries.keys) {
            if (key.startsWith("profile_") && key.endsWith("_xp")) {
                val parts = key.split("_")
                if (parts.size >= 2) {
                    foundProfiles.add(parts[1])
                }
            }
        }
        
        if (foundProfiles.isEmpty()) {
            sb.append("No saved profiles.")
        } else {
            for (p in foundProfiles) {
                sb.append(" Ratio $p: Saved\n")
            }
        }
        
        tvList.text = sb.toString()
    }
}
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/ShizukuBinder.java
```java
package com.example.coverscreentester;

import android.content.ComponentName;
import android.content.ServiceConnection;
import rikka.shizuku.Shizuku;

public class ShizukuBinder {
    
    public static void bind(ComponentName component, ServiceConnection connection, boolean debug, int version) {
        Shizuku.UserServiceArgs args = new Shizuku.UserServiceArgs(component)
                .processNameSuffix("shell")
                .daemon(false)
                .debuggable(debug)
                .version(version);
        
        Shizuku.bindUserService(args, connection);
    }

    public static void unbind(ComponentName component, ServiceConnection connection) {
        Shizuku.UserServiceArgs args = new Shizuku.UserServiceArgs(component)
                .processNameSuffix("shell")
                .daemon(false);
        
        Shizuku.unbindUserService(args, connection, true); 
    }
}
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/SwipeTrailView.kt
```kotlin
package com.example.coverscreentester

import android.content.Context
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.Path
import android.view.View

// =================================================================================
// CLASS: SwipeTrailView
// SUMMARY: A custom View that renders a trail/path for swipe gestures.
//          Supports configurable trail color for:
//          - Blue (0x00A0E9) - Normal swipe typing trail
//          - Orange (0xFF9900) - Virtual mirror orientation trail
//          The view is non-interactive and passes all touches through.
// =================================================================================
class SwipeTrailView(context: Context) : View(context) {

    private val path = Path()
    private val paint = Paint().apply {
        color = Color.parseColor("#00A0E9") // DroidOS Blue (default)
        style = Paint.Style.STROKE
        strokeWidth = 12f
        strokeJoin = Paint.Join.ROUND
        strokeCap = Paint.Cap.ROUND
        isAntiAlias = true
        alpha = 180
    }

    init {
        // Important: Pass touches through this view so the keyboard underneath gets them
        isClickable = false
        isFocusable = false
    }

    // =================================================================================
    // FUNCTION: setTrailColor
    // SUMMARY: Sets the color of the trail. Used to differentiate between:
    //          - Blue trail for normal swipe typing
    //          - Orange trail for virtual mirror orientation mode
    // @param color - ARGB color integer (e.g., 0xFFFF9900 for orange)
    // =================================================================================
    fun setTrailColor(color: Int) {
        paint.color = color
        // Preserve alpha transparency
        paint.alpha = 180
        invalidate()
    }
    // =================================================================================
    // END BLOCK: setTrailColor
    // =================================================================================

    // =================================================================================
    // FUNCTION: resetToDefaultColor
    // SUMMARY: Resets trail color back to DroidOS blue (default swipe color).
    // =================================================================================
    fun resetToDefaultColor() {
        paint.color = Color.parseColor("#00A0E9")
        paint.alpha = 180
        invalidate()
    }
    // =================================================================================
    // END BLOCK: resetToDefaultColor
    // =================================================================================

    // =================================================================================
    // FUNCTION: addPoint
    // SUMMARY: Adds a point to the trail path. Called during touch move events.
    // @param x - X coordinate relative to the view
    // @param y - Y coordinate relative to the view
    // =================================================================================
    fun addPoint(x: Float, y: Float) {
        if (path.isEmpty) {
            path.moveTo(x, y)
        } else {
            path.lineTo(x, y)
        }
        invalidate()
    }
    // =================================================================================
    // END BLOCK: addPoint
    // =================================================================================

    // =================================================================================
    // FUNCTION: clear
    // SUMMARY: Clears the trail path. Called when swipe ends or orientation mode exits.
    // =================================================================================
    fun clear() {
        path.reset()
        invalidate()
    }
    // =================================================================================
    // END BLOCK: clear
    // =================================================================================

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        canvas.drawPath(path, paint)
    }
}
// =================================================================================
// END CLASS: SwipeTrailView
// =================================================================================
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/TrackpadMenuAdapter.kt
```kotlin
package com.example.coverscreentester

import android.graphics.Color
import android.util.TypedValue
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.GridLayout
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.SeekBar
import android.widget.Switch
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView

class TrackpadMenuAdapter(private val items: List<MenuItem>) : 
    RecyclerView.Adapter<TrackpadMenuAdapter.Holder>() {

    data class MenuItem(
        val title: String,
        val iconRes: Int,
        val type: Type,
        val initValue: Int = 0, // For sliders (0-100) or Toggles (0/1)
        val max: Int = 100,     // NEW: Custom max value for sliders
        val action: ((Any) -> Unit)? = null // Callback
    )

    enum class Type {
        ACTION, // Simple Click
        TOGGLE, // Switch
        SLIDER, // SeekBar
        DPAD,   // Directional Pad
        INFO,   // Text only
        HEADER, // Main Section Header (Bold, White)
        SUBHEADER // Sub-section Header (Small, Grey)
    }

    inner class Holder(v: View) : RecyclerView.ViewHolder(v) {
        val icon: ImageView = v.findViewById(R.id.item_icon)
        val title: TextView = v.findViewById(R.id.item_title)
        val valueText: TextView = v.findViewById(R.id.item_value_text)
        val switch: Switch = v.findViewById(R.id.item_switch)
        val actionIcon: ImageView = v.findViewById(R.id.item_action_icon)
        val slider: SeekBar = v.findViewById(R.id.item_seekbar)
        val dpadGrid: GridLayout = v.findViewById(R.id.item_dpad_grid)
        val helpText: TextView = v.findViewById(R.id.item_help_text)

        // D-Pad Buttons
        val btnUp: Button = v.findViewById(R.id.btn_up)
        val btnDown: Button = v.findViewById(R.id.btn_down)
        val btnLeft: Button = v.findViewById(R.id.btn_left)
        val btnRight: Button = v.findViewById(R.id.btn_right)
        val btnCenter: Button = v.findViewById(R.id.btn_center)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): Holder {
        val v = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_trackpad_menu, parent, false)
        return Holder(v)
    }

    override fun onBindViewHolder(holder: Holder, position: Int) {
        val item = items[position]
        
        // Reset Visibility & Style
        (holder.itemView as android.view.ViewGroup).getChildAt(0).visibility = View.VISIBLE
        holder.valueText.visibility = View.GONE
        holder.switch.visibility = View.GONE
        holder.actionIcon.visibility = View.GONE
        holder.slider.visibility = View.GONE
        holder.dpadGrid.visibility = View.GONE
        holder.helpText.visibility = View.GONE
        holder.title.visibility = View.VISIBLE
        holder.icon.visibility = View.VISIBLE
        
        holder.title.text = item.title
        holder.icon.setImageResource(item.iconRes)
        
        // Default text style (Reset)
        holder.title.setTypeface(null, android.graphics.Typeface.NORMAL)
        holder.title.setTextColor(Color.WHITE)
        holder.title.setTextSize(TypedValue.COMPLEX_UNIT_SP, 16f)
        
        // Reset Item Background/Padding
        holder.itemView.setBackgroundResource(R.drawable.bg_item_press)
        holder.itemView.setPadding(0,0,0,0) // Reset padding
        
        // Reset click listener
        holder.itemView.setOnClickListener(null)

        when (item.type) {
            Type.ACTION -> {
                holder.actionIcon.visibility = View.GONE
                holder.itemView.setOnClickListener { item.action?.invoke(true) }
            }
            Type.TOGGLE -> {
                holder.switch.visibility = View.VISIBLE
                holder.switch.isChecked = item.initValue == 1
                holder.switch.setOnCheckedChangeListener { _, isChecked ->
                    item.action?.invoke(isChecked)
                }
                holder.itemView.setOnClickListener { holder.switch.toggle() }
            }
            Type.SLIDER -> {
                holder.valueText.visibility = View.VISIBLE
                holder.slider.visibility = View.VISIBLE
                holder.slider.max = item.max
                holder.valueText.text = "${item.initValue}"
                holder.slider.progress = item.initValue
                
                holder.slider.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {
                    override fun onProgressChanged(s: SeekBar?, v: Int, fromUser: Boolean) {
                        if (fromUser) {
                            holder.valueText.text = "$v"
                            item.action?.invoke(v)
                        }
                    }
                    override fun onStartTrackingTouch(s: SeekBar?) {}
                    override fun onStopTrackingTouch(s: SeekBar?) {}
                })
            }
            Type.DPAD -> {
                holder.dpadGrid.visibility = View.VISIBLE
                holder.btnUp.setOnClickListener { item.action?.invoke("UP") }
                holder.btnDown.setOnClickListener { item.action?.invoke("DOWN") }
                holder.btnLeft.setOnClickListener { item.action?.invoke("LEFT") }
                holder.btnRight.setOnClickListener { item.action?.invoke("RIGHT") }
                holder.btnCenter.setOnClickListener { item.action?.invoke("CENTER") }
            }
            Type.INFO -> {
                (holder.itemView as android.view.ViewGroup).getChildAt(0).visibility = View.GONE
                holder.helpText.visibility = View.VISIBLE
                holder.helpText.text = item.title 
                holder.title.visibility = View.GONE 
                holder.icon.visibility = View.GONE
                holder.itemView.setBackgroundResource(android.R.color.transparent) // No press effect for INFO
            }
            Type.HEADER -> {
                holder.title.visibility = View.VISIBLE
                holder.title.text = item.title
                holder.title.setTypeface(null, android.graphics.Typeface.BOLD)
                holder.title.setTextSize(TypedValue.COMPLEX_UNIT_SP, 18f) // Larger
                holder.icon.visibility = View.GONE
                holder.itemView.setBackgroundResource(android.R.color.transparent) // No press effect
            }
            Type.SUBHEADER -> {
                holder.title.visibility = View.VISIBLE
                holder.title.text = item.title
                holder.title.setTypeface(null, android.graphics.Typeface.NORMAL)
                holder.title.setTextSize(TypedValue.COMPLEX_UNIT_SP, 13f) // Small
                holder.title.setTextColor(Color.parseColor("#AAAAAA")) // Grey
                holder.icon.visibility = View.GONE
                holder.itemView.setBackgroundResource(android.R.color.transparent) // No press effect
                // Optional: Add top margin if possible via params, or just rely on list order
            }
        }
    }

    override fun getItemCount(): Int = items.size
}
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/TrackpadService.kt
```kotlin
package com.example.coverscreentester

import android.app.Service
import android.content.Intent
import android.graphics.PixelFormat
import android.os.IBinder
import android.view.LayoutInflater
import android.view.View
import android.view.WindowManager
import android.widget.Button
import android.widget.Toast
import android.hardware.display.DisplayManager
import android.os.Build
import android.util.Log
import android.content.Context

class TrackpadService : Service() {

    private val TAG = "TrackpadService" // Define TAG

    private lateinit var windowManager: WindowManager
    private var trackpadView: View? = null 
    private var currentDisplayId: Int = 0

    override fun onBind(intent: Intent?): IBinder? {
        return null
    }

    /* * FUNCTION: onStartCommand
     * SUMMARY: Handles the "Recall" logic. If the service is already running but 
     * receives a different display ID, it destroys the old view and recreates 
     * it on the new display context.
     */
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val targetDisplayId = intent?.getIntExtra("TARGET_DISPLAY_ID", currentDisplayId) ?: currentDisplayId
        android.util.Log.d("TrackpadService", "onStartCommand: Target=$targetDisplayId, Current=$currentDisplayId")

        if (trackpadView != null) {
            // If display has changed, migrate the view
            if (targetDisplayId != currentDisplayId) {
                android.util.Log.d("TrackpadService", "Migrating Trackpad to Display $targetDisplayId")
                try {
                    windowManager.removeView(trackpadView)
                } catch (e: Exception) {
                    android.util.Log.e("TrackpadService", "Migration removeView failed", e)
                }
                trackpadView = null
                setupUI(targetDisplayId)
            }
        } else {
            // First time initialization
            android.util.Log.d("TrackpadService", "Initial setup on Display $targetDisplayId")
            setupUI(targetDisplayId)
        }
        
        return START_STICKY
    }

    override fun onCreate() {
        super.onCreate()
        android.util.Log.d("TrackpadService", "Service Created")
        setupShizuku() // This will be defined later
    }

    /* * FUNCTION: setupUI
     * SUMMARY: Creates a WindowManager context bound specifically to the 
     * requested displayId. This forces the view to the physical screen.
     */
    private fun setupUI(displayId: Int) {
        currentDisplayId = displayId
        val dm = getSystemService(Context.DISPLAY_SERVICE) as android.hardware.display.DisplayManager
        val targetDisplay = dm.getDisplay(displayId) ?: dm.getDisplay(0)
        
        // CRITICAL: Create context for the specific physical display
        val displayContext = createDisplayContext(targetDisplay)
        windowManager = displayContext.getSystemService(Context.WINDOW_SERVICE) as WindowManager

        val inflater = android.view.LayoutInflater.from(displayContext)
        trackpadView = inflater.inflate(R.layout.layout_trackpad, null)

        val params = WindowManager.LayoutParams(
            WindowManager.LayoutParams.MATCH_PARENT,
            WindowManager.LayoutParams.MATCH_PARENT,
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) 
                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY 
            else 
                WindowManager.LayoutParams.TYPE_PHONE,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or 
            WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,
            android.graphics.PixelFormat.TRANSLUCENT
        )

        setupTrackpadLogic(trackpadView!!)
        windowManager.addView(trackpadView, params)
    }

    private fun setupTrackpadLogic(view: View) {
        // Setup Safety Exit Button
        val closeBtn = view.findViewById<Button>(R.id.btn_close)
        closeBtn?.setOnClickListener {
            stopSelf()
        }

        // Setup Trackpad Touch Listener
        val trackpadArea = view.findViewById<View>(R.id.view_trackpad)
        trackpadArea?.setOnTouchListener { _, _ ->
            // This consumes the touch event so it doesn't pass through to the launcher
            // We will add the Shizuku injection logic here next.
            true
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        if (trackpadView != null) {
            try {
                windowManager.removeView(trackpadView)
            } catch (e: Exception) {
                e.printStackTrace()
            }
            trackpadView = null
        }
        Toast.makeText(this, "Trackpad Overlay Stopped", Toast.LENGTH_SHORT).show()
    }

    private fun setupShizuku() {
        // Placeholder for Shizuku setup logic
        // This will be implemented when Shizuku functionality is added.
        Log.d(TAG, "setupShizuku: Placeholder called.")
    }
}
```

## File: Cover-Screen-Trackpad/app/src/main/res/layout/activity_keyboard.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:gravity="bottom"
    android:background="#00000000">

    <View
        android:id="@+id/view_touch_dismiss"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:background="#00000000" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:background="#222222"
        android:padding="12dp">

        <TextView
            android:id="@+id/tv_status"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Remote Input Active"
            android:textColor="#AAAAAA"
            android:textSize="12sp"
            android:layout_marginBottom="8dp"/>

        <EditText
            android:id="@+id/et_remote_input"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="#333333"
            android:padding="12dp"
            android:textColor="#FFFFFF"
            android:hint="Type here..."
            android:textColorHint="#888888"
            android:inputType="textNoSuggestions|textVisiblePassword"
            android:imeOptions="flagNoExtractUi"
            android:minHeight="48dp"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="8dp">

            <Button
                android:id="@+id/btn_clear"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="Clear"
                android:backgroundTint="#FF9800"
                android:layout_marginEnd="4dp"/>

            <Button
                android:id="@+id/btn_close"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="Close"
                android:backgroundTint="#990000"
                android:layout_marginStart="4dp"/>
        </LinearLayout>
    </LinearLayout>
</LinearLayout>
```

## File: Cover-Screen-Trackpad/app/src/main/res/layout/activity_manual_adjust.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp"
    android:background="#121212"
    android:gravity="center">

    <TextView
        android:id="@+id/text_mode"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="TRACKPAD: POSITION"
        android:textColor="#00FF00"
        android:textSize="20sp"
        android:textStyle="bold"
        android:layout_marginBottom="24dp"/>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        android:layout_marginBottom="16dp">

        <Button
            android:id="@+id/btn_toggle_target"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Edit: Trackpad"
            android:layout_marginEnd="8dp"/>

        <Button
            android:id="@+id/btn_toggle_mode"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Mode: Position"/>
    </LinearLayout>

    <Button
        android:id="@+id/btn_up"
        android:layout_width="80dp"
        android:layout_height="60dp"
        android:text="UP"/>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center"
        android:layout_marginTop="8dp"
        android:layout_marginBottom="8dp">

        <Button
            android:id="@+id/btn_left"
            android:layout_width="80dp"
            android:layout_height="60dp"
            android:text="LEFT"
            android:layout_marginEnd="16dp"/>

        <Button
            android:id="@+id/btn_center"
            android:layout_width="80dp"
            android:layout_height="60dp"
            android:text="RESET"
            android:textColor="#FF9800"/>

        <Button
            android:id="@+id/btn_right"
            android:layout_width="80dp"
            android:layout_height="60dp"
            android:text="RIGHT"
            android:layout_marginStart="16dp"/>

    </LinearLayout>

    <Button
        android:id="@+id/btn_down"
        android:layout_width="80dp"
        android:layout_height="60dp"
        android:text="DOWN"/>

    <Button
        android:id="@+id/btn_rotate"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Rotate 90"
        android:layout_marginTop="24dp"/>

    <Button
        android:id="@+id/btn_back"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Done / Back"
        android:backgroundTint="#555555"
        android:layout_marginTop="16dp"/>

</LinearLayout>
```

## File: Cover-Screen-Trackpad/app/src/main/res/layout/activity_menu.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#121212"
    android:fillViewport="true">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="24dp"
        android:gravity="center_horizontal">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Trackpad Setup"
            android:textColor="#FFFFFF"
            android:textSize="24sp"
            android:textStyle="bold"
            android:layout_marginBottom="24dp" />

        <TextView
            android:id="@+id/tvStep1Title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Step 1: Initialize Restriction"
            android:textColor="#3DDC84"
            android:textStyle="bold"
            android:layout_marginBottom="8dp"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Disclosure: This app uses the AccessibilityService API to function as a trackpad. It simulates touch inputs (clicks and swipes) on the cover screen on your behalf. This app does not collect, store, or transmit any personal user data through this service."
            android:textColor="#DDDDDD"
            android:textSize="12sp"
            android:background="#222222"
            android:padding="12dp"
            android:layout_marginBottom="12dp"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Instructions: Find 'Cover Screen Trackpad' and tap it. If a 'Restricted Setting' dialog appears, click OK and proceed to Step 2. If it enables successfully, you can skip to Step 4."
            android:textColor="#AAAAAA"
            android:textSize="12sp"
            android:layout_marginBottom="8dp"/>

        <Button
            android:id="@+id/btnStep1Trigger"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Open Accessibility"
            android:backgroundTint="#333333"
            android:textColor="#FFFFFF"/>

        <View
            android:layout_width="match_parent"
            android:layout_height="1dp"
            android:background="#333333"
            android:layout_marginTop="16dp"
            android:layout_marginBottom="16dp"/>

        <TextView
            android:id="@+id/tvStep2Title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Step 2: Allow Restricted Settings"
            android:textColor="#3DDC84"
            android:textStyle="bold"
            android:layout_marginBottom="8dp"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="1. Click button below to open App Info.\n2. Tap the 3-dot menu (top right).\n3. Select 'Allow Restricted Settings'."
            android:textColor="#AAAAAA"
            android:textSize="12sp"
            android:layout_marginBottom="8dp"/>

        <Button
            android:id="@+id/btnStep2Unblock"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Open App Info"
            android:backgroundTint="#333333"
            android:textColor="#FFFFFF"/>

        <View
            android:layout_width="match_parent"
            android:layout_height="1dp"
            android:background="#333333"
            android:layout_marginTop="16dp"
            android:layout_marginBottom="16dp"/>

        <TextView
            android:id="@+id/tvStep3Title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Step 3: Enable Accessibility"
            android:textColor="#3DDC84"
            android:textStyle="bold"
            android:layout_marginBottom="8dp"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Go back to Accessibility and enable 'Cover Screen Trackpad'. It should now work."
            android:textColor="#AAAAAA"
            android:textSize="12sp"
            android:layout_marginBottom="8dp"/>

        <Button
            android:id="@+id/btnStep3Enable"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Grant Accessibility"
            android:backgroundTint="#333333"
            android:textColor="#FFFFFF"/>

        <View
            android:layout_width="match_parent"
            android:layout_height="1dp"
            android:background="#333333"
            android:layout_marginTop="16dp"
            android:layout_marginBottom="16dp"/>

        <!-- NEW: Step for Null Keyboard -->
        <TextView
            android:id="@+id/tvStepNullKeyboardTitle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Step 3.5: Enable Null Keyboard"
            android:textColor="#3DDC84"
            android:textStyle="bold"
            android:layout_marginBottom="8dp"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Required for keyboard input handling without blocking the screen. Enable 'DroidOS Null Keyboard' in the next screen."
            android:textColor="#AAAAAA"
            android:textSize="12sp"
            android:layout_marginBottom="8dp"/>

        <Button
            android:id="@+id/btnStepNullKeyboardEnable"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Enable Null Keyboard"
            android:backgroundTint="#333333"
            android:textColor="#FFFFFF"/>

        <View
            android:layout_width="match_parent"
            android:layout_height="1dp"
            android:background="#333333"
            android:layout_marginTop="16dp"
            android:layout_marginBottom="16dp"/>

        <TextView
            android:id="@+id/tvStep4Title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Step 4: Overlay Permission"
            android:textColor="#3DDC84"
            android:textStyle="bold"
            android:layout_marginBottom="8dp"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Disclosure: This app requires the 'Display over other apps' permission to render the mouse cursor and trackpad controls on top of your screen."
            android:textColor="#DDDDDD"
            android:textSize="12sp"
            android:background="#222222"
            android:padding="8dp"
            android:layout_marginBottom="8dp"/>

        <Button
            android:id="@+id/btnStep4Overlay"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Grant Overlay"
            android:backgroundTint="#333333"
            android:textColor="#FFFFFF"/>

        <View
            android:layout_width="match_parent"
            android:layout_height="1dp"
            android:background="#333333"
            android:layout_marginTop="16dp"
            android:layout_marginBottom="16dp"/>

        <TextView
            android:id="@+id/tvStep5Title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Step 5: Shizuku Permission"
            android:textColor="#3DDC84"
            android:textStyle="bold"
            android:layout_marginBottom="8dp"/>

        <Button
            android:id="@+id/btnStep5Shizuku"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Grant Shizuku"
            android:backgroundTint="#333333"
            android:textColor="#FFFFFF"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Note: If Shizuku permissions are lost, a red dot may appear in the app."
            android:textColor="#AAAAAA"
            android:textSize="11sp"
            android:layout_marginTop="8dp"
            android:layout_marginBottom="32dp"/>

        <Button
            android:id="@+id/btnStartApp"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="LAUNCH DROIDOS"
            android:backgroundTint="#009688"
            android:textColor="#FFFFFF"
            android:textStyle="bold"
            android:minHeight="60dp"
            android:layout_marginTop="8dp"/>

        <Button
            android:id="@+id/btnOpenSettings"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="OPEN DROIDOS SETTINGS"
            android:backgroundTint="#444444"
            android:textColor="#FFFFFF"
            android:textStyle="bold"
            android:minHeight="60dp"
            android:layout_marginTop="16dp"/>

    </LinearLayout>
</ScrollView>
```

## File: Cover-Screen-Trackpad/app/src/main/res/layout/activity_profiles.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#121212"
    android:fillViewport="true">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="24dp">

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Layout Profiles"
            android:textColor="#FFFFFF"
            android:textSize="24sp"
            android:textStyle="bold"
            android:layout_marginBottom="16dp"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="The app automatically detects screen changes (Cover Screen vs AR Glasses) and loads the matching layout."
            android:textColor="#AAAAAA"
            android:layout_marginBottom="24dp"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:background="#222222"
            android:padding="16dp"
            android:layout_marginBottom="24dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="CURRENT SCREEN"
                android:textColor="#FF9800"
                android:textStyle="bold"
                android:layout_marginBottom="8dp"/>

            <TextView
                android:id="@+id/tvCurrentStats"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="Ratio: 1.0"
                android:textColor="#FFFFFF"
                android:fontFamily="monospace"
                android:layout_marginBottom="16dp"/>

            <Button
                android:id="@+id/btnSaveCurrent"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="Save Current Position"
                android:backgroundTint="#3DDC84"
                android:textColor="#000000"
                android:textStyle="bold"
                android:layout_marginBottom="8dp"/>
                
            <Button
                android:id="@+id/btnResetCurrent"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="Delete Profile (Reset)"
                android:backgroundTint="#990000"
                android:textColor="#FFFFFF"/>
        </LinearLayout>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="ALL SAVED PROFILES"
            android:textColor="#AAAAAA"
            android:layout_marginBottom="8dp"/>
            
        <TextView
            android:id="@+id/tvProfileList"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="..."
            android:textColor="#FFFFFF"
            android:fontFamily="monospace"
            android:layout_marginBottom="24dp"/>

        <Button
            android:id="@+id/btnClose"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Back"
            android:backgroundTint="#444444"
            android:layout_marginBottom="40dp"/>

    </LinearLayout>
</ScrollView>
```

## File: Cover-Screen-Trackpad/app/src/main/res/layout/item_dpi_custom.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp"
    android:gravity="center_vertical"
    android:background="@drawable/bg_item_press">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="DPI:"
        android:textColor="#888888"
        android:textSize="14sp"
        android:paddingEnd="8dp"/>

    <EditText
        android:id="@+id/input_dpi_value"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:inputType="number"
        android:maxLength="3"
        android:text="120"
        android:textColor="#FFFFFF"
        android:textSize="18sp"
        android:imeOptions="actionDone"
        android:background="@null"/>

    <ImageView
        android:id="@+id/btn_dpi_minus"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:padding="10dp"
        android:src="@android:drawable/ic_input_delete"
        app:tint="#FF5555"
        android:background="?attr/selectableItemBackgroundBorderless"/>

    <ImageView
        android:id="@+id/btn_dpi_plus"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:padding="10dp"
        android:src="@android:drawable/ic_input_add"
        app:tint="#3DDC84"
        android:background="?attr/selectableItemBackgroundBorderless"/>

</LinearLayout>
```

## File: Cover-Screen-Trackpad/app/src/main/res/layout/layout_trackpad_bubble.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="60dp"
    android:layout_height="60dp"
    android:background="@drawable/bg_trackpad_bubble"
    android:clickable="true"
    android:focusable="true">

    <ImageView
        android:id="@+id/bubble_icon"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:layout_gravity="center"
        android:src="@mipmap/ic_trackpad_adaptive"
        android:contentDescription="Trackpad Menu" 
        android:clipToOutline="true"/>
        
    <ImageView
        android:id="@+id/status_dot"
        android:layout_width="12dp"
        android:layout_height="12dp"
        android:layout_gravity="top|end"
        android:layout_margin="10dp"
        android:src="@android:drawable/ic_notification_overlay"
        app:tint="#FF0000"
        android:visibility="gone" />

</FrameLayout>
```

## File: Cover-Screen-Trackpad/app/src/main/res/layout/layout_trackpad_drawer.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:background="@null"
    android:elevation="0dp">

    <LinearLayout
        android:id="@+id/menu_container"
        android:layout_width="320dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:background="@drawable/bg_trackpad_drawer"
        android:orientation="vertical"
        android:elevation="0dp"
        android:minHeight="300dp">

        <RelativeLayout
            android:id="@+id/menu_drag_handle"
            android:layout_width="match_parent"
            android:layout_height="50dp"
            android:background="#00000000"
            android:paddingEnd="12dp"
            android:clickable="true"
            android:focusable="true">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_centerVertical="true"
                android:layout_marginStart="16dp"
                android:text="DroidOS Trackpad Keyboard"
                android:textColor="#FFFFFF"
                android:textStyle="bold"
                android:textSize="16sp" />

            <ImageView
                android:id="@+id/btn_close_menu"
                android:layout_width="30dp"
                android:layout_height="30dp"
                android:layout_alignParentEnd="true"
                android:layout_centerVertical="true"
                android:background="?android:attr/selectableItemBackgroundBorderless"
                android:padding="6dp"
                android:src="@android:drawable/ic_menu_close_clear_cancel"
                app:tint="#FF5555" />
        </RelativeLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:orientation="horizontal">

            <ScrollView
                android:layout_width="56dp"
                android:layout_height="match_parent"
                android:background="#222222">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:paddingTop="8dp"
                    android:paddingBottom="8dp">

                    <ImageView
                        android:id="@+id/tab_main"
                        android:layout_width="match_parent"
                        android:layout_height="48dp"
                        android:padding="12dp"
                        android:src="@drawable/ic_cursor"
                        app:tint="#888888" />

                    <ImageView
                        android:id="@+id/tab_presets"
                        android:layout_width="match_parent"
                        android:layout_height="48dp"
                        android:padding="12dp"
                        android:src="@drawable/ic_tab_presets"
                        app:tint="#888888" />

                    <ImageView
                        android:id="@+id/tab_move"
                        android:layout_width="match_parent"
                        android:layout_height="48dp"
                        android:padding="12dp"
                        android:src="@drawable/ic_tab_move"
                        app:tint="#888888" />

                    <ImageView
                        android:id="@+id/tab_kb_move"
                        android:layout_width="match_parent"
                        android:layout_height="48dp"
                        android:padding="12dp"
                        android:src="@drawable/ic_tab_kb_move"
                        app:tint="#888888" />

                    <ImageView
                        android:id="@+id/tab_mirror"
                        android:layout_width="match_parent"
                        android:layout_height="48dp"
                        android:padding="12dp"
                        android:src="@drawable/ic_tab_kb_move"
                        app:tint="#888888" />

                    <ImageView
                        android:id="@+id/tab_config"
                        android:layout_width="match_parent"
                        android:layout_height="48dp"
                        android:padding="12dp"
                        android:src="@drawable/ic_tab_config"
                        app:tint="#888888" />

                    <ImageView
                        android:id="@+id/tab_tune"
                        android:layout_width="match_parent"
                        android:layout_height="48dp"
                        android:padding="12dp"
                        android:src="@drawable/ic_tab_tune"
                        app:tint="#888888" />

                    <ImageView
                        android:id="@+id/tab_hardkeys"
                        android:layout_width="match_parent"
                        android:layout_height="48dp"
                        android:padding="12dp"
                        android:src="@drawable/ic_tab_hardkeys"
                        app:tint="#888888" />

                    <ImageView
                        android:id="@+id/tab_bubble"
                        android:layout_width="match_parent"
                        android:layout_height="48dp"
                        android:padding="12dp"
                        android:src="@drawable/ic_tab_bubble"
                        app:tint="#888888" />

                    <ImageView
                        android:id="@+id/tab_profiles"
                        android:layout_width="match_parent"
                        android:layout_height="48dp"
                        android:padding="12dp"
                        android:src="@drawable/ic_tab_profiles"
                        app:tint="#888888" />

                    <ImageView
                        android:id="@+id/tab_help"
                        android:layout_width="match_parent"
                        android:layout_height="48dp"
                        android:padding="12dp"
                        android:src="@drawable/ic_tab_help"
                        app:tint="#888888" />

                </LinearLayout>
            </ScrollView>

            <androidx.recyclerview.widget.RecyclerView
                android:id="@+id/menu_recycler"
                android:layout_width="match_parent"
                android:layout_height="350dp"
                android:padding="8dp"
                android:scrollbars="vertical" />

        </LinearLayout>

    </LinearLayout>
</FrameLayout>
```

## File: Cover-Screen-Trackpad/app/src/main/res/layout/layout_trackpad.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#99000000">

    <View
        android:id="@+id/touchArea"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clickable="true"
        android:focusable="true" />

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp"
        android:layout_gravity="top|start"
        android:background="#CC000000"
        android:layout_margin="16dp"
        android:elevation="10dp">

        <TextView
            android:id="@+id/statusText"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Target: Local"
            android:textColor="#FFFFFF"
            android:textStyle="bold"
            android:layout_marginBottom="8dp" />

        <Button
            android:id="@+id/btnSwitchTarget"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Switch Display"
            android:textSize="12sp"
            android:padding="8dp" />

    </LinearLayout>
</FrameLayout>
```

## File: Cover-Screen-Trackpad/app/src/main/res/layout/service_overlay.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#20000000">

    <View
        android:id="@+id/view_trackpad"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clickable="true"
        android:focusable="true" />

    <Button
        android:id="@+id/btn_close"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="top|end"
        android:layout_margin="16dp"
        android:backgroundTint="#FF0000"
        android:text="EXIT"
        android:textColor="#FFFFFF" />

</FrameLayout>
```

## File: Cover-Screen-Trackpad/app/src/main/res/xml/backup_rules.xml
```xml
<?xml version="1.0" encoding="utf-8"?><full-backup-content>
    </full-backup-content>
```

## File: Cover-Screen-Trackpad/app/src/main/res/xml/data_extraction_rules.xml
```xml
<?xml version="1.0" encoding="utf-8"?><data-extraction-rules>
    <cloud-backup>
        </cloud-backup>
    </data-extraction-rules>
```

## File: Cover-Screen-Trackpad/app/src/main/res/xml/method.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<input-method xmlns:android="http://schemas.android.com/apk/res/android" />
```

## File: Cover-Screen-Trackpad/app/.gitignore
```
/build
```

## File: Cover-Screen-Trackpad/app/build.gradle.kts
```kotlin
plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
}

android {
    namespace = "com.example.coverscreentester"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.katsuyamaki.DroidOSTrackpadKeyboard"
        minSdk = 30
        targetSdk = 34
        versionCode = 3
        versionName = "3.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildFeatures {
        viewBinding = true
        buildConfig = true
        aidl = true
    }

    sourceSets {
        getByName("main") {
            aidl.srcDirs(listOf("src/main/aidl"))
            java.srcDirs(layout.buildDirectory.dir("generated/source/aidl/debug"))
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = "17"
    }
}

dependencies {
    implementation("dev.rikka.shizuku:api:13.1.5")
    implementation("dev.rikka.shizuku:provider:13.1.5")
    implementation("dev.rikka.shizuku:aidl:13.1.5")

    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.appcompat)
    implementation(libs.material)
    implementation(libs.androidx.activity)
    implementation(libs.androidx.constraintlayout)
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
}
```

## File: Cover-Screen-Trackpad/gradle/libs.versions.toml
```toml
[versions]
agp = "8.13.1"
kotlin = "1.9.23"
coreKtx = "1.13.1"
junit = "4.13.2"
junitVersion = "1.1.5"
espressoCore = "3.5.1"
appcompat = "1.6.1"
material = "1.11.0"
activity = "1.9.0"
constraintlayout = "2.1.4"
shizuku = "13.1.5" # <--- REVERTED TO LATEST VERSION

[libraries]
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-appcompat = { group = "androidx.appcompat", name = "appcompat", version.ref = "appcompat" }
material = { group = "com.google.android.material", name = "material", version.ref = "material" }
androidx-activity = { group = "androidx.activity", name = "activity", version.ref = "activity" }
androidx-constraintlayout = { group = "androidx.constraintlayout", name = "constraintlayout", version.ref = "constraintlayout" }
shizuku-api = { group = "dev.rikka.shizuku", name = "api", version.ref = "shizuku" }
shizuku-provider = { group = "dev.rikka.shizuku", name = "provider", version.ref = "shizuku" }
shizuku-aidl = { group = "dev.rikka.shizuku", name = "aidl", version.ref = "shizuku" }

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
```

## File: Cover-Screen-Trackpad/.gitignore
```
*.iml
.gradle
/local.properties
/.idea/caches
/.idea/libraries
/.idea/modules.xml
/.idea/workspace.xml
/.idea/navEditor.xml
/.idea/assetWizardSettings.xml
.DS_Store
/build
/captures
.externalNativeBuild
.cxx
local.properties
```

## File: Cover-Screen-Trackpad/build.gradle.kts
```kotlin
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
}
```

## File: Cover-Screen-Trackpad/gradlew
```
#!/bin/sh
APP_HOME=${0%/*}
APP_NAME=$(basename $0)
APP_BASE_NAME=${APP_NAME%.*}
if [ "$APP_HOME" = "$APP_NAME" ]; then APP_HOME=.; fi
if [ -n "$JAVA_HOME" ] ; then
    JAVA_EXE="$JAVA_HOME/bin/java"
else
    JAVA_EXE="java"
fi
if [ ! -x "$JAVA_EXE" ] ; then
    echo "Error: JAVA_HOME is not set or $JAVA_EXE does not exist." >&2
    exit 1
fi
CLASSPATH="$APP_HOME/gradle/wrapper/gradle-wrapper.jar"
exec "$JAVA_EXE" -Dorg.gradle.appname="$APP_BASE_NAME" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
```

## File: Cover-Screen-Trackpad/gradlew.bat
```batch
@if "%DEBUG%"=="" @echo off
setlocal
set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
set APP_HOME=%DIRNAME%
set JAVA_EXE=java.exe
if defined JAVA_HOME set JAVA_EXE="%JAVA_HOME%\bin\java.exe"
set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
"%JAVA_EXE%" -Dorg.gradle.appname=%~n0 -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
endlocal
```

## File: Cover-Screen-Trackpad/README.md
```markdown
# CoverScreen Trackpad 

**Turn your Samsung Flip cover screen into a fully functional mouse trackpad.**

![Android](https://img.shields.io/badge/Android-3DDC84?style=for-the-badge&logo=android&logoColor=white)
![Kotlin](https://img.shields.io/badge/kotlin-%237F52FF.svg?style=for-the-badge&logo=kotlin&logoColor=white)
![Shizuku](https://img.shields.io/badge/Shizuku-Required-blue?style=for-the-badge)

##  About
**CoverScreen Trackpad** is a specialized utility designed for the Samsung Galaxy Z Flip series (and similar foldables). It creates a transparent, always-on-top trackpad overlay on your cover screen, allowing you to control apps that are difficult to use on the small display.

This app solves the "fat finger" problem on tiny screens by giving you a precise cursor, similar to using a laptop touchpad. It uses **Shizuku** to perform clicks and gestures without Accessibility Services, ensuring better battery life and privacy.

##  Key Features
* **Precision Cursor:** Navigate tiny UI elements with a mouse pointer.
* **Smart Input:** Toggle between "Mouse Mode" and "Keyboard Mode" by holding the corner (prevents the trackpad from blocking your typing).
* **Scroll Bars:** Dedicated vertical and horizontal scroll zones on the edges.
* **Customizable:** Adjust transparency, scroll direction, handle sizes, and scrollbar placement (Left/Right, Top/Bottom).
* **No Accessibility Service:** Uses ADB/Shizuku for cleaner input injection.

##  Requirements
1.  **Android 11+**
2.  **[Shizuku](https://play.google.com/store/apps/details?id=moe.shizuku.privileged.api)** (Must be installed and running).

##  Setup Instructions (Critical)
1.  Install **Shizuku** from the Play Store and start it (via Wireless Debugging).
2.  Install the **CoverScreen Trackpad** APK (from Releases).
3.  **OPEN THE APP ON YOUR MAIN SCREEN FIRST!** 
4.  Grant **"Draw Over Other Apps"** and **"Shizuku"** permissions when prompted.
5.  Once the status says **"Ready"**, you can close the phone and launch the app on your cover screen.

##  Controls
| Action | Gesture / Button |
| :--- | :--- |
| **Left Click** | Tap anywhere on trackpad |
| **Right Click (Back)** | Press **Volume Down** |
| **Drag / Scroll** | Hold **Volume Up** + Swipe |
| **Toggle Keyboard** | Hold **Top-Left Corner** (1s) |
| **Move Window** | Drag **Top-Right Handle** |
| **Resize Window** | Hold **Bottom-Right Handle** (1s) then drag |
| **Open Menu** | Tap **Bottom-Left Handle** |

##  Configuration
Open the app menu (Bottom-Left handle) to configure:
* Haptic Feedback
* Scroll Direction (Natural vs Standard)
* Scrollbar Placement
* Visual Transparency
* Handle Size

##  Disclaimer
This project is currently in **Alpha**. It is intended for testing and development purposes. Use at your own risk.
```

## File: Cover-Screen-Trackpad/settings.gradle.kts
```kotlin
pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
        maven { url = uri("https://jitpack.io") }
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
        maven { url = uri("https://jitpack.io") }
    }
}

rootProject.name = "CoverScreenTrackpad"
include(":app")
```

## File: README.md
```markdown
DroidOS 
<br>
<br>

---

DroidOS is a suite of advanced system tools designed to give "superpowers" to the standard Android experience.
It functions as a universal Samsung DeX replacement, a tiling window manager, and an unrestricted app launcher that works on any Android device. Whether you are using a Foldable, a Flip phone, AR Glasses, or a secondary monitor, DroidOS unlocks the full potential of your hardware.

![Screenshot_20251130_185618_Discord](https://github.com/user-attachments/assets/dca14a11-21e6-439c-b653-7ce9f8e73a87)

Video Demonstration : https://youtu.be/aOzkV3t7wFM

<br>
<br>

---

 Core Features

 Universal Desktop Mode (DeX Replacement)
Unlike proprietary solutions locked to specific brands, DroidOS provides a desktop-class experience on any Android phone:
 * Window Management: Force apps into specific tiling layouts (Split-screen, Quadrants, Tri-split) on external displays.
 * Input Control: Turn your phone screen into a fully functional trackpad and keyboard while viewing content on a larger screen.
 AR Glasses & Virtual Screens
Optimized for users of XREAL, Rokid, Viture, and other AR glasses:
 * "Headless" Mode: Turn off your phone's physical screen to save battery and reduce heat while the system continues running on the glasses.
 * Blind Navigation: The Trackpad module allows you to control the AR interface without looking at your phone.
 Foldable & Cover Screen Enhancements
Unleash the full power of your Galaxy Z Flip, Fold, or other foldable devices:
 * Unrestricted Launching: Launch any app on the cover screen, bypassing system "Good Lock" allowlists.
 * Orientation Control: Force landscape or portrait orientations on screens that don't natively support them.
 How It Works
DroidOS utilizes Shizuku to access elevated system APIs without requiring root access. This allows it to:
 * Inject raw input events (Mouse/Keyboard) directly into the system input stream.
 * Manage window sizes, positions, and display power states via hidden Android APIs (Reflection).
 * Launch activities on specific display IDs (Cover screens, Virtual displays).

<br>
<br>

---

 Getting Started

Prerequisites
 * Shizuku: Must be installed and running on your device.
 * Developer Options: "Force activities to be resizable" and "Enable freeform windows" must be enabled.

Installation
You can download the latest APKs for both modules from the Releases page.
 * Install DroidOS Launcher to manage your apps and windows.
 * Install DroidOS Trackpad Keyboard to control the cursor.
 * Grant Shizuku permissions when prompted in each app.
 * I reccomend this fork of shizuku https://github.com/thedjchi/Shizuku once you set it up. It has a watchdog feature to autorestart whenever it gets turned off. Once you turn it on, even if you lose wireless adb you can still turn shizuku back on without it. Also has an auto start on boot feature. Does not require root.
 * Grant accessibility permissions to the trackpad when prompted.

 * DroidOS Launcher can be exited by swiping the bubble icon away.

<br>
<br>

---

 Contributing

We welcome contributions! 

Please note that this is a Monorepo.
 * If you are fixing a bug in the Launcher, make your Pull Request against the Cover-Screen-Launcher directory.
 * If you are improving the Trackpad, work within the Cover-Screen-Trackpad directory.

<br>
<br>

---

 DroidOS Launcher Usage Guide

The DroidOS Launcher is designed to manage multi-window tiling and control display resolutions, primarily using Shizuku for elevated permissions.
1. The Two Operational Modes
The Launcher operates primarily using an app queue combined with your selected window layout. The core difference lies in how aggressively the launcher manages apps after initialization.
>
| Mode | Key Feature | Execution Action | Ideal For |
|---|---|---|---|
| Instant Mode | Live, dynamic window management. | Windows are launched/resized automatically every time you adjust the queue (add/remove/hide apps). The Green Play/Execute button is hidden. | Quick adjustments, experimental resizing, or when fine-tuning a small layout. |
| Launcher Mode | Traditional "batch" execution. | Changes to the queue or layout only take effect when you explicitly press the Green Play/Execute button. | Large, complex setups (3+ apps) where manual timing is better, or minimizing system resource drain. |
> Switch Mode: Go to the Settings tab (Gear Icon) and toggle "Instant Mode (Live Changes)".
> 
2. Managing the App Queue (The Dock)
The App Queue (the horizontal list of icons at the top of the main drawer) determines which apps are launched and where they are placed in your chosen layout.
>
| Action | How To | Result |
|---|---|---|
| Adding an App | 1. Navigate to the Search tab. 2. Tap an app listed in the main recycler view. | The app is added to the right end of the App Queue. If in Instant Mode, the layout is applied immediately. |
| Adding a Spacer | Tap "(Blank Space)" in the search list. | Inserts a blank placeholder into the queue. This ensures an empty tile space in your final layout (e.g., in a 4-Quadrant layout, you can use 2 apps and 2 blanks). |
| Reordering/Moving | Drag and drop an app icon horizontally within the queue. | Changes the app's position in the queue, which dictates its screen placement (Tiling order). |
| Toggling Hide/Minimize | Tap an app icon in the App Queue. | The app's icon turns slightly transparent (minimized). The app is moved to the background using its Task ID. The app is skipped during subsequent tiling calculations. |
| Closing/Killing App | Swipe the app icon up or down in the App Queue. | The app is removed from the queue and a force-stop shell command is executed to kill the app. |
| Favoriting (Global) | Long-press an app in the main search list or swipe the app left/right in the search list. | Toggles the star icon and adds/removes the app from your global favorites list. |
3. Tiling Position & Order
Tiling positions are determined strictly from left-to-right in the App Queue to top-to-bottom, left-to-right in the selected screen layout.
 * The leftmost app in your queue corresponds to the first defined window tile in your layout.
 * The second app corresponds to the second tile, and so on.
Example: 4-Quadrant Layout
 * Tile 1 (Top-Left): Corresponds to the 1st app in the queue.
 * Tile 2 (Top-Right): Corresponds to the 2nd app in the queue.
 * Tile 3 (Bottom-Left): Corresponds to the 3rd app in the queue.
 * Tile 4 (Bottom-Right): Corresponds to the 4th app in the queue.
You can ensure an app lands in a specific tile by dragging it to the corresponding position in the App Queue.

<br>
<br>

---

 DroidOS Virtual Display Setup

This guide outlines the steps to activate and control a virtual, tiled desktop environment when using AR glasses (such as XREAL) connected to your Android device. This process relies on having Shizuku running with permissions granted to both the CoverScreen Launcher and CoverScreen Trackpad applications.

Part 1: Create and Switch to Virtual Display (Launcher App)
The goal of this phase is to create a new virtual screen and move the Launcher's target focus from your physical phone screen to that new screen.
 * Set Initial Resolution (Optional but Recommended):
   * Open the CoverScreen Launcher floating bubble.
   * Navigate to the Resolution Mode (Icon: Rectangle with dots) tab.
   * Select "Default (Reset)".
   * Note: The developer often sets a custom resolution (like 1080p) here to ensure the display from the glasses (e.g., Beam Pro) is usable, as the physical screen itself may be too tiny for the mirrored content.
 * Enable Virtual Display:
   * Navigate to the Settings Mode (Icon: Gear/Preferences) tab.
   * Toggle the "Virtual Display (1080p)" option.
 * Switch Launch Target:
   * Press the "Switch Display (Current [ID])" button immediately below the Virtual Display toggle.
   * Result: Your physical phone screen should become mostly blank, showing only the Launcher bubble (or the main screen if still open). The virtual screen on the glasses should now show the output.

Part 2: Gaining Cursor Control (Trackpad App)
Now that the system is outputting to the glasses, you must redirect your phone's touch input to control the cursor on the remote screen.
 * Launch Trackpad App:
   * Open the CoverScreen Trackpad application on your physical phone screen.
   * Note: The trackpad functions as an overlay on your physical phone screen, allowing you to use your phone's surface to control the larger remote display.
 * Redirect Input:
   * Press the "Target: Switch Local/Remote" button.
   * Result: You should now see a cursor moving on the glasses display corresponding to your touch input on the phone.
 * Activate Headless/Extinguish Mode (Optional):
   * Return to the CoverScreen Launcher (Settings Tab).
   * Toggle "Display Off (Touch on)" to turn off the physical screen entirely.
 Trackpad Overlay Controls
The Trackpad overlay provides dedicated controls accessible through its corners and edges:
| Control Point | Action | Result | Source |
|---|---|---|---|
| Top-Right Corner Handle | Drag finger | Moves (repositions) the trackpad overlay on the physical screen. |  |
| Bottom-Right Corner Handle | Drag finger | Resizes the trackpad overlay. |  |
| Bottom-Left Corner | Tap (Click) | Opens the manual adjust menu, allowing you to resize and reposition using a controller instead of dragging. |  |
| Edges (Top/Bottom) | Finger near edge + Move Up/Down | Performs Vertical Scrolling in the remote screen. |  |
| Edges (Left/Right) | Finger near edge + Move Left/Right | Performs Horizontal Scrolling in the remote screen. |  |
Scrolling Note: Ensure the trackpad overlay is not positioned too close to the edges of your phone's physical screen for the scrolling zones to work reliably.

<br>
<br>

---

Want to donate to support the development of this project? https://ko-fi.com/katsuyamaki

 Project Structure (Monorepo)
This repository is a Monorepo containing two distinct but complementary Android applications.
>  Developer Note: Do not open this root folder directly in Android Studio. You must open each project folder individually.
> 
| Project | Description | Path |
|---|---|---|
| DroidOS Launcher | An advanced tiling window manager and app launcher. Bypasses cover screen restrictions and manages multi-window layouts. | /Cover-Screen-Launcher |
| DroidOS Trackpad Keyboard | A virtual mouse trackpad and custom keyboard overlay. Turns your phone into a precision input device for external displays. | /Cover-Screen-Trackpad |


 License
This project is licensed under the GNU General Public License v3.0 (GPLv3).
You are free to use, modify, and distribute this software, but all modifications must remain open source. See the LICENSE file for details.

<br>
<br>

---

![Screenshot_20251130_125934_Reddit](https://github.com/user-attachments/assets/a4644964-8371-4f39-9a03-df88e4a8524a)

![Screenshot_20251130_185403_Discord](https://github.com/user-attachments/assets/6a876a1e-67c5-4968-84ff-2ed36411c54a)

![Screenshot_20251130_185026_Discord](https://github.com/user-attachments/assets/c89110b9-0a0b-47ed-83e9-9d54a150beae)

![Screenshot_20251130_130005_Reddit](https://github.com/user-attachments/assets/24ceaf2f-5212-4fe6-b027-e5941164ca93)

![Screenshot_20251130_125958_Reddit](https://github.com/user-attachments/assets/3809df01-7d7a-4383-b5f3-f9aa85998685)

![Screenshot_20251130_125940_Reddit](https://github.com/user-attachments/assets/fd1ab37f-3158-4b01-a342-9c5f82423b89)

![Screenshot_20251130_125922_Reddit](https://github.com/user-attachments/assets/2af9a4f6-8dd2-48da-9551-943845a28613)

![Screenshot_20251130_125807_One UI Cover Home](https://github.com/user-attachments/assets/eb08e879-6c55-45f6-a175-a19791588337)

<br>
<br>

---
```

## File: .claude/settings.local.json
```json
{
  "permissions": {
    "allow": [
      "Bash(./gradlew compileDebugKotlin:*)",
      "Bash(SHELL=/bin/bash /data/data/com.termux/files/home/projects/DroidOS/Cover-Screen-Trackpad/gradlew:*)",
      "Bash(SHELL=/bin/bash /data/data/com.termux/files/home/projects/DroidOS/Cover-Screen-Launcher/gradlew:*)",
      "Bash(grep:*)",
      "Bash(./gradlew assembleDebug:*)",
      "Bash(adb install:*)",
      "Bash(bash -c \"cd /data/data/com.termux/files/home/projects/DroidOS/Cover-Screen-Launcher && SHELL=/bin/bash ./gradlew assembleDebug\")",
      "Bash(bash -c \"cd /data/data/com.termux/files/home/projects/DroidOS/Cover-Screen-Launcher && git status\")",
      "Bash(bash -c \"cd /data/data/com.termux/files/home/projects/DroidOS/Cover-Screen-Trackpad && SHELL=/bin/bash ./gradlew assembleDebug\")"
    ]
  }
}
```

## File: Cover-Screen-Launcher/app/src/main/aidl/com/example/quadrantlauncher/IShellService.aidl
```
package com.example.quadrantlauncher;

interface IShellService {
    void injectKey(int keyCode, int action, int flags, int displayId, int metaState);
    void forceStop(String packageName);
    void runCommand(String command);
    void setScreenOff(int displayIndex, boolean turnOff);
    void repositionTask(String packageName, String className, int left, int top, int right, int bottom);
    List<String> getVisiblePackages(int displayId);
    List<String> getWindowLayouts(int displayId);
    List<String> getAllRunningPackages();
    int getTaskId(String packageName, String className);
    void moveTaskToBack(int taskId);

    // Brightness Control
    void setSystemBrightness(int brightness);
    int getSystemBrightness();
    float getSystemBrightnessFloat();
    void setAutoBrightness(boolean enabled);
    boolean isAutoBrightness();
    
    // Legacy / Direct Hardware Control
    boolean setBrightnessViaDisplayManager(int displayId, float brightness);

    // NEW: Alternate Display Off Logic (Targeted)
    void setBrightness(int displayId, int value);
}
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/activity_menu.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp"
    android:gravity="center">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Select Launch Mode"
        android:textSize="20sp"
        android:layout_marginBottom="24dp" />

    <Button
        android:id="@+id/button_quadrant"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="4-Quadrant Launcher" />

    <Button
        android:id="@+id/button_split"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="2-App Split-Screen" />

    <Button
        android:id="@+id/button_tri_split"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="3-App Split-Screen (Row)" />

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/activity_quadrant.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp"
    tools:context=".QuadrantActivity">

    <Button
        android:id="@+id/q1_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Select App for Quadrant 1" />

    <Button
        android:id="@+id/q2_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Select App for Quadrant 2" />

    <Button
        android:id="@+id/q3_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Select App for Quadrant 3" />

    <Button
        android:id="@+id/q4_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Select App for Quadrant 4" />

    <View
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" />

    <Button
        android:id="@+id/launch_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="LAUNCH"
        style="@style/Widget.AppCompat.Button.Colored" /> </LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/activity_tri_split.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp"
    tools:context=".TriSplitActivity">

    <Button
        android:id="@+id/app1_button_tri"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Select App 1 (Left)" />

    <Button
        android:id="@+id/app2_button_tri"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Select App 2 (Middle)" />

    <Button
        android:id="@+id/app3_button_tri"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Select App 3 (Right)" />

    <View
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" />

    <Button
        android:id="@+id/launch_button_tri_split"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="LAUNCH 3-APP SPLIT"
        style="@style/Widget.AppCompat.Button.Colored" />

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/item_custom_mod.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="12dp"
    android:gravity="center_vertical"
    android:background="@drawable/bg_item_press">

    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:orientation="vertical"
        android:paddingEnd="8dp">
        
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Custom Modifier (Sticky)"
            android:textColor="#FFFFFF"
            android:textSize="14sp"
            android:textStyle="bold"/>
            
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Type a single key (e.g. ` or ~)"
            android:textColor="#888888"
            android:textSize="10sp"/>
    </LinearLayout>

    <EditText
        android:id="@+id/input_custom_mod"
        android:layout_width="60dp"
        android:layout_height="wrap_content"
        android:background="#333333"
        android:padding="8dp"
        android:textColor="#00FFFF"
        android:textSize="16sp"
        android:textStyle="bold"
        android:gravity="center"
        android:maxLength="1"
        android:inputType="text"
        android:imeOptions="actionDone"/>

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/item_keybind.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp"
    android:gravity="center_vertical"
    android:background="@drawable/bg_item_press">

    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:orientation="vertical"
        android:paddingEnd="8dp">
        
        <TextView
            android:id="@+id/kb_title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Command Name"
            android:textColor="#FFFFFF"
            android:textSize="14sp"
            android:textStyle="bold"/>
            
        <TextView
            android:id="@+id/kb_desc"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Tap to copy ADB command"
            android:textColor="#888888"
            android:textSize="10sp"/>
    </LinearLayout>

    <Button
        android:id="@+id/btn_mod"
        android:layout_width="60dp"
        android:layout_height="36dp"
        android:text="ALT"
        android:textSize="10sp"
        android:backgroundTint="#444444"
        android:textColor="#FFFFFF"
        android:padding="0dp"
        android:layout_marginEnd="4dp"/>

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="+"
        android:textColor="#888888"
        android:paddingEnd="4dp"/>

    <Button
        android:id="@+id/btn_key"
        android:layout_width="60dp"
        android:layout_height="36dp"
        android:text="A"
        android:textSize="10sp"
        android:backgroundTint="#444444"
        android:textColor="#FFFFFF"
        android:padding="0dp"/>

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/item_layout_option.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/layout_option_container"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="12dp"
    android:gravity="center_vertical"
    android:background="@drawable/bg_item_press">

    <EditText
        android:id="@+id/layout_name"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:text="Layout Name"
        android:textColor="#FFFFFF"
        android:textSize="16sp"
        android:background="@null"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:singleLine="true"
        android:clickable="false"
        android:focusable="false"
        android:longClickable="false"
        android:focusableInTouchMode="false" />

    <ImageView
        android:id="@+id/btn_edit_layout_name"
        android:layout_width="32dp"
        android:layout_height="32dp"
        android:padding="6dp"
        android:src="@android:drawable/ic_menu_edit"
        android:tint="#AAAAAA"
        android:background="?attr/selectableItemBackgroundBorderless"
        android:visibility="visible"
        android:clickable="true"
        android:focusable="true" />

    <ImageView
        android:id="@+id/btn_save_profile"
        android:layout_width="32dp"
        android:layout_height="32dp"
        android:padding="4dp"
        android:src="@android:drawable/ic_menu_save"
        android:tint="#00AAFF"
        android:background="?attr/selectableItemBackgroundBorderless"
        android:visibility="gone"
        android:clickable="true"
        android:focusable="true" />

    <ImageView
        android:id="@+id/btn_extinguish_item"
        android:layout_width="32dp"
        android:layout_height="32dp"
        android:padding="4dp"
        android:src="@android:drawable/ic_lock_power_off"
        android:tint="#FF5555"
        android:background="?attr/selectableItemBackgroundBorderless"
        android:visibility="gone"
        android:clickable="true"
        android:focusable="true" />

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/item_margin_setting.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp"
    android:gravity="center_vertical"
    android:background="@drawable/bg_item_press">

    <TextView
        android:id="@+id/text_margin_label"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Margin:"
        android:textColor="#888888"
        android:textSize="14sp"
        android:paddingEnd="8dp"/>

    <SeekBar
        android:id="@+id/sb_margin_slider"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:max="50"
        android:progress="0"
        android:paddingStart="10dp"
        android:paddingEnd="10dp"/>

    <TextView
        android:id="@+id/text_margin_value"
        android:layout_width="40dp"
        android:layout_height="wrap_content"
        android:text="0%"
        android:gravity="end"
        android:textColor="#FFFFFF"
        android:textSize="16sp"/>

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/item_selected_app.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="48dp"
    android:layout_height="48dp"
    android:padding="4dp">

    <ImageView
        android:id="@+id/selected_app_icon"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:src="@mipmap/ic_launcher_round"
        android:background="@null"
        android:padding="2dp"
        android:clipToOutline="true"/>

    <!-- Focus Indicator (Underline) -->
    <View
        android:id="@+id/focus_underline"
        android:layout_width="24dp"
        android:layout_height="3dp"
        android:layout_gravity="bottom|center_horizontal"
        android:background="#00FF00"
        android:visibility="gone"/>
</FrameLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/item_simple_text.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/text1"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="16dp"
    android:text="Key Name"
    android:textColor="#FFFFFF"
    android:textSize="16sp"
    android:background="@drawable/bg_item_press"
    android:gravity="center_vertical"/>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/item_visual_queue_app.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="56dp"
    android:layout_height="56dp"
    android:padding="4dp">

    <ImageView
        android:id="@+id/vq_app_icon"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:src="@mipmap/ic_launcher_round"
        android:padding="4dp"/>
        
    <!-- Selection Highlight Border (For Command Targeting) -->
    <View
        android:id="@+id/vq_highlight"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="@drawable/bg_item_active"
        android:alpha="0.5"
        android:visibility="gone"/>

    <!-- Focus Indicator (Current System Focus) -->
    <View
        android:id="@+id/focus_underline"
        android:layout_width="30dp"
        android:layout_height="4dp"
        android:layout_gravity="bottom|center_horizontal"
        android:background="#00FF00"
        android:visibility="gone"/>

    <!-- Number Badge -->
    <TextView
        android:id="@+id/vq_slot_number"
        android:layout_width="18dp"
        android:layout_height="18dp"
        android:layout_gravity="top|start"
        android:text="1"
        android:textColor="#FFFFFF"
        android:textSize="10sp"
        android:textStyle="bold"
        android:gravity="center"
        android:background="@drawable/bg_bubble"
        android:backgroundTint="#000000"/>

</FrameLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/layout_key_picker.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="300dp"
    android:layout_height="400dp"
    android:orientation="vertical"
    android:background="@drawable/bg_drawer"
    android:elevation="20dp"
    android:padding="16dp">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Select Key"
        android:textColor="#FFFFFF"
        android:textSize="18sp"
        android:textStyle="bold"
        android:gravity="center"
        android:layout_marginBottom="12dp"/>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/picker_recycler"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:scrollbars="vertical"/>

    <Button
        android:id="@+id/btn_cancel_picker"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Cancel"
        android:backgroundTint="#555555"
        android:textColor="#FFFFFF"
        android:layout_marginTop="8dp"/>

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/layout_visual_queue.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:background="@drawable/bg_drawer"
    android:padding="12dp"
    android:gravity="center_horizontal"
    android:layout_marginBottom="50dp">

    <TextView
        android:id="@+id/visual_queue_prompt"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="COMMAND"
        android:textColor="#00FF00"
        android:textSize="10sp"
        android:textStyle="normal"
        android:background="@null"
        android:layout_marginBottom="4dp"/>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/visual_queue_recycler"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:minWidth="200dp"
        android:orientation="horizontal"/>

<!-- Dummy input to hold keyboard focus -->
    <EditText
        android:id="@+id/vq_dummy_input"
        android:layout_width="1px"
        android:layout_height="1px"
        android:background="@null"
        android:cursorVisible="false"
        android:inputType="text"
        android:imeOptions="actionNone"
        android:alpha="0"/>
</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/res/xml/backup_rules.xml
```xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older than API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>
```

## File: Cover-Screen-Launcher/app/src/main/res/xml/data_extraction_rules.xml
```xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>
```

## File: Cover-Screen-Launcher/app/src/main/AndroidManifest.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES" />
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_SPECIAL_USE" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />

    <queries>
        <package android:name="moe.shizuku.privileged.api" />
        <package android:name="rikka.shizuku.ui" />
    </queries>

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:icon="@mipmap/ic_launcher_adaptive"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_adaptive"
        android:supportsRtl="true"
        android:theme="@style/Theme.QuadrantLauncher"
        tools:targetApi="31">

        <provider
            android:name="rikka.shizuku.ShizukuProvider"
            android:authorities="${applicationId}.shizuku"
            android:enabled="true"
            android:exported="true"
            android:multiprocess="false" />

        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        
        <activity android:name=".IconPickerActivity" 
                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
                  android:exported="false" />

        <service
            android:name=".FloatingLauncherService"
            android:enabled="true"
            android:exported="true"
            android:label="@string/app_name"
            android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE">
            <intent-filter>
                <action android:name="android.accessibilityservice.AccessibilityService" />
            </intent-filter>
            <meta-data
                android:name="android.accessibilityservice"
                android:resource="@xml/accessibility_service_config" />
        </service>

        <activity android:name=".SplitActivity" android:exported="false" />

        <activity
            android:name=".PermissionActivity"
            android:theme="@android:style/Theme.NoTitleBar"
            android:screenOrientation="portrait" />

    </application>
</manifest>
```

## File: Cover-Screen-Launcher/app/.gitignore
```
/build
```

## File: Cover-Screen-Launcher/gradle/libs.versions.toml
```toml
[versions]
agp = "8.13.1"
kotlin = "2.0.21"
coreKtx = "1.10.1"
junit = "4.13.2"
junitVersion = "1.1.5"
espressoCore = "3.5.1"
appcompat = "1.6.1"
material = "1.10.0"
activity = "1.8.0"
constraintlayout = "2.1.4"

[libraries]
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-appcompat = { group = "androidx.appcompat", name = "appcompat", version.ref = "appcompat" }
material = { group = "com.google.android.material", name = "material", version.ref = "material" }
androidx-activity = { group = "androidx.activity", name = "activity", version.ref = "activity" }
androidx-constraintlayout = { group = "androidx.constraintlayout", name = "constraintlayout", version.ref = "constraintlayout" }

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
```

## File: Cover-Screen-Launcher/build.gradle.kts
```kotlin
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
}
```

## File: Cover-Screen-Launcher/gradlew.bat
```batch
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
```

## File: Cover-Screen-Trackpad/app/src/main/assets/clean_dict_with_nvim.lua
```lua
-- scripts/clean_dict_with_nvim.lua

-- Configuration
local input_file = "dictionary.txt"
local output_file = "dictionary.txt" -- Overwrite strict or use new name
local backup_file = "dictionary.bak"

-- Setup Spelling
vim.opt.spell = true
vim.opt.spelllang = "en"

print("Starting dictionary sanitization...")

-- Read Input
local infile = io.open(input_file, "r")
if not infile then
	print("Error: Could not open " .. input_file)
	vim.cmd("q")
	return
end

local valid_words = {}
local count_total = 0
local count_kept = 0

for line in infile:lines() do
	local word = line:match("^%s*(.-)%s*$") -- Trim whitespace
	if word and word ~= "" then
		count_total = count_total + 1

		-- Check word against nvim dictionary
		-- spellbadword returns a list: [bad_word, error_type]
		-- error_type can be: 'bad' (unknown), 'caps', 'rare', 'local', etc.
		-- We only reject 'bad'. We accept 'caps' because swipe dicts are often lowercase.
		local result = vim.fn.spellbadword(word)
		local error_type = result[2]

		if error_type ~= "bad" then
			table.insert(valid_words, word)
			count_kept = count_kept + 1
		end
	end
end
infile:close()

-- Write Output
print("Sanitization complete.")
print("Total words scanned: " .. count_total)
print("Words kept: " .. count_kept)
print("Words removed: " .. (count_total - count_kept))

-- Backup original
os.rename(input_file, backup_file)
print("Original dictionary backed up to " .. backup_file)

local outfile = io.open(output_file, "w")
if outfile then
	for _, word in ipairs(valid_words) do
		outfile:write(word .. "\n")
	end
	outfile:close()
	print("Clean dictionary saved to " .. output_file)
else
	print("Error: Could not write to " .. output_file)
end

vim.cmd("q")
```

## File: Cover-Screen-Trackpad/app/src/main/assets/clean_dictionary.py
```python
import os
import re

# ==========================================
# CONFIGURATION
# ==========================================
INPUT_FILE = "dictionary.txt"
OUTPUT_FILE = "dictionary.txt" # Overwrites original

# 1. STRICT ALLOWLISTS (Short words are the noisiest in swipe)
# Only these 1-letter words are allowed
VALID_1_LETTER = {"a", "i"}

# Only these 2-letter words are allowed
VALID_2_LETTER = {
    "am", "an", "as", "at", "be", "by", "do", "go", "ha", "he", "hi", 
    "if", "in", "is", "it", "me", "my", "no", "of", "oh", "ok", "on", 
    "or", "ox", "so", "to", "up", "us", "we", "ye", "yo"
}

# Only these 3-letter words are allowed (Common English + standard abbreviations)
VALID_3_LETTER = {
    "act", "add", "ado", "age", "ago", "aid", "aim", "air", "ale", "all", "and", "ant", "any", "ape", "apt", "arc", "are", "ark", "arm", "art", "ash", "ask", "ate", "awe", "axe", "aye",
    "bad", "bag", "ban", "bar", "bat", "bay", "bed", "bee", "beg", "bet", "bib", "bid", "big", "bin", "bit", "bob", "bog", "boo", "bow", "box", "boy", "bra", "bud", "bug", "bum", "bun", "bus", "but", "buy", "bye",
    "cab", "cad", "cam", "can", "cap", "car", "cat", "cod", "cog", "con", "coo", "cop", "cot", "cow", "coy", "cry", "cub", "cue", "cup", "cut",
    "dab", "dad", "dam", "day", "den", "dew", "did", "die", "dig", "dim", "din", "dip", "doc", "doe", "dog", "don", "dot", "dry", "dub", "dud", "due", "dug", "duo", "dye",
    "ear", "eat", "ebb", "eel", "egg", "ego", "eke", "elf", "elk", "elm", "end", "era", "err", "eve", "ewe", "eye",
    "fad", "fan", "far", "fat", "fax", "fed", "fee", "few", "fib", "fig", "fin", "fit", "fix", "flu", "fly", "foe", "fog", "for", "fox", "fry", "fun", "fur",
    "gab", "gag", "gal", "gap", "gas", "gay", "gel", "gem", "get", "gig", "gin", "god", "got", "gum", "gun", "gut", "guy", "gym",
    "had", "hag", "ham", "has", "hat", "hay", "hem", "hen", "her", "hey", "hid", "him", "hip", "hit", "hoe", "hog", "hop", "hot", "how", "hub", "hue", "hug", "hum", "hut",
    "ice", "icy", "ill", "imp", "ink", "inn", "ion", "ire", "irk", "its", "ivy",
    "jab", "jam", "jar", "jaw", "jay", "jet", "jig", "job", "jog", "joy", "jug",
    "kea", "keg", "key", "kid", "kin", "kit",
    "lab", "lad", "lag", "lap", "law", "lay", "led", "lee", "leg", "let", "lid", "lie", "lip", "lit", "lob", "log", "loo", "lot", "low", "lug",
    "mad", "man", "map", "mat", "may", "men", "met", "mid", "mix", "mob", "mom", "mop", "mud", "mug", "mum",
    "nab", "nag", "nap", "nay", "net", "new", "nil", "nip", "nod", "nor", "not", "now", "nun", "nut",
    "oak", "oar", "oat", "odd", "off", "oft", "oil", "old", "one", "opt", "orb", "ore", "our", "out", "owl", "own",
    "pad", "pal", "pan", "par", "pat", "paw", "pay", "pea", "peg", "pen", "pet", "pew", "pie", "pig", "pin", "pit", "ply", "pod", "pop", "pot", "pro", "pry", "pub", "pun", "pup", "put",
    "rag", "ram", "ran", "rap", "rat", "raw", "ray", "red", "rib", "rid", "rig", "rim", "rip", "rob", "rod", "rot", "row", "rub", "rue", "rug", "rum", "run", "rut", "rye",
    "sad", "sag", "sap", "sat", "saw", "sax", "say", "sea", "see", "set", "sew", "sex", "she", "shy", "sin", "sip", "sir", "sit", "six", "ski", "sky", "sly", "sob", "sod", "son", "sop", "sow", "soy", "spa", "spy", "sub", "sue", "sum", "sun",
    "tab", "tag", "tan", "tap", "tar", "tat", "tax", "tea", "tee", "ten", "the", "thy", "tic", "tie", "tin", "tip", " toe", "tog", "ton", "too", "top", "tow", "toy", "try", "tub", "tug", "two",
    "urn", "use",
    "van", "vat", "vet", "via", "vow",
    "wad", "wag", "war", "was", "wax", "way", "web", "wed", "wee", "wet", "who", "why", "wig", "win", "wit", "woe", "won", "woo", "wow", "wry",
    "yak", "yam", "yap", "yes", "yet", "yew", "you",
    "zap", "zip", "zoo"
}

# 2. BLACKLIST
# Remove specific junk words or patterns
BLOCKED_PATTERNS = [
    r".*sex$",      # Ends in sex (animalsex, worldsex), unless it is 'sex' (handled by length check)
    r"^[^aeiouy]+$" # Words with NO vowels (e.g. 'tgp', 'mnt') - usually abbreviations
]
# Exceptions to the "ends with sex" rule (valid words)
SEX_EXCEPTIONS = {"sex", "unisex", "middlesex", "essex"}

def clean_dictionary():
    print(f"Reading {INPUT_FILE}...")
    
    if not os.path.exists(INPUT_FILE):
        print(f"Error: {INPUT_FILE} not found.")
        return

    with open(INPUT_FILE, 'r', encoding='utf-8') as f:
        raw_words = f.read().splitlines()

    cleaned_words = []
    removed_count = 0

    seen = set()

    for w in raw_words:
        w = w.strip().lower()
        
        # Filter 1: Basic Validity
        if not w or not w.isalpha():
            continue

        # Filter 2: Length-based strict allowlists
        if len(w) == 1:
            if w not in VALID_1_LETTER:
                removed_count += 1
                continue
        elif len(w) == 2:
            if w not in VALID_2_LETTER:
                # print(f"Removing 2-letter junk: {w}")
                removed_count += 1
                continue
        elif len(w) == 3:
            if w not in VALID_3_LETTER:
                # print(f"Removing 3-letter junk: {w}")
                removed_count += 1
                continue

        # Filter 3: Pattern Blocking
        is_blocked = False
        
        # Check "No Vowels" (junk abbreviations)
        if re.match(r"^[^aeiouy]+$", w):
            removed_count += 1
            continue

        # Check "sex" suffix spam
        if w.endswith("sex") and w not in SEX_EXCEPTIONS:
            print(f"Removing spam: {w}")
            removed_count += 1
            continue

        # Deduplicate
        if w in seen:
            continue
            
        seen.add(w)
        cleaned_words.append(w)

    # Sort alphabetically
    cleaned_words.sort()

    print(f"Original count: {len(raw_words)}")
    print(f"Removed: {removed_count}")
    print(f"New count: {len(cleaned_words)}")

    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        f.write("\n".join(cleaned_words))
    
    print(f"Successfully cleaned dictionary saved to {OUTPUT_FILE}")

if __name__ == "__main__":
    clean_dictionary()
```

## File: Cover-Screen-Trackpad/app/src/main/assets/sanitize_dict.py
```python
import os
import sys

# Configuration
INPUT_FILE = 'dictionary.txt'
OUTPUT_FILE = 'dictionary_sanitized.txt'

# Blocklist of unwanted words
BLACKLIST = {
    # German
    'der', 'die', 'und', 'des', 'von', 'im', 'da', 'den', 'ein', 'eine', 'zu', 'mit', 
    'ist', 'auf', 'aus', 'dem', 'fuer', 'fur', 'sich', 'nicht', 'dass', 'sie', 'wir', 'ich',
    # French
    'le', 'la', 'les', 'un', 'une', 'du', 'et', 'pour', 'que', 'qui', 'dans', 'sur', 
    'par', 'pas', 'aux', 'ne', 'ce', 'se', 'vous', 'nous', 'en', 'au', 'monde', 'mais',
    # Spanish
    'el', 'los', 'las', 'del', 'por', 'para', 'con', 'una', 'su', 'al', 'lo', 'como', 'mas', 'todo', 'sobre',
    # Garbage / File extensions / HTML / Protocols
    'http', 'https', 'www', 'com', 'org', 'net', 'html', 'php', 'jpg', 'jpeg', 'gif', 
    'png', 'pdf', 'rss', 'xml', 'css', 'js', 'exe', 'dll', 'txt', 'src', 'href', 'img',
    'gmt', 'pst', 'est', 'cst', 'mst', 'utc', 'vol', 'tel', 'fax', 'isbn', 'faq', 'nbsp',
    'aa', 'bb', 'cc', 'dd', 'ee', 'ff', 'gg', 'hh', 'jj', 'kk', 'll', 'mm', 'nn', 'oo', 'pp', 'qq', 'rr', 'ss', 'tt', 'uu', 'vv', 'ww', 'xx', 'yy', 'zz',
    'ii', 'iii', 'iv', 'vi', 'vii', 'viii', 'ix', 'xi', 'xii', 'xiii', 'xiv', 'xv', 'xvi',
    # Adult / Offensive (Remove to clean up suggestions)
    'porn', 'sex', 'xxx', 'fuck', 'shit', 'ass', 'dick', 'pussy', 'cock', 'bitch', 
    'anal', 'erotic', 'nude', 'naked', 'milf', 'cunt', 'whore', 'slut', 'rape', 
    'incest', 'beastiality', 'shemale', 'tranny', 'hentai', 'boobs', 'tits', 
    'blowjob', 'handjob', 'dildo', 'vibrator', 'camgirl', 'escort', 'lolita',
    'lesbian', 'gay', 'bisexual', 'transgender', 'queer'
}

# Allow list for single letters
KEEP_SINGLE = {'a', 'i'}

def sanitize():
    # Handle path resolution (check current or parent dir)
    target_file = INPUT_FILE
    if not os.path.exists(target_file):
        if os.path.exists(os.path.join('..', INPUT_FILE)):
            target_file = os.path.join('..', INPUT_FILE)
        else:
            print(f"Error: {INPUT_FILE} not found in current or parent directory.")
            return

    print(f"Reading {target_file}...")
    try:
        with open(target_file, 'r', encoding='utf-8', errors='ignore') as f:
            lines = f.readlines()
    except Exception as e:
        print(f"Failed to read file: {e}")
        return

    clean_lines = []
    seen = set()
    removed_count = 0

    for line in lines:
        word = line.strip().lower()
        
        # skip empty
        if not word:
            continue
            
        # skip numbers or mixed alphanumeric (e.g. mp3, 4th) unless desired, assuming pure dictionary here
        if not word.isalpha():
            # Special case: keep strictly alpha words. Remove things with numbers like 'mp3' or '3rd'
            removed_count += 1
            continue

        # skip single letters except 'a' and 'i'
        if len(word) == 1 and word not in KEEP_SINGLE:
            removed_count += 1
            continue

        # blacklist check
        if word in BLACKLIST:
            removed_count += 1
            continue

        # dedup
        if word in seen:
            continue
            
        seen.add(word)
        clean_lines.append(word)

    # Write output
    out_path = OUTPUT_FILE
    if os.path.dirname(target_file):
        out_path = os.path.join(os.path.dirname(target_file), OUTPUT_FILE)
        
    with open(out_path, 'w', encoding='utf-8') as f:
        f.write('\n'.join(clean_lines))
        f.write('\n')
        
    print(f"Sanitization complete.")
    print(f"Processed: {len(lines)} lines.")
    print(f"Removed: {removed_count} lines.")
    print(f"Cleaned file saved to: {out_path}")

if __name__ == "__main__":
    sanitize()
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/InterAppCommandReceiver.kt
```kotlin
package com.example.coverscreentester

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.util.Log

/**
 * =================================================================================
 * CLASS: InterAppCommandReceiver
 * SUMMARY: Static BroadcastReceiver for inter-app communication.
 *          Receives commands from DroidOS Launcher and ADB, then forwards them
 *          to the OverlayService. This ensures commands work even when the
 *          OverlayService's dynamic receiver isn't registered (background state).
 * 
 * USAGE (ADB):
 *   adb shell am broadcast -a com.example.coverscreentester.SOFT_RESTART
 *   adb shell am broadcast -a com.example.coverscreentester.MOVE_TO_VIRTUAL --ei DISPLAY_ID 2
 *   adb shell am broadcast -a com.example.coverscreentester.RETURN_TO_PHYSICAL --ei DISPLAY_ID 0
 *   adb shell am broadcast -a com.example.coverscreentester.ENFORCE_ZORDER
 *   adb shell am broadcast -a com.example.coverscreentester.TOGGLE_VIRTUAL_MIRROR
 *   adb shell am broadcast -a com.example.coverscreentester.GET_STATUS
 * =================================================================================
 */
class InterAppCommandReceiver : BroadcastReceiver() {

    companion object {
        private const val TAG = "InterAppCmdReceiver"
        
        // Action constants
        const val ACTION_SOFT_RESTART = "com.example.coverscreentester.SOFT_RESTART"
        const val ACTION_MOVE_TO_VIRTUAL = "com.example.coverscreentester.MOVE_TO_VIRTUAL"
        const val ACTION_RETURN_TO_PHYSICAL = "com.example.coverscreentester.RETURN_TO_PHYSICAL"
        const val ACTION_ENFORCE_ZORDER = "com.example.coverscreentester.ENFORCE_ZORDER"
        const val ACTION_TOGGLE_VIRTUAL_MIRROR = "com.example.coverscreentester.TOGGLE_VIRTUAL_MIRROR"
        const val ACTION_GET_STATUS = "com.example.coverscreentester.GET_STATUS"
        
        // Extra keys
        const val EXTRA_DISPLAY_ID = "DISPLAY_ID"
    }

    override fun onReceive(context: Context?, intent: Intent?) {
        if (context == null || intent == null) return
        
        val action = intent.action ?: return
        Log.d(TAG, "Received inter-app command: $action")
        
        // Forward the command to OverlayService via startService
        // The OverlayService will handle the actual logic
        val serviceIntent = Intent(context, OverlayService::class.java).apply {
            this.action = action
            
            // Copy all extras from the original intent
            intent.extras?.let { extras ->
                putExtras(extras)
            }
        }
        
        try {
            // Start the service with the command
            // Using startService because AccessibilityService handles its own lifecycle
            context.startService(serviceIntent)
            Log.d(TAG, "Forwarded command to OverlayService: $action")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to forward command to OverlayService", e)
            
            // If service start fails, try broadcasting directly
            // The OverlayService's dynamic receiver might pick it up
            try {
                val broadcastIntent = Intent(action).apply {
                    setPackage(context.packageName)
                    intent.extras?.let { extras ->
                        putExtras(extras)
                    }
                }
                context.sendBroadcast(broadcastIntent)
                Log.d(TAG, "Sent internal broadcast as fallback: $action")
            } catch (e2: Exception) {
                Log.e(TAG, "Fallback broadcast also failed", e2)
            }
        }
    }
}
// =================================================================================
// END CLASS: InterAppCommandReceiver
// =================================================================================
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/KeyboardManager.kt
```kotlin
package com.example.coverscreentester

import android.content.Context
import android.graphics.Color
import android.graphics.Typeface
import android.graphics.drawable.GradientDrawable
import android.view.Gravity
import android.view.KeyEvent
import android.view.View
import android.view.WindowManager
import android.widget.FrameLayout
import android.widget.LinearLayout
import android.widget.TextView
import kotlin.math.abs

class KeyboardManager(
    private val context: Context,
    private val windowManager: WindowManager,
    private val keyInjector: (Int) -> Unit
) {
    var keyboardLayout: FrameLayout? = null
    var layoutParams: WindowManager.LayoutParams? = null
    
    private var isShifted = false
    private var isSymbols = false
    private var isVisible = false
    
    // Config
    private var currentWidth = 450
    // We use PROPORTIONAL spacing to ensure Aspect Ratio matches on all screens
    // 0 margin on container, slight margin on keys handled by spacing
    private val KEY_SPACING_RATIO = 0.005f 
    
    // Data Classes
    data class KeyDef(val label: String, val code: Int, val weight: Float = 1f, val isSpecial: Boolean = false)

    private val ROW_1 = listOf(
        KeyDef("q", KeyEvent.KEYCODE_Q), KeyDef("w", KeyEvent.KEYCODE_W), KeyDef("e", KeyEvent.KEYCODE_E),
        KeyDef("r", KeyEvent.KEYCODE_R), KeyDef("t", KeyEvent.KEYCODE_T), KeyDef("y", KeyEvent.KEYCODE_Y),
        KeyDef("u", KeyEvent.KEYCODE_U), KeyDef("i", KeyEvent.KEYCODE_I), KeyDef("o", KeyEvent.KEYCODE_O),
        KeyDef("p", KeyEvent.KEYCODE_P)
    )
    
    private val ROW_2 = listOf(
        KeyDef("a", KeyEvent.KEYCODE_A), KeyDef("s", KeyEvent.KEYCODE_S), KeyDef("d", KeyEvent.KEYCODE_D),
        KeyDef("f", KeyEvent.KEYCODE_F), KeyDef("g", KeyEvent.KEYCODE_G), KeyDef("h", KeyEvent.KEYCODE_H),
        KeyDef("j", KeyEvent.KEYCODE_J), KeyDef("k", KeyEvent.KEYCODE_K), KeyDef("l", KeyEvent.KEYCODE_L)
    )
    
    private val ROW_3 = listOf(
        KeyDef("SHIFT", -1, 1.5f, true),
        KeyDef("z", KeyEvent.KEYCODE_Z), KeyDef("x", KeyEvent.KEYCODE_X), KeyDef("c", KeyEvent.KEYCODE_C),
        KeyDef("v", KeyEvent.KEYCODE_V), KeyDef("b", KeyEvent.KEYCODE_B), KeyDef("n", KeyEvent.KEYCODE_N),
        KeyDef("m", KeyEvent.KEYCODE_M),
        KeyDef("", KeyEvent.KEYCODE_DEL, 1.5f, true)
    )
    
    private val ROW_4 = listOf(
        KeyDef("?123", -2, 1.5f, true),
        KeyDef(",", KeyEvent.KEYCODE_COMMA), 
        KeyDef("SPACE", KeyEvent.KEYCODE_SPACE, 4f), 
        KeyDef(".", KeyEvent.KEYCODE_PERIOD),
        KeyDef("ENTER", KeyEvent.KEYCODE_ENTER, 1.5f, true)
    )

    private val ARROWS = listOf(
        KeyDef("", KeyEvent.KEYCODE_DPAD_LEFT, 1f, true),
        KeyDef("", KeyEvent.KEYCODE_DPAD_UP, 1f, true),
        KeyDef("", KeyEvent.KEYCODE_DPAD_DOWN, 1f, true),
        KeyDef("", KeyEvent.KEYCODE_DPAD_RIGHT, 1f, true)
    )

    private val ROW_NUMS = listOf(
        KeyDef("1", KeyEvent.KEYCODE_1), KeyDef("2", KeyEvent.KEYCODE_2), KeyDef("3", KeyEvent.KEYCODE_3),
        KeyDef("4", KeyEvent.KEYCODE_4), KeyDef("5", KeyEvent.KEYCODE_5), KeyDef("6", KeyEvent.KEYCODE_6),
        KeyDef("7", KeyEvent.KEYCODE_7), KeyDef("8", KeyEvent.KEYCODE_8), KeyDef("9", KeyEvent.KEYCODE_9),
        KeyDef("0", KeyEvent.KEYCODE_0)
    )
    
    private val ROW_SYMS = listOf(
        KeyDef("@", KeyEvent.KEYCODE_AT), KeyDef("#", KeyEvent.KEYCODE_POUND), KeyDef("$", KeyEvent.KEYCODE_4), 
        KeyDef("%", KeyEvent.KEYCODE_5), KeyDef("&", KeyEvent.KEYCODE_7), KeyDef("-", KeyEvent.KEYCODE_MINUS),
        KeyDef("+", KeyEvent.KEYCODE_PLUS), KeyDef("(", KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN), KeyDef(")", KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN)
    )

    fun createView(): View {
        val root = FrameLayout(context)
        
        val bg = GradientDrawable()
        bg.setColor(Color.parseColor("#EE121212"))
        bg.cornerRadius = 20f
        bg.setStroke(2, Color.parseColor("#44FFFFFF"))
        root.background = bg

        val mainContainer = LinearLayout(context)
        mainContainer.orientation = LinearLayout.VERTICAL
        // Zero padding - we fill the aspect ratio box completely
        mainContainer.setPadding(0, 0, 0, 0)
        
        mainContainer.addView(createRow(if (isSymbols) ROW_NUMS else ROW_1))
        mainContainer.addView(createRow(if (isSymbols) ROW_SYMS else ROW_2))
        mainContainer.addView(createRow(ROW_3))
        mainContainer.addView(createRow(ROW_4))
        mainContainer.addView(createRow(ARROWS))

        // Match Parent (which is strictly controlled by Window Size)
        root.addView(mainContainer, FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT))
        
        // --- SYNC LOCKER ---
        // Ensure Physical Keyboard strictly follows the 0.55 Ratio
        root.addOnLayoutChangeListener { _, left, top, right, bottom, _, _, _, _ ->
            val width = right - left
            val height = bottom - top
            if (width > 0) {
                val targetHeight = (width * 0.55f).toInt()
                if (abs(height - targetHeight) > 10) {
                    layoutParams?.height = targetHeight
                    try { windowManager.updateViewLayout(keyboardLayout, layoutParams) } catch (e: Exception) {}
                }
            }
        }
        
        return root
    }

    private fun createRow(keys: List<KeyDef>): LinearLayout {
        val row = LinearLayout(context)
        row.orientation = LinearLayout.HORIZONTAL
        
        // Vertical Weight 1.0 -> 5 Rows = 20% height each
        val rowParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, 0)
        rowParams.weight = 1.0f
        row.layoutParams = rowParams
        
        val MAX_ROW_WEIGHT = 10f
        val currentWeight = keys.map { it.weight }.sum()
        val missingWeight = MAX_ROW_WEIGHT - currentWeight
        
        if (missingWeight > 0.1f) {
            val spacer = View(context)
            val params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.MATCH_PARENT)
            params.weight = missingWeight / 2f
            row.addView(spacer, params)
        }
        
        // Font scaled to Width
        val fontSize = (currentWidth / 30f).coerceIn(10f, 22f)
        val marginPx = (currentWidth * KEY_SPACING_RATIO).toInt().coerceAtLeast(1)
        
        for (k in keys) {
            val btn = TextView(context)
            val label = if (!isSymbols && isShifted && k.label.length == 1) k.label.uppercase() else k.label
            
            btn.text = label
            btn.setTextColor(Color.WHITE)
            btn.textSize = fontSize
            btn.gravity = Gravity.CENTER
            btn.typeface = Typeface.DEFAULT_BOLD
            
            val keyBg = GradientDrawable()
            keyBg.setColor(if (k.isSpecial) Color.parseColor("#444444") else Color.parseColor("#2A2A2A"))
            keyBg.cornerRadius = 10f
            btn.background = keyBg
            
            val params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.MATCH_PARENT)
            params.weight = k.weight
            params.setMargins(marginPx, marginPx, marginPx, marginPx)
            row.addView(btn, params)
            
            btn.setOnClickListener {
                handleKeyPress(k)
                btn.alpha = 0.5f
                btn.postDelayed({ btn.alpha = 1.0f }, 50)
            }
        }
        
        if (missingWeight > 0.1f) {
            val spacer = View(context)
            val params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.MATCH_PARENT)
            params.weight = missingWeight / 2f
            row.addView(spacer, params)
        }

        return row
    }

    private fun handleKeyPress(k: KeyDef) {
        when (k.code) {
            -1 -> { isShifted = !isShifted; refreshLayout() }
            -2 -> { isSymbols = !isSymbols; refreshLayout() }
            else -> {
                keyInjector(k.code)
                if (isShifted) { isShifted = false; refreshLayout() }
            }
        }
    }

    fun show(width: Int, height: Int) {
        if (isVisible) return
        
        currentWidth = width
        // Strict Start
        val targetHeight = (width * 0.55f).toInt()
        
        layoutParams = WindowManager.LayoutParams(
            currentWidth,
            targetHeight, 
            WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or
            WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL,
            android.graphics.PixelFormat.TRANSLUCENT
        )
        
        layoutParams?.gravity = Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
        layoutParams?.y = 0 

        keyboardLayout = createView() as FrameLayout
        windowManager.addView(keyboardLayout, layoutParams)
        isVisible = true
    }

    fun hide() {
        if (!isVisible) return
        try { windowManager.removeView(keyboardLayout) } catch (e: Exception) {}
        isVisible = false
        keyboardLayout = null
    }
    
    fun toggle(width: Int, height: Int) { if (isVisible) hide() else show(width, height) }

    private fun refreshLayout() {
        if (!isVisible) return
        val p = keyboardLayout?.layoutParams
        windowManager.removeView(keyboardLayout)
        keyboardLayout = createView() as FrameLayout
        windowManager.addView(keyboardLayout, p)
    }
}
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/SettingsActivity.kt
```kotlin
package com.example.coverscreentester

import android.app.Activity
import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.widget.Button
import android.widget.SeekBar
import android.widget.Switch

class SettingsActivity : Activity() {


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_settings)

        val prefs = getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)

        // 1. Define UI Elements
        val swTapScroll = findViewById<Switch>(R.id.swTapScroll)
        val swVibrate = findViewById<Switch>(R.id.swVibrate)
        val swReverseScroll = findViewById<Switch>(R.id.swReverseScroll) // Matches XML
        val swVPos = findViewById<Switch>(R.id.swVPos)
        val swHPos = findViewById<Switch>(R.id.swHPos)
        
        // ... rest of the file ...

        
        val seekBarCursor = findViewById<SeekBar>(R.id.seekBarCursorSpeed)
        val seekBarScroll = findViewById<SeekBar>(R.id.seekBarScrollSpeed)
        val seekCursorSize = findViewById<SeekBar>(R.id.seekBarCursorSize)
        val seekAlpha = findViewById<SeekBar>(R.id.seekBarAlpha)
        val seekHandleSize = findViewById<SeekBar>(R.id.seekBarHandleSize)
        val seekScrollVisual = findViewById<SeekBar>(R.id.seekBarScrollVisual)
        
        val seekHandleTouch = findViewById<SeekBar>(R.id.seekBarHandleTouch)
        val seekScrollTouch = findViewById<SeekBar>(R.id.seekBarScrollTouch)
        
        val btnSave = findViewById<Button>(R.id.btnSave)
        val btnBack = findViewById<Button>(R.id.btnBack)

        // =================================================================================
        // 2. LOAD SAVED VALUES
        // =================================================================================
        swTapScroll.isChecked = prefs.getBoolean("tap_scroll", true)
        swVibrate.isChecked = prefs.getBoolean("vibrate", true)
        swReverseScroll.isChecked = prefs.getBoolean("reverse_scroll", false)
        swVPos.isChecked = prefs.getBoolean("v_pos_left", false)
        swHPos.isChecked = prefs.getBoolean("h_pos_top", false)
        
        seekBarCursor.progress = ((prefs.getFloat("cursor_speed", 2.5f)) * 10).toInt()
        seekBarScroll.progress = ((prefs.getFloat("scroll_speed", 1.0f)) * 10).toInt()
        
        seekCursorSize.progress = prefs.getInt("cursor_size", 50)
        seekAlpha.progress = prefs.getInt("alpha", 50)
        seekHandleSize.progress = prefs.getInt("handle_size", 14)
        seekScrollVisual.progress = prefs.getInt("scroll_visual_size", 4)
        
        seekHandleTouch.progress = prefs.getInt("handle_touch_size", 60)
        seekScrollTouch.progress = prefs.getInt("scroll_touch_size", 60)

        // =================================================================================
        // 3. LISTENERS
        // =================================================================================
        fun createPreviewListener(target: String): SeekBar.OnSeekBarChangeListener {
            return object : SeekBar.OnSeekBarChangeListener {
                override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {
                    val intent = Intent(this@SettingsActivity, OverlayService::class.java)
                    intent.action = "PREVIEW_UPDATE"
                    intent.putExtra("TARGET", target)
                    intent.putExtra("VALUE", progress)
                    startService(intent)
                }
                override fun onStartTrackingTouch(seekBar: SeekBar?) {}
                override fun onStopTrackingTouch(seekBar: SeekBar?) {}
            }
        }

        seekCursorSize.setOnSeekBarChangeListener(createPreviewListener("cursor_size"))
        seekAlpha.setOnSeekBarChangeListener(createPreviewListener("alpha"))
        seekHandleSize.setOnSeekBarChangeListener(createPreviewListener("handle_size"))
        seekScrollVisual.setOnSeekBarChangeListener(createPreviewListener("scroll_visual"))
        seekHandleTouch.setOnSeekBarChangeListener(createPreviewListener("handle_touch"))
        seekScrollTouch.setOnSeekBarChangeListener(createPreviewListener("scroll_touch"))

        // =================================================================================
        // 4. SAVE BUTTON LOGIC
        // =================================================================================
        btnSave.setOnClickListener {
            val cVal = if (seekBarCursor.progress < 1) 0.1f else seekBarCursor.progress / 10f
            val sVal = if (seekBarScroll.progress < 1) 0.1f else seekBarScroll.progress / 10f
            
            prefs.edit()
                .putFloat("cursor_speed", cVal)
                .putFloat("scroll_speed", sVal)
                .putBoolean("tap_scroll", swTapScroll.isChecked)
                .putBoolean("vibrate", swVibrate.isChecked)
                .putBoolean("reverse_scroll", swReverseScroll.isChecked)
                .putBoolean("v_pos_left", swVPos.isChecked)
                .putBoolean("h_pos_top", swHPos.isChecked)
                .putInt("cursor_size", seekCursorSize.progress)
                .putInt("alpha", seekAlpha.progress)
                .putInt("handle_size", seekHandleSize.progress)
                .putInt("scroll_visual_size", seekScrollVisual.progress)
                .putInt("handle_touch_size", seekHandleTouch.progress)
                .putInt("scroll_touch_size", seekScrollTouch.progress)
                .apply()

            val intent = Intent(this, OverlayService::class.java)
            intent.action = "RELOAD_PREFS"
            startService(intent)
            finish()
        }

        btnBack.setOnClickListener { finish() }
    }
}
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/ShellUserService.kt
```kotlin
package com.example.coverscreentester

import android.os.Binder
import android.os.IBinder
import android.os.Process
import android.os.SystemClock
import android.util.Log
import android.view.InputDevice
import android.view.InputEvent
import android.view.KeyEvent
import android.view.MotionEvent
import com.example.coverscreentester.IShellService
import java.io.BufferedReader
import java.io.InputStreamReader
import java.lang.reflect.Method
import java.util.ArrayList
import android.os.Build
import android.annotation.SuppressLint

class ShellUserService : IShellService.Stub() {

    private val TAG = "ShellUserService"
    private lateinit var inputManager: Any
    private lateinit var injectInputEventMethod: Method
    private val INJECT_MODE_ASYNC = 0
    private var isReflectionBroken = false

    // --- Screen Control Reflection ---
    companion object {
        const val POWER_MODE_OFF = 0
        const val POWER_MODE_NORMAL = 2
        
        @Volatile private var displayControlClass: Class<*>? = null
        @Volatile private var displayControlClassLoaded = false
    }

    private val surfaceControlClass: Class<*> by lazy {
        Class.forName("android.view.SurfaceControl")
    }

    init {
        setupReflection()
    }

    private fun setupReflection() {
        try {
            val imClass = Class.forName("android.hardware.input.InputManager")
            val getInstance = imClass.getMethod("getInstance")
            inputManager = getInstance.invoke(null)!!
            injectInputEventMethod = imClass.getMethod("injectInputEvent", InputEvent::class.java, Int::class.javaPrimitiveType)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to setup reflection", e)
            isReflectionBroken = true
        }
    }

    // --- HELPER: Display Control Class (Android 14+) ---
    @SuppressLint("BlockedPrivateApi")
    private fun getDisplayControlClass(): Class<*>? {
        if (displayControlClassLoaded && displayControlClass != null) return displayControlClass
        
        return try {
            val classLoaderFactoryClass = Class.forName("com.android.internal.os.ClassLoaderFactory")
            val createClassLoaderMethod = classLoaderFactoryClass.getDeclaredMethod(
                "createClassLoader",
                String::class.java,
                String::class.java,
                String::class.java,
                ClassLoader::class.java,
                Int::class.javaPrimitiveType,
                Boolean::class.javaPrimitiveType,
                String::class.java
            )
            val classLoader = createClassLoaderMethod.invoke(
                null, "/system/framework/services.jar", null, null,
                ClassLoader.getSystemClassLoader(), 0, true, null
            ) as ClassLoader

            val loadedClass = classLoader.loadClass("com.android.server.display.DisplayControl").also {
                val loadMethod = Runtime::class.java.getDeclaredMethod(
                    "loadLibrary0",
                    Class::class.java,
                    String::class.java
                )
                loadMethod.isAccessible = true
                loadMethod.invoke(Runtime.getRuntime(), it, "android_servers")
            }
            
            displayControlClass = loadedClass
            displayControlClassLoaded = true
            loadedClass
        } catch (e: Exception) {
            Log.w(TAG, "DisplayControl not available", e)
            null
        }
    }

    // --- HELPER: Get Physical Display Tokens ---
    private fun getAllPhysicalDisplayTokens(): List<IBinder> {
        val tokens = ArrayList<IBinder>()
        try {
            val physicalIds: LongArray = if (Build.VERSION.SDK_INT >= 34) {
                val controlClass = getDisplayControlClass()
                if (controlClass != null) {
                    controlClass.getMethod("getPhysicalDisplayIds").invoke(null) as LongArray
                } else {
                     try {
                        surfaceControlClass.getMethod("getPhysicalDisplayIds").invoke(null) as LongArray
                     } catch (e: Exception) { LongArray(0) }
                }
            } else {
                surfaceControlClass.getMethod("getPhysicalDisplayIds").invoke(null) as LongArray
            }

            if (physicalIds.isEmpty()) {
                getSurfaceControlInternalToken()?.let { tokens.add(it) }
                return tokens
            }

            for (id in physicalIds) {
                try {
                    val token: IBinder? = if (Build.VERSION.SDK_INT >= 34) {
                        val controlClass = getDisplayControlClass()
                        if (controlClass != null) {
                             controlClass.getMethod("getPhysicalDisplayToken", Long::class.javaPrimitiveType)
                                .invoke(null, id) as? IBinder
                        } else {
                            surfaceControlClass.getMethod("getPhysicalDisplayToken", Long::class.javaPrimitiveType)
                                .invoke(null, id) as? IBinder
                        }
                    } else {
                        surfaceControlClass.getMethod("getPhysicalDisplayToken", Long::class.javaPrimitiveType)
                            .invoke(null, id) as? IBinder
                    }
                    
                    if (token != null) tokens.add(token)
                } catch (e: Exception) {
                    Log.w(TAG, "Failed to get token for physical ID $id", e)
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Critical failure getting display tokens", e)
        }
        return tokens
    }

    private fun getSurfaceControlInternalToken(): IBinder? {
        return try {
            if (Build.VERSION.SDK_INT < 29) {
                surfaceControlClass.getMethod("getBuiltInDisplay", Int::class.java).invoke(null, 0) as IBinder
            } else {
                surfaceControlClass.getMethod("getInternalDisplayToken").invoke(null) as IBinder
            }
        } catch (e: Exception) { null }
    }

    private fun setPowerModeOnToken(token: IBinder, mode: Int) {
        try {
            val method = surfaceControlClass.getMethod(
                "setDisplayPowerMode",
                IBinder::class.java,
                Int::class.javaPrimitiveType
            )
            method.invoke(null, token, mode)
        } catch (e: Exception) {
            Log.e(TAG, "setDisplayPowerMode failed for token $token", e)
        }
    }

    private fun setDisplayBrightnessOnToken(token: IBinder, brightness: Float): Boolean {
        try {
            val method = surfaceControlClass.getMethod(
                "setDisplayBrightness",
                IBinder::class.java,
                Float::class.javaPrimitiveType
            )
            method.invoke(null, token, brightness)
            return true
        } catch (e: Exception) {
             try {
                val method = surfaceControlClass.getMethod(
                    "setDisplayBrightness",
                    IBinder::class.java,
                    Float::class.javaPrimitiveType,
                    Float::class.javaPrimitiveType,
                    Float::class.javaPrimitiveType,
                    Float::class.javaPrimitiveType
                )
                method.invoke(null, token, brightness, brightness, brightness, brightness)
                return true
            } catch (e2: Exception) {
                return false
            }
        }
    }

    // --- SHELL COMMAND HELPER ---
    private fun execShell(cmd: String) {
        try {
            Runtime.getRuntime().exec(arrayOf("sh", "-c", cmd)).waitFor()
        } catch (e: Exception) {
            Log.e(TAG, "Shell command failed", e)
        }
    }

    // --- IMPLEMENTATION: BRIGHTNESS (ALTERNATE MODE) ---
    override fun setBrightness(value: Int) {
        val token = Binder.clearCallingIdentity()
        try {
            Log.i(TAG, "setBrightness: $value")
            execShell("settings put system screen_brightness_mode 0")

            if (value == -1) {
                // Alternate Mode (Extinguish)
                execShell("settings put system screen_brightness_min 0")
                execShell("settings put system screen_brightness_float -1.0")
                execShell("settings put system screen_brightness -1")
                
                val tokens = getAllPhysicalDisplayTokens()
                val safeTokens = tokens.take(2)
                for (t in safeTokens) {
                    setDisplayBrightnessOnToken(t, -1.0f)
                }
            } else {
                // Wake Up
                val safeVal = value.coerceIn(1, 255)
                val floatVal = safeVal / 255.0f
                
                execShell("settings put system screen_brightness_float $floatVal")
                execShell("settings put system screen_brightness $safeVal")
                
                val tokens = getAllPhysicalDisplayTokens()
                for (t in tokens) {
                    setDisplayBrightnessOnToken(t, floatVal)
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error in setBrightness", e)
        } finally {
            Binder.restoreCallingIdentity(token)
        }
    }

    // --- IMPLEMENTATION: SCREEN OFF (STANDARD MODE) ---
    override fun setScreenOff(displayIndex: Int, turnOff: Boolean) {
        val token = Binder.clearCallingIdentity()
        try {
            val mode = if (turnOff) POWER_MODE_OFF else POWER_MODE_NORMAL
            
            val tokens = getAllPhysicalDisplayTokens()
            val safeTokens = tokens.take(2) // Safety: Only target first 2 displays
            
            for (t in safeTokens) {
                setPowerModeOnToken(t, mode)
            }
        } catch (e: Exception) {
            Log.e(TAG, "setScreenOff failed", e)
        } finally {
            Binder.restoreCallingIdentity(token)
        }
    }
    
    override fun setBrightnessViaDisplayManager(displayId: Int, brightness: Float): Boolean {
        return false
    }

    override fun setSystemCursorVisibility(visible: Boolean) {
        val token = Binder.clearCallingIdentity()
        try {
            if (this::inputManager.isInitialized) {
                val method = inputManager.javaClass.getMethod("setCursorVisibility", Boolean::class.javaPrimitiveType)
                method.invoke(inputManager, visible)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to set cursor visibility", e)
        } finally {
            Binder.restoreCallingIdentity(token)
        }
    }

    // --- INPUT INJECTION ---
    override fun injectKey(keyCode: Int, action: Int, metaState: Int, displayId: Int, deviceId: Int) {
        if (!this::inputManager.isInitialized) return
        val now = SystemClock.uptimeMillis()
        
        // CRITICAL CONFIGURATION:
        // Device ID = 1 (Mimics the "Hardware Keyboard" we use to block soft-kb)
        // Scan Code = 0 (Generic/Ignore). Setting this to 1 caused the buffering/reject issue.
        val forcedDeviceId = 1 
        val finalScanCode = 0 
        val finalFlags = 8 // FLAG_FROM_SYSTEM
        
        val event = KeyEvent(
            now, now, action, keyCode, 0, metaState, 
            forcedDeviceId, finalScanCode, finalFlags, 
            InputDevice.SOURCE_KEYBOARD
        )
        
        try {
            // Restore Display Targeting
            // We MUST target the display where the user is looking.
            val method = InputEvent::class.java.getMethod("setDisplayId", Int::class.javaPrimitiveType)
            method.invoke(event, displayId)
            
            injectInputEventMethod.invoke(inputManager, event, INJECT_MODE_ASYNC)
        } catch (e: Exception) {
            // Fallback
            if (action == KeyEvent.ACTION_DOWN) execShell("input keyevent $keyCode")
        }
    }

    // Trigger to force system to update "Hardware Keyboard" status immediately
    override fun injectDummyHardwareKey(displayId: Int) {
         if (!this::inputManager.isInitialized) return
         val now = SystemClock.uptimeMillis()
         
         // Use SAME ID (1) as the text injection to maintain consistency
         val eventDown = KeyEvent(now, now, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_SHIFT_LEFT, 0, 0, 1, 1, 8, InputDevice.SOURCE_KEYBOARD)
         val eventUp = KeyEvent(now, now, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_SHIFT_LEFT, 0, 0, 1, 1, 8, InputDevice.SOURCE_KEYBOARD)
         
         try {
            val method = InputEvent::class.java.getMethod("setDisplayId", Int::class.javaPrimitiveType)
            method.invoke(eventDown, displayId)
            method.invoke(eventUp, displayId)
            
            injectInputEventMethod.invoke(inputManager, eventDown, INJECT_MODE_ASYNC)
            injectInputEventMethod.invoke(inputManager, eventUp, INJECT_MODE_ASYNC)
         } catch(e: Exception) {}
    }

    override fun injectMouse(action: Int, x: Float, y: Float, displayId: Int, source: Int, buttonState: Int, downTime: Long) {
        injectInternal(action, x, y, displayId, downTime, SystemClock.uptimeMillis(), source, buttonState)
    }
    
    override fun injectScroll(x: Float, y: Float, vDistance: Float, hDistance: Float, displayId: Int) {
         if (!this::inputManager.isInitialized) return
         val now = SystemClock.uptimeMillis()
         val props = MotionEvent.PointerProperties(); props.id = 0; props.toolType = MotionEvent.TOOL_TYPE_MOUSE
         val coords = MotionEvent.PointerCoords(); coords.x = x; coords.y = y; coords.pressure = 1.0f; coords.size = 1.0f
         coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vDistance)
         coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hDistance)
         try {
             val event = MotionEvent.obtain(now, now, MotionEvent.ACTION_SCROLL, 1, arrayOf(props), arrayOf(coords), 0, 0, 1.0f, 1.0f, 0, 0, InputDevice.SOURCE_MOUSE, 0)
             val method = MotionEvent::class.java.getMethod("setDisplayId", Int::class.javaPrimitiveType)
             method.invoke(event, displayId)
             injectInputEventMethod.invoke(inputManager, event, INJECT_MODE_ASYNC)
             event.recycle()
         } catch(e: Exception){}
    }

    override fun execClick(x: Float, y: Float, displayId: Int) {
        val now = SystemClock.uptimeMillis()
        // Fix: Use SOURCE_TOUCHSCREEN to mimic a physical Finger tap
        // This is more reliable than Mouse events for Android UI elements
        injectInternal(MotionEvent.ACTION_DOWN, x, y, displayId, now, now, InputDevice.SOURCE_TOUCHSCREEN, 0)
        try { Thread.sleep(60) } catch (e: InterruptedException) {}
        injectInternal(MotionEvent.ACTION_UP, x, y, displayId, now, now+60, InputDevice.SOURCE_TOUCHSCREEN, 0)
    }

    override fun execRightClick(x: Float, y: Float, displayId: Int) {
        val now = SystemClock.uptimeMillis()
        // Right click must remain MOUSE (Android doesn't have right-click for touch)
        injectInternal(MotionEvent.ACTION_DOWN, x, y, displayId, now, now, InputDevice.SOURCE_MOUSE, MotionEvent.BUTTON_SECONDARY)
        try { Thread.sleep(60) } catch (e: InterruptedException) {}
        injectInternal(MotionEvent.ACTION_UP, x, y, displayId, now, now+60, InputDevice.SOURCE_MOUSE, 0)
    }

    private fun injectInternal(action: Int, x: Float, y: Float, displayId: Int, downTime: Long, eventTime: Long, source: Int, buttonState: Int) {
        if (!this::inputManager.isInitialized) return
        val props = MotionEvent.PointerProperties(); props.id = 0
        props.toolType = if (source == InputDevice.SOURCE_MOUSE) MotionEvent.TOOL_TYPE_MOUSE else MotionEvent.TOOL_TYPE_FINGER
        val coords = MotionEvent.PointerCoords(); coords.x = x; coords.y = y
        coords.pressure = if (buttonState != 0 || action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_MOVE) 1.0f else 0.0f; coords.size = 1.0f
        try {
            val event = MotionEvent.obtain(downTime, eventTime, action, 1, arrayOf(props), arrayOf(coords), 0, buttonState, 1.0f, 1.0f, 0, 0, source, 0)
            val method = MotionEvent::class.java.getMethod("setDisplayId", Int::class.javaPrimitiveType)
            method.invoke(event, displayId)
            injectInputEventMethod.invoke(inputManager, event, INJECT_MODE_ASYNC)
            event.recycle()
        } catch (e: Exception) { Log.e(TAG, "Injection failed", e) }
    }

    override fun setWindowingMode(taskId: Int, mode: Int) {}
    override fun resizeTask(taskId: Int, left: Int, top: Int, right: Int, bottom: Int) {}
    override fun runCommand(cmd: String): String {
        val token = Binder.clearCallingIdentity()
        val output = StringBuilder()
        try {
            val process = Runtime.getRuntime().exec(arrayOf("sh", "-c", cmd))
            val reader = BufferedReader(InputStreamReader(process.inputStream))
            var line: String?
            while (reader.readLine().also { line = it } != null) {
                output.append(line).append("\n")
            }
            reader.close()
            process.waitFor()
        } catch (e: Exception) {
            Log.e(TAG, "runCommand failed: $cmd", e)
        } finally {
            Binder.restoreCallingIdentity(token)
        }
        return output.toString()
    }
}
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/ShizukuInputHandler.kt
```kotlin
package com.example.coverscreentester

import android.os.SystemClock
import android.view.InputDevice
import android.view.MotionEvent

class ShizukuInputHandler(
    private val shellService: IShellService?,
    private var displayId: Int
) {
    fun updateDisplay(newDisplayId: Int) {
        this.displayId = newDisplayId
    }

    fun moveMouseRelative(dx: Float, dy: Float) {
        if (shellService == null) return
        
        // Convert to Int for shell command
        val dxInt = dx.toInt()
        val dyInt = dy.toInt()
        
        if (dxInt == 0 && dyInt == 0) return

        Thread {
            try {
                // Use input command for relative movement
                shellService.runCommand("input -d $displayId mouse relative $dxInt $dyInt")
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }.start()
    }

    fun injectKey(keyCode: Int, metaState: Int) {
        if (shellService == null) return
        Thread {
            try {
                // Inject Down and Up events
                shellService.injectKey(keyCode, android.view.KeyEvent.ACTION_DOWN, metaState, displayId, -1)
                Thread.sleep(10)
                shellService.injectKey(keyCode, android.view.KeyEvent.ACTION_UP, metaState, displayId, -1)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }.start()
    }
}
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/TrackpadPrefs.kt
```kotlin
package com.example.coverscreentester

class TrackpadPrefs {
    var cursorSpeed = 2.5f
    var scrollSpeed = 6.0f
    var prefTapScroll = true
    var prefVibrate = false
    var prefReverseScroll = false
    var prefAlpha = 50
    var prefBgAlpha = 220
    var prefKeyboardAlpha = 255
    var prefHandleSize = 14
    var prefVPosLeft = false
    var prefHPosTop = false
    var prefLocked = false
    var prefHandleTouchSize = 80
    var prefScrollTouchSize = 80
    var prefScrollVisualSize = 4
    var prefCursorSize = 50
    var prefKeyScale = 135
    var prefUseAltScreenOff = true
    var prefAutomationEnabled = true
    var prefBubbleX = 50
    var prefBubbleY = 300
    var prefAnchored = false
    var prefBubbleSize = 100
    var prefBubbleIconIndex = 0
    var prefBubbleAlpha = 255
    var prefPersistentService = false
    var prefBlockSoftKeyboard = false

    // =================================================================================
    // VIRTUAL MIRROR MODE PREFERENCES
    // SUMMARY: Settings for displaying a mirror keyboard on remote/AR display.
    //          When enabled, touching the physical keyboard shows an orange orientation
    //          trail on both displays. After finger stops for orientDelayMs, normal
    //          keyboard input resumes.
    // =================================================================================
    var prefVirtualMirrorMode = false
    var prefMirrorOrientDelayMs = 1000L  // Default 1 second orientation delay
    // =================================================================================
    // END BLOCK: VIRTUAL MIRROR MODE PREFERENCES
    // =================================================================================

    var prefOverrideSystemShortcuts = true
    var customModKey = 0 // To persist across view rebuilds

    var hardkeyVolUpTap = "left_click"
    var hardkeyVolUpDouble = "left_click"
    var hardkeyVolUpHold = "left_click"
    var hardkeyVolDownTap = "toggle_keyboard"
    var hardkeyVolDownDouble = "open_menu"
    var hardkeyVolDownHold = "action_back"
    var hardkeyPowerDouble = "none"
    var doubleTapMs = 300
    var holdDurationMs = 400
    var displayOffMode = "alternate"
}
```

## File: Cover-Screen-Trackpad/app/src/main/res/layout/activity_settings.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#000000"
    android:padding="16dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Trackpad Settings"
            android:textColor="#FFFFFF"
            android:textSize="20sp"
            android:textStyle="bold"
            android:layout_marginBottom="16dp"/>

        <Switch
            android:id="@+id/swTapScroll"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Tap to Scroll"
            android:textColor="#FFFFFF"
            android:minHeight="48dp"
            android:layout_marginBottom="8dp"/>

        <Switch
            android:id="@+id/swVibrate"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Haptic Feedback"
            android:textColor="#FFFFFF"
            android:minHeight="48dp"
            android:layout_marginBottom="8dp"/>

        <Switch
            android:id="@+id/swReverseScroll"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Reverse Scrolling"
            android:textColor="#FFFFFF"
            android:minHeight="48dp"
            android:layout_marginBottom="8dp"/>

        <Switch
            android:id="@+id/swVPos"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Vertical Position (Left/Top)"
            android:textColor="#FFFFFF"
            android:minHeight="48dp"
            android:layout_marginBottom="8dp"/>

        <Switch
            android:id="@+id/swHPos"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Horizontal Position (Top/Left)"
            android:textColor="#FFFFFF"
            android:minHeight="48dp"
            android:layout_marginBottom="16dp"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Cursor Speed"
            android:textColor="#FFFFFF"/>
        <SeekBar
            android:id="@+id/seekBarCursorSpeed"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="100"
            android:progress="25"
            android:layout_marginBottom="16dp"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Scroll Speed"
            android:textColor="#FFFFFF"/>
        <SeekBar
            android:id="@+id/seekBarScrollSpeed"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="100"
            android:progress="10"
            android:layout_marginBottom="16dp"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Cursor Size"
            android:textColor="#FFFFFF"/>
        <SeekBar
            android:id="@+id/seekBarCursorSize"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="100"
            android:progress="50"
            android:layout_marginBottom="16dp"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Transparency"
            android:textColor="#FFFFFF"/>
        <SeekBar
            android:id="@+id/seekBarAlpha"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="255"
            android:progress="50"
            android:layout_marginBottom="16dp"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Handle Size"
            android:textColor="#FFFFFF"/>
        <SeekBar
            android:id="@+id/seekBarHandleSize"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="50"
            android:progress="14"
            android:layout_marginBottom="16dp"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Scroll Visual Size"
            android:textColor="#FFFFFF"/>
        <SeekBar
            android:id="@+id/seekBarScrollVisual"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="20"
            android:progress="4"
            android:layout_marginBottom="16dp"/>
            
        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Handle Touch Area"
            android:textColor="#FFFFFF"/>
        <SeekBar
            android:id="@+id/seekBarHandleTouch"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="150"
            android:progress="60"
            android:layout_marginBottom="16dp"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Scroll Touch Area"
            android:textColor="#FFFFFF"/>
        <SeekBar
            android:id="@+id/seekBarScrollTouch"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="150"
            android:progress="60"
            android:layout_marginBottom="16dp"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Prediction: Fast/Sloppy (Left) vs Neat (Right)"
            android:textColor="#FFFFFF"
            android:layout_marginBottom="4dp"/>
            
        <SeekBar
            android:id="@+id/seekBarPrediction"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="170"
            android:progress="50"
            android:layout_marginBottom="24dp"/>

        <Button
            android:id="@+id/btnSave"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Save &amp; Reload"
            android:layout_marginBottom="8dp"/>

        <Button
            android:id="@+id/btnBack"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Back"/>

    </LinearLayout>
</ScrollView>
```

## File: Cover-Screen-Trackpad/app/src/main/res/layout/item_trackpad_menu.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:background="@drawable/bg_item_press"
    android:padding="8dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:minHeight="40dp">

        <ImageView
            android:id="@+id/item_icon"
            android:layout_width="24dp"
            android:layout_height="24dp"
            android:src="@drawable/ic_cursor"
            app:tint="#AAAAAA"
            android:layout_marginEnd="12dp"/>

        <TextView
            android:id="@+id/item_title"
            android:layout_width="0dp"
            android:layout_weight="1"
            android:layout_height="wrap_content"
            android:text="Setting Name"
            android:textColor="#FFFFFF"
            android:textSize="16sp"/>

        <TextView
            android:id="@+id/item_value_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="100%"
            android:textColor="#3DDC84"
            android:visibility="gone"
            android:paddingEnd="8dp"/>

        <Switch
            android:id="@+id/item_switch"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:visibility="gone"/>
            
        <ImageView
            android:id="@+id/item_action_icon"
            android:layout_width="24dp"
            android:layout_height="24dp"
            android:src="@android:drawable/ic_media_play"
            app:tint="#3DDC84"
            android:visibility="gone"/>

    </LinearLayout>

    <SeekBar
        android:id="@+id/item_seekbar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="4dp"
        android:visibility="gone"/>

    <GridLayout
        android:id="@+id/item_dpad_grid"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:columnCount="3"
        android:rowCount="3"
        android:visibility="gone"
        android:padding="8dp">

        <Space android:layout_width="50dp" android:layout_height="50dp"/>
        <Button android:id="@+id/btn_up" android:text="" android:layout_width="50dp" android:layout_height="50dp" android:backgroundTint="#333333" android:textColor="#FFFFFF"/>
        <Space android:layout_width="50dp" android:layout_height="50dp"/>

        <Button android:id="@+id/btn_left" android:text="" android:layout_width="50dp" android:layout_height="50dp" android:backgroundTint="#333333" android:textColor="#FFFFFF"/>
        <Button android:id="@+id/btn_center" android:text="" android:layout_width="50dp" android:layout_height="50dp" android:backgroundTint="#555555" android:textColor="#FFFFFF"/>
        <Button android:id="@+id/btn_right" android:text="" android:layout_width="50dp" android:layout_height="50dp" android:backgroundTint="#333333" android:textColor="#FFFFFF"/>

        <Space android:layout_width="50dp" android:layout_height="50dp"/>
        <Button android:id="@+id/btn_down" android:text="" android:layout_width="50dp" android:layout_height="50dp" android:backgroundTint="#333333" android:textColor="#FFFFFF"/>
        <Space android:layout_width="50dp" android:layout_height="50dp"/>
    </GridLayout>

    <TextView
        android:id="@+id/item_help_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Help text goes here..."
        android:textColor="#AAAAAA"
        android:textSize="14sp"
        android:visibility="gone"
        android:padding="4dp"/>

</LinearLayout>
```

## File: Cover-Screen-Trackpad/app/src/main/res/menu/dock_menu.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item
        android:id="@+id/item_resize_mode"
        android:title="Auto Resize App Mode"
        android:checkable="true"
        android:checked="false"
        android:icon="@android:drawable/ic_menu_crop" />
    
    <item
        android:id="@+id/item_switch_ime"
        android:title="Switch to Gboard/Other"
        android:icon="@android:drawable/ic_menu_set_as" />
    
    <item
        android:id="@+id/item_settings"
        android:title="Settings"
        android:icon="@android:drawable/ic_menu_preferences" />
        
    <item
        android:id="@+id/item_exit"
        android:title="Exit DroidOS IME"
        android:icon="@android:drawable/ic_menu_close_clear_cancel" />
</menu>
```

## File: Cover-Screen-Trackpad/app/src/main/res/xml/accessibility_service_config.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<accessibility-service xmlns:android="http://schemas.android.com/apk/res/android"
    android:description="@string/accessibility_service_description"
    android:accessibilityEventTypes="typeAllMask"
    android:accessibilityFeedbackType="feedbackGeneric"
    android:notificationTimeout="100"
    android:canRetrieveWindowContent="true"
    android:canPerformGestures="false" 
    android:canRequestFilterKeyEvents="true" 
    android:accessibilityFlags="flagRequestTouchExplorationMode|flagRequestFilterKeyEvents" />
```

## File: Cover-Screen-Trackpad/app/src/main/AndroidManifest.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_SPECIAL_USE" />
    <uses-permission android:name="android.permission.VIBRATE" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />

    <queries>
        <package android:name="moe.shizuku.privileged.api" />
        <package android:name="rikka.shizuku.ui" />
        <intent>
            <action android:name="android.speech.action.RECOGNIZE_SPEECH" />
        </intent>
        <intent>
            <action android:name="android.intent.action.VOICE_COMMAND" />
        </intent>
        <package android:name="com.google.android.googlequicksearchbox" />
    </queries>

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_trackpad_adaptive"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_trackpad_adaptive"
        android:supportsRtl="true"
        android:theme="@style/Theme.CoverScreenTester"
        android:resizeableActivity="true"> 
        
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:configChanges="orientation|screenSize|screenLayout|density|smallestScreenSize"
            android:windowSoftInputMode="adjustResize">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
            
            <meta-data android:name="android.max_aspect" android:value="4.0" />
        </activity>

        <activity 
            android:name=".SettingsActivity"
            android:exported="false" 
            android:theme="@style/Theme.CoverScreenTester" />

        <activity 
            android:name=".ProfilesActivity"
            android:exported="false" 
            android:theme="@style/Theme.CoverScreenTester" />

        <activity 
            android:name=".ManualAdjustActivity"
            android:exported="false" 
            android:theme="@style/Theme.CoverScreenTester" />
            
        <activity 
            android:name=".KeyboardActivity"
            android:exported="false" 
            android:theme="@android:style/Theme.Translucent.NoTitleBar"
            android:excludeFromRecents="true"
            android:noHistory="true" />

        <activity
            android:name=".KeyboardPickerActivity"
            android:theme="@android:style/Theme.Translucent.NoTitleBar"
            android:excludeFromRecents="true"
            android:taskAffinity=""
            android:launchMode="singleInstance"
            android:exported="false" />

        <service
            android:name=".OverlayService"
            android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"
            android:exported="true"
            android:foregroundServiceType="specialUse">
            <intent-filter>
                <action android:name="android.accessibilityservice.AccessibilityService" />
                <action android:name="PREVIEW_UPDATE" />
                <action android:name="RESET_POSITION" />
                <action android:name="ROTATE" />
                <action android:name="SAVE_LAYOUT" />
                <action android:name="LOAD_LAYOUT" />
                <action android:name="RELOAD_PREFS" />
                <action android:name="DELETE_PROFILE" />
                <action android:name="MANUAL_ADJUST" /> 
                <action android:name="CYCLE_INPUT_TARGET" />
                <action android:name="RESET_CURSOR" />
                <action android:name="TOGGLE_DEBUG" />
                <action android:name="FORCE_KEYBOARD" />
                <action android:name="TOGGLE_CUSTOM_KEYBOARD" />
                <action android:name="SET_TRACKPAD_VISIBILITY" />
                <action android:name="SET_PREVIEW_MODE" />
            </intent-filter>
            <meta-data
                android:name="android.accessibilityservice"
                android:resource="@xml/accessibility_service_config" />
        </service>

        <service
            android:name=".DockInputMethodService"
            android:label="DroidOS Input Dock"
            android:permission="android.permission.BIND_INPUT_METHOD"
            android:exported="true">
            <intent-filter>
                <action android:name="android.view.InputMethod" />
            </intent-filter>
            <meta-data
                android:name="android.view.im"
                android:resource="@xml/method" />
        </service>

        <!-- =================================================================================
             INTER-APP COMMAND RECEIVER
             SUMMARY: Static receiver to handle commands from DroidOS Launcher and ADB.
                      Allows soft restart, z-order fixes, and virtual display coordination
                      without requiring the Activity to be in foreground.
             USAGE (ADB): adb shell am broadcast -a com.example.coverscreentester.SOFT_RESTART
             ================================================================================= -->
                <receiver android:name=".InterAppCommandReceiver" android:enabled="true" android:exported="true">
                    <intent-filter>
                        <action android:name="com.example.coverscreentester.SOFT_RESTART" />
                        <action android:name="com.example.coverscreentester.MOVE_TO_VIRTUAL" />
                        <action android:name="com.example.coverscreentester.RETURN_TO_PHYSICAL" />
                        <action android:name="com.example.coverscreentester.ENFORCE_ZORDER" />
                        <action android:name="com.example.coverscreentester.TOGGLE_VIRTUAL_MIRROR" />
                        <action android:name="com.example.coverscreentester.OPEN_DRAWER" />
                        <action android:name="com.example.coverscreentester.GET_STATUS" />
                        <action android:name="com.example.coverscreentester.STOP_SERVICE" />
        
                        <action android:name="com.katsuyamaki.DroidOSTrackpadKeyboard.SOFT_RESTART" />
                        <action android:name="com.katsuyamaki.DroidOSTrackpadKeyboard.MOVE_TO_VIRTUAL" />
                        <action android:name="com.katsuyamaki.DroidOSTrackpadKeyboard.RETURN_TO_PHYSICAL" />
                        <action android:name="com.katsuyamaki.DroidOSTrackpadKeyboard.ENFORCE_ZORDER" />
                        <action android:name="com.katsuyamaki.DroidOSTrackpadKeyboard.TOGGLE_VIRTUAL_MIRROR" />
                        <action android:name="com.katsuyamaki.DroidOSTrackpadKeyboard.OPEN_DRAWER" />
                        <action android:name="com.katsuyamaki.DroidOSTrackpadKeyboard.GET_STATUS" />
                        <action android:name="com.katsuyamaki.DroidOSTrackpadKeyboard.STOP_SERVICE" />
                    </intent-filter>
                </receiver>
        <!-- END BLOCK: INTER-APP COMMAND RECEIVER -->

        <provider
            android:name="rikka.shizuku.ShizukuProvider"
            android:authorities="${applicationId}.shizuku"
            android:enabled="true"
            android:exported="true"
            android:multiprocess="false" />

    </application>

</manifest>
```

## File: Cover-Screen-Trackpad/app/src/main/AndroidManifest.xml.update
```
<!-- Add this inside <application> tag -->
<service
    android:name=".DroidOSIME"
    android:label="@string/keyboard_name"
    android:permission="android.permission.BIND_INPUT_METHOD">
    <intent-filter>
        <action android:name="android.view.InputMethod" />
    </intent-filter>
    <meta-data
        android:name="android.view.im"
        android:resource="@xml/method" />
</service>

<service 
    android:name=".DockInputMethodService"
    android:enabled="true"
    android:exported="false" />
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/activity_permissions.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#121212"
    android:fillViewport="true">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="24dp"
        android:gravity="center_horizontal">

        <ImageView
            android:layout_width="80dp"
            android:layout_height="80dp"
            android:src="@mipmap/ic_launcher_adaptive"
            android:layout_marginBottom="16dp"/>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="DroidOS Launcher"
            android:textSize="28sp"
            android:textStyle="bold"
            android:textColor="#FFFFFF"
            android:layout_marginBottom="8dp" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Required Permissions"
            android:textSize="14sp"
            android:textColor="#AAAAAA"
            android:layout_marginBottom="30dp" />

        <!-- STEP 1: RESTRICTED SETTINGS -->
        <LinearLayout
            android:id="@+id/btn_perm_restricted"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:background="@drawable/bg_item_press"
            android:padding="16dp"
            android:layout_marginBottom="12dp"
            android:gravity="center_vertical"
            android:clickable="true"
            android:focusable="true">
            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:orientation="vertical">
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="1. Unlock Restrictions"
                    android:textColor="#FF9800"
                    android:textSize="16sp"
                    android:textStyle="bold"/>
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Tap  3-dots (top right)  Allow Restricted"
                    android:textColor="#888888"
                    android:textSize="12sp"/>
            </LinearLayout>
            <ImageView
                android:id="@+id/icon_status_restricted"
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@android:drawable/ic_menu_info_details"
                android:tint="#FF9800"/>
        </LinearLayout>

        <!-- STEP 2: OVERLAY -->
        <LinearLayout
            android:id="@+id/btn_perm_overlay"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:background="@drawable/bg_item_press"
            android:padding="16dp"
            android:layout_marginBottom="12dp"
            android:gravity="center_vertical"
            android:clickable="true"
            android:focusable="true">
            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:orientation="vertical">
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="2. Display Over Apps"
                    android:textColor="#FFFFFF"
                    android:textSize="16sp"
                    android:textStyle="bold"/>
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Required for Floating Bubble"
                    android:textColor="#888888"
                    android:textSize="12sp"/>
            </LinearLayout>
            <ImageView
                android:id="@+id/icon_status_overlay"
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@android:drawable/checkbox_off_background"/>
        </LinearLayout>

        <!-- STEP 3: ACCESSIBILITY -->
        <LinearLayout
            android:id="@+id/btn_perm_accessibility"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:background="@drawable/bg_item_press"
            android:padding="16dp"
            android:layout_marginBottom="12dp"
            android:gravity="center_vertical"
            android:clickable="true"
            android:focusable="true">
            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:orientation="vertical">
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="3. Accessibility Service"
                    android:textColor="#FFFFFF"
                    android:textSize="16sp"
                    android:textStyle="bold"/>
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Required for App Switching"
                    android:textColor="#888888"
                    android:textSize="12sp"/>
            </LinearLayout>
            <ImageView
                android:id="@+id/icon_status_accessibility"
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@android:drawable/checkbox_off_background"/>
        </LinearLayout>

        <!-- STEP 4: SHIZUKU -->
        <LinearLayout
            android:id="@+id/btn_perm_shizuku"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:background="@drawable/bg_item_press"
            android:padding="16dp"
            android:layout_marginBottom="32dp"
            android:gravity="center_vertical"
            android:clickable="true"
            android:focusable="true">
            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:orientation="vertical">
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="4. Shizuku Access"
                    android:textColor="#FFFFFF"
                    android:textSize="16sp"
                    android:textStyle="bold"/>
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Required for Window Control"
                    android:textColor="#888888"
                    android:textSize="12sp"/>
            </LinearLayout>
            <ImageView
                android:id="@+id/icon_status_shizuku"
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@android:drawable/checkbox_off_background"/>
        </LinearLayout>

        <Button
            android:id="@+id/btn_continue"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Grant Permissions First"
            android:backgroundTint="#00A0E9"
            android:textColor="#FFFFFF"
            android:padding="14dp"
            android:alpha="0.5"
            android:enabled="false"/>

    </LinearLayout>
</ScrollView>
```

## File: Cover-Screen-Trackpad/app/src/main/aidl/com/example/coverscreentester/IShellService.aidl
```
package com.example.coverscreentester;

interface IShellService {
    void injectMouse(int action, float x, float y, int displayId, int source, int buttonState, long downTime);
    void injectScroll(float x, float y, float vDistance, float hDistance, int displayId);
    void execClick(float x, float y, int displayId);
    void execRightClick(float x, float y, int displayId);
    
    // Updated to support deviceId parameter
    void injectKey(int keyCode, int action, int metaState, int displayId, int deviceId);
    
    // NEW: Trigger for "Hardware Keyboard" detection
    void injectDummyHardwareKey(int displayId);
    
    void setWindowingMode(int taskId, int mode);
    void resizeTask(int taskId, int left, int top, int right, int bottom);
    String runCommand(String cmd);

    // Screen Control Methods
    void setScreenOff(int displayIndex, boolean turnOff);
    void setBrightness(int value);
    boolean setBrightnessViaDisplayManager(int displayId, float brightness);
    void setSystemCursorVisibility(boolean visible);
}
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/MainActivity.kt
```kotlin
package com.example.coverscreentester

import android.accessibilityservice.AccessibilityServiceInfo
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.provider.Settings
import android.view.accessibility.AccessibilityManager
import android.widget.Button
import android.widget.Toast
import android.os.Build
import androidx.appcompat.app.AppCompatActivity
import rikka.shizuku.Shizuku

// =================================================================================
// MAINACTIVITY: Permission Landing Page and Service Launcher
// SUMMARY: This activity displays permission status and launches the OverlayService
//          once all required permissions are granted. On subsequent launches where
//          permissions are already granted, it skips the UI and goes directly to
//          recalling/launching the service.
// =================================================================================

class MainActivity : AppCompatActivity(), Shizuku.OnRequestPermissionResultListener {

    // Wizard UI Elements
    private lateinit var containerRestricted: android.widget.LinearLayout
    private lateinit var containerAccessibility: android.widget.LinearLayout
    private lateinit var containerShizuku: android.widget.LinearLayout

    private lateinit var iconRestricted: android.widget.ImageView
    private lateinit var iconAccessibility: android.widget.ImageView
    private lateinit var iconShizuku: android.widget.ImageView

    private lateinit var btnLaunch: android.widget.Button
    
    // Track if we've already initialized the UI
    private var uiInitialized = false

override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // [SAFETY] PANIC RESET: Tap App Icon 3 times in 5 seconds to Reset
        val prefs = getSharedPreferences("PanicState", Context.MODE_PRIVATE)
        val now = System.currentTimeMillis()
        val lastLaunch = prefs.getLong("last_launch", 0)
        var count = prefs.getInt("launch_count", 0)

        if (now - lastLaunch < 5000) {
            count++
        } else {
            count = 1
        }
        prefs.edit().putLong("last_launch", now).putInt("launch_count", count).commit()

        if (count >= 3) {
            val v = getSystemService(Context.VIBRATOR_SERVICE) as android.os.Vibrator
            if (Build.VERSION.SDK_INT >= 26) {
                v.vibrate(android.os.VibrationEffect.createOneShot(500, 255))
            } else { @Suppress("DEPRECATION") v.vibrate(500) }

            Toast.makeText(this, "!!! TRACKPAD RESET !!!", Toast.LENGTH_LONG).show()

            // Send Force Reset Broadcast (Unblocks Keyboard, Wakes Screen)
            val resetIntent = Intent("com.example.coverscreentester.SOFT_RESTART")
            sendBroadcast(resetIntent)

            val stopIntent = Intent(this, OverlayService::class.java)
            stopService(stopIntent)

            android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
                android.os.Process.killProcess(android.os.Process.myPid())
                System.exit(0)
            }, 500)

            finish()
            return
        }

        // DEBUG LOG
        val dId = intent.getIntExtra("displayId", -999)
        val force = intent.getBooleanExtra("force_start", false)
        val isRestart = intent.getBooleanExtra("IS_RESTART", false)
        android.util.Log.w("MainActivity", ">>> ON CREATE | Display: $dId | Force: $force | IsRestart: $isRestart <<<")
        
        if (dId != -999) {
            Toast.makeText(this, "Activity Woke: D$dId", Toast.LENGTH_SHORT).show()
        }
        
        // [FIX] Check for Force Start flag from Launcher (Hard Restart)
        // If this flag is present, we assume the Launcher has already handled 
        // permissions/shizuku and we should just start the service immediately.
        val isForceStart = intent.getBooleanExtra("force_start", false)
        
        // Check permissions OR Force Start flag
        if (isForceStart || checkCriticalPermissions()) {
            // All permissions granted (or forced) - skip UI and launch/recall service
            launchOverlayServiceAndFinish()
            return
        }
        
        // Permissions not granted - show the permission landing page
        initializePermissionUI()
    }
    
    // =================================================================================
    // FUNCTION: initializePermissionUI
    // SUMMARY: Sets up the permission status UI with buttons matching the actual layout.
    //          Only called when permissions are missing on first launch.
    // =================================================================================
    private fun initializePermissionUI() {
        setContentView(R.layout.activity_main)
        uiInitialized = true

        // Bind Views
        containerRestricted = findViewById(R.id.btn_fix_restricted)
        containerAccessibility = findViewById(R.id.btn_open_accessibility)
        containerShizuku = findViewById(R.id.btn_start_check)

        iconRestricted = findViewById(R.id.icon_restricted)
        iconAccessibility = findViewById(R.id.icon_accessibility)
        iconShizuku = findViewById(R.id.icon_shizuku)

        btnLaunch = findViewById(R.id.btn_switch_display)

        // Register Shizuku listener
        Shizuku.addRequestPermissionResultListener(this)

        // Click Listeners
        containerRestricted.setOnClickListener { openAppInfo() }
        containerAccessibility.setOnClickListener { openAccessibilitySettings() }

        containerShizuku.setOnClickListener {
            if (!isShizukuReady()) {
                requestShizukuPermission()
            } else {
                Toast.makeText(this, "Shizuku already active", Toast.LENGTH_SHORT).show()
                updateButtonStates()
            }
        }

        btnLaunch.setOnClickListener {
            // Final check
            if (checkCriticalPermissions()) {
                launchOverlayServiceAndFinish()
            } else {
                showMissingPermissionsToast()
            }
        }

        updateButtonStates()
    }
    // =================================================================================
    // END FUNCTION: initializePermissionUI
    // =================================================================================

    override fun onResume() {
        super.onResume()
        
        // Only update UI if we're showing the permission page
        if (uiInitialized) {
            // Check again in case user granted permissions and came back
            if (checkCriticalPermissions()) {
                launchOverlayServiceAndFinish()
                return
            }
            updateButtonStates()
        }
    }

    // =================================================================================
    // FUNCTION: updateButtonStates
    // SUMMARY: Updates button colors/states based on current permission status.
    // =================================================================================
    private fun updateButtonStates() {
        if (!uiInitialized) return

        val isAccessibilityReady = isAccessibilityEnabled()
        val isShizukuReady = isShizukuReady()

        // Helper to update row visual state
        fun updateRow(container: android.widget.LinearLayout, icon: android.widget.ImageView, isDone: Boolean) {
            if (isDone) {
                icon.setImageResource(android.R.drawable.checkbox_on_background)
                icon.setColorFilter(android.graphics.Color.GREEN)
                container.alpha = 0.5f // Dim when done
            } else {
                icon.setImageResource(android.R.drawable.checkbox_off_background)
                icon.setColorFilter(android.graphics.Color.RED)
                container.alpha = 1.0f
            }
        }

        // 1. Restricted Settings (Implicit: if Accessibility works, this is done)
        updateRow(containerRestricted, iconRestricted, isAccessibilityReady)
        if (isAccessibilityReady) iconRestricted.setColorFilter(android.graphics.Color.GREEN)

        // 2. Accessibility
        updateRow(containerAccessibility, iconAccessibility, isAccessibilityReady)

        // 3. Shizuku
        updateRow(containerShizuku, iconShizuku, isShizukuReady)

        // 4. Launch Button State
        if (isAccessibilityReady && isShizukuReady) {
            btnLaunch.isEnabled = true
            btnLaunch.alpha = 1.0f
            btnLaunch.text = "LAUNCH TRACKPAD"
            btnLaunch.backgroundTintList = android.content.res.ColorStateList.valueOf(android.graphics.Color.parseColor("#3DDC84"))
        } else {
            btnLaunch.isEnabled = false
            btnLaunch.alpha = 0.5f

            // Helpful Guide Text
            btnLaunch.text = when {
                !isAccessibilityReady -> "Step 2: Enable Accessibility"
                !isShizukuReady -> "Step 3: Grant Shizuku"
                else -> "Grant Permissions First"
            }
        }
    }
    // =================================================================================
    // END FUNCTION: updateButtonStates
    // =================================================================================

    // =================================================================================
    // FUNCTION: launchOverlayServiceAndFinish
    // SUMMARY: Launches the OverlayService on the current display and finishes
    //          the activity. This is called when all permissions are granted.
    // =================================================================================



    private fun launchOverlayServiceAndFinish() {
        // 1. Create the Service Intent (Rename to 'serviceIntent' to avoid shadowing bug)
        val serviceIntent = Intent(this, OverlayService::class.java)
        
        // 2. Read from the Activity Intent (Use 'getIntent()' explicitly)
        val originIntent = getIntent()

        // [FIX] Forward the Display ID
        // We check 'originIntent' (from Launcher) and put into 'serviceIntent' (for Service)
        if (originIntent.hasExtra("displayId")) {
            val targetId = originIntent.getIntExtra("displayId", 0)
            serviceIntent.putExtra("displayId", targetId)
        }
        
        // Forward force_start flag
        if (originIntent.hasExtra("force_start")) {
             serviceIntent.putExtra("force_start", true)
        }

        // 3. Start Service
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
            startForegroundService(serviceIntent)
        } else {
            startService(serviceIntent)
        }

        // 4. Minimize to keep process alive
        moveTaskToBack(true)
        
        // 5. Finish after delay
        android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
            finish()
        }, 1500)
    }



    // =================================================================================
    // END FUNCTION: launchOverlayServiceAndFinish
    // =================================================================================

    // =================================================================================
    // FUNCTION: checkCriticalPermissions
    // SUMMARY: Returns true only if ALL required permissions are granted.
    //          Does NOT show toasts - used for silent checking.
    // =================================================================================
    private fun checkCriticalPermissions(): Boolean {
        // [Fixed] Removed Overlay Permission check. 
        // Since we use TYPE_ACCESSIBILITY_OVERLAY, the separate 'Appear on Top' permission is not strictly required.
        
        // 1. Accessibility
        if (!isAccessibilityEnabled()) {
            return false
        }

        // 2. Shizuku
        if (!isShizukuReady()) {
            return false
        }

        return true
    }
    // =================================================================================
    // END FUNCTION: checkCriticalPermissions
    // =================================================================================

    // =================================================================================
    // FUNCTION: showMissingPermissionsToast
    // SUMMARY: Shows a specific toast about which permission is missing.
    // =================================================================================
    private fun showMissingPermissionsToast() {
        when {
            !isAccessibilityEnabled() -> {
                Toast.makeText(this, "Missing: Accessibility Service", Toast.LENGTH_SHORT).show()
            }
            !isShizukuReady() -> {
                Toast.makeText(this, "Missing: Shizuku Permission", Toast.LENGTH_SHORT).show()
            }
            else -> {
                Toast.makeText(this, "All permissions granted!", Toast.LENGTH_SHORT).show()
            }
        }
    }
    // =================================================================================
    // END FUNCTION: showMissingPermissionsToast
    // =================================================================================

    // =================================================================================
    // FUNCTION: isAccessibilityEnabled
    // SUMMARY: Checks if our accessibility service is enabled in system settings.
    // =================================================================================
    private fun isAccessibilityEnabled(): Boolean {
        // [FIX] Read Settings.Secure directly. 
        // AccessibilityManager only lists *running* services. After a force-stop, 
        // the service is not running yet, so AM returns false. 
        // But the *Permission* is still granted in Settings, so we check that source of truth.
        return try {
            val expectedServiceName = "$packageName/.OverlayService"
            val enabledServices = Settings.Secure.getString(
                contentResolver,
                Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES
            ) ?: ""
            
            // Check if our service string exists in the setting
            val colonSplit = enabledServices.split(":")
            colonSplit.any { component ->
                component.equals(expectedServiceName, ignoreCase = true) || 
                component.contains("$packageName/")
            }
        } catch (e: Exception) {
            false
        }
    }
    // =================================================================================
    // END FUNCTION: isAccessibilityEnabled
    // =================================================================================
    
    // =================================================================================
    // FUNCTION: isShizukuReady
    // SUMMARY: Returns true if Shizuku is running and we have permission.
    // =================================================================================
    private fun isShizukuReady(): Boolean {
        return try {
            Shizuku.getBinder() != null && 
            Shizuku.checkSelfPermission() == PackageManager.PERMISSION_GRANTED
        } catch (e: Exception) {
            false
        }
    }
    // =================================================================================
    // END FUNCTION: isShizukuReady
    // =================================================================================
    
    // =================================================================================
    // HELPER FUNCTIONS: Open Settings Pages
    // =================================================================================
    private fun openAccessibilitySettings() {
        try {
            startActivity(Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS))
        } catch (e: Exception) {
            Toast.makeText(this, "Could not open Accessibility settings", Toast.LENGTH_SHORT).show()
        }
    }
    
    private fun openAppInfo() {
        try {
            val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
            intent.data = Uri.parse("package:$packageName")
            startActivity(intent)
            Toast.makeText(this, "Tap 3 dot hamburger menu for 'Allow Restricted Settings' at top right corner. If not visible, enable at next step and return here.", Toast.LENGTH_LONG).show()
        } catch (e: Exception) {
            Toast.makeText(this, "Could not open App Info", Toast.LENGTH_SHORT).show()
        }
    }
    
    private fun requestShizukuPermission() {
        try {
            if (Shizuku.getBinder() == null) {
                Toast.makeText(this, "Shizuku is not running. Please start Shizuku first.", Toast.LENGTH_LONG).show()
                return
            }
            if (Shizuku.checkSelfPermission() != PackageManager.PERMISSION_GRANTED) {
                Shizuku.requestPermission(0)
            } else {
                Toast.makeText(this, "Shizuku permission already granted", Toast.LENGTH_SHORT).show()
                updateButtonStates()
            }
        } catch (e: Exception) {
            Toast.makeText(this, "Error: ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }
    // =================================================================================
    // END HELPER FUNCTIONS
    // =================================================================================

    override fun onRequestPermissionResult(requestCode: Int, grantResult: Int) {
        if (grantResult == PackageManager.PERMISSION_GRANTED) {
            Toast.makeText(this, "Shizuku Granted!", Toast.LENGTH_SHORT).show()
            updateButtonStates()
            
            // Auto-launch if this was the last missing permission
            if (checkCriticalPermissions()) {
                launchOverlayServiceAndFinish()
            }
        } else {
            Toast.makeText(this, "Shizuku permission denied", Toast.LENGTH_SHORT).show()
        }
    }
    
    override fun onDestroy() {
        super.onDestroy()
        try {
            Shizuku.removeRequestPermissionResultListener(this)
        } catch (e: Exception) {}
    }
}

// =================================================================================
// END FILE: MainActivity.kt
// =================================================================================
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/NullInputMethodService.kt
```kotlin
package com.example.coverscreentester

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.inputmethodservice.InputMethodService
import android.os.Build
import android.os.SystemClock
import android.view.KeyEvent
import android.view.View
import android.view.inputmethod.InputConnection
import android.view.inputmethod.EditorInfo

// =================================================================================
// CLASS: NullInputMethodService
// SUMMARY: A "hollow" IME that displays nothing but maintains an InputConnection.
//          Receives commands via broadcast from the DroidOS keyboard overlay and
//          injects text/keys through the InputConnection for seamless text input.
//
//          This is necessary because overlay keyboards cannot directly access the
//          InputConnection of the focused app - only the active IME can do that.
//
//          FIXED: Now properly handles metaState for SHIFT, CTRL, ALT modifiers.
// =================================================================================
class NullInputMethodService : InputMethodService() {

    companion object {
        private const val TAG = "NullIME"
    }

    // =================================================================================
    // BROADCAST RECEIVER: Handles commands from OverlayService (DroidOS Keyboard)
    // SUMMARY: Processes INJECT_TEXT, INJECT_KEY, and INJECT_DELETE broadcasts.
    //          INJECT_KEY now properly handles metaState for shift/ctrl/alt support.
    // =================================================================================
    private val inputReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            val ic = currentInputConnection ?: return
            
            when (intent?.action) {
                // =====================================================================
                // ACTION: INJECT_TEXT
                // SUMMARY: Commits text directly to the input field.
                //          Used for normal character input and word completion.
                // =====================================================================
                "com.example.coverscreentester.INJECT_TEXT" -> {
                    val text = intent.getStringExtra("text")
                    if (!text.isNullOrEmpty()) {
                        ic.commitText(text, 1)
                    }
                }
                
                // =====================================================================
                // ACTION: INJECT_KEY (FIXED)
                // SUMMARY: Sends a key event with proper metaState support.
                //          This enables SHIFT (for uppercase/symbols), CTRL, and ALT.
                //
                //          Previously used sendDownUpKeyEvents() which ignores metaState.
                //          Now constructs full KeyEvent objects with metaState included.
                // =====================================================================
                "com.example.coverscreentester.INJECT_KEY" -> {
                    val code = intent.getIntExtra("keyCode", 0)
                    val metaState = intent.getIntExtra("metaState", 0)
                    
                    if (code > 0) {
                        sendKeyEventWithMeta(ic, code, metaState)
                    }
                }
                
                // =====================================================================
                // ACTION: INJECT_DELETE
                // SUMMARY: Deletes characters before the cursor.
                //          Used for backspace and bulk delete operations.
                // =====================================================================
                "com.example.coverscreentester.INJECT_DELETE" -> {
                    val length = intent.getIntExtra("length", 1)
                    if (length > 0) {
                        ic.deleteSurroundingText(length, 0)
                    }
                }
            }
        }
    }
    // =================================================================================
    // END BLOCK: Broadcast Receiver
    // =================================================================================

    // =================================================================================
    // FUNCTION: sendKeyEventWithMeta
    // SUMMARY: Sends DOWN and UP KeyEvents with proper metaState support.
    //          This is the fix for SHIFT/CTRL/ALT not working.
    //
    //          The standard sendDownUpKeyEvents() method doesn't accept metaState,
    //          so we construct the KeyEvents manually with all required fields.
    //
    // PARAMETERS:
    //   - ic: The InputConnection to send events through
    //   - keyCode: The Android keycode (e.g., KEYCODE_A, KEYCODE_1)
    //   - metaState: Modifier flags (META_SHIFT_ON, META_CTRL_ON, META_ALT_ON)
    // =================================================================================
    private fun sendKeyEventWithMeta(ic: InputConnection, keyCode: Int, metaState: Int) {
        val eventTime = SystemClock.uptimeMillis()
        
        // Construct KEY_DOWN event with metaState
        val downEvent = KeyEvent(
            eventTime,              // downTime
            eventTime,              // eventTime
            KeyEvent.ACTION_DOWN,   // action
            keyCode,                // keyCode
            0,                      // repeat count
            metaState,              // metaState - THE KEY FIX!
            0,                      // deviceId
            0,                      // scanCode
            KeyEvent.FLAG_SOFT_KEYBOARD or KeyEvent.FLAG_KEEP_TOUCH_MODE,  // flags
            android.view.InputDevice.SOURCE_KEYBOARD  // source
        )
        
        // Construct KEY_UP event with metaState
        val upEvent = KeyEvent(
            eventTime,              // downTime
            eventTime,              // eventTime
            KeyEvent.ACTION_UP,     // action
            keyCode,                // keyCode
            0,                      // repeat count
            metaState,              // metaState - THE KEY FIX!
            0,                      // deviceId
            0,                      // scanCode
            KeyEvent.FLAG_SOFT_KEYBOARD or KeyEvent.FLAG_KEEP_TOUCH_MODE,  // flags
            android.view.InputDevice.SOURCE_KEYBOARD  // source
        )
        
        // Send both events through the InputConnection
        ic.sendKeyEvent(downEvent)
        ic.sendKeyEvent(upEvent)
        
        // Debug logging (can be removed after confirming fix works)
        if (metaState != 0) {
            android.util.Log.d(TAG, "Sent key $keyCode with metaState=$metaState " +
                "(SHIFT=${metaState and KeyEvent.META_SHIFT_ON != 0}, " +
                "CTRL=${metaState and KeyEvent.META_CTRL_ON != 0}, " +
                "ALT=${metaState and KeyEvent.META_ALT_ON != 0})")
        }
    }
    // =================================================================================
    // END BLOCK: sendKeyEventWithMeta
    // =================================================================================

    override fun onCreate() {
        super.onCreate()
        android.util.Log.d(TAG, "NullInputMethodService created")
        
        // Register receiver for OverlayService communication
        val filter = IntentFilter().apply {
            addAction("com.example.coverscreentester.INJECT_TEXT")
            addAction("com.example.coverscreentester.INJECT_KEY")
            addAction("com.example.coverscreentester.INJECT_DELETE")
        }
        
        if (Build.VERSION.SDK_INT >= 33) { // TIRAMISU
            registerReceiver(inputReceiver, filter, Context.RECEIVER_NOT_EXPORTED)
        } else {
            registerReceiver(inputReceiver, filter)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        android.util.Log.d(TAG, "NullInputMethodService destroyed")
        try {
            unregisterReceiver(inputReceiver)
        } catch (e: Exception) {
            // Ignore if not registered
        }
    }

    // =================================================================================
    // FUNCTION: onCreateInputView
    // SUMMARY: Returns a zero-sized invisible view.
    //          The system requires an input view, but we don't want to show anything
    //          because the DroidOS overlay keyboard handles all visual display.
    // =================================================================================
    override fun onCreateInputView(): View {
        return View(this).apply {
            layoutParams = android.view.ViewGroup.LayoutParams(0, 0)
            visibility = View.GONE
        }
    }
    // =================================================================================
    // END BLOCK: onCreateInputView
    // =================================================================================
    
    override fun onCreateCandidatesView(): View? {
        return null // No suggestions - DroidOS keyboard handles this
    }

    // =================================================================================
    // FUNCTION: onEvaluateInputViewShown
    // SUMMARY: Returns true so the system maintains an active InputConnection.
    //          Without this, the InputConnection may not be available when we need it.
    // =================================================================================
    override fun onEvaluateInputViewShown(): Boolean {
        return true
    }
    // =================================================================================
    // END BLOCK: onEvaluateInputViewShown
    // =================================================================================
}

// =================================================================================
// END FILE: NullInputMethodService.kt
// =================================================================================
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/PredictionEngine.kt
```kotlin
package com.example.coverscreentester

import android.content.Context
import android.graphics.PointF
import java.util.ArrayList
import java.util.Locale
import kotlin.math.hypot
import kotlin.math.sqrt
import kotlin.math.max
import kotlin.math.min
import kotlin.math.ln
import kotlin.math.abs

// =================================================================================
// DATA CLASS: TimedPoint
// SUMMARY: A point with timestamp for dwell time analysis in swipe gestures.
//          Allows the prediction engine to detect when users linger on keys
//          to disambiguate similar words like "for" vs "four".
// =================================================================================
data class TimedPoint(
    val x: Float,
    val y: Float,
    val timestamp: Long  // System.currentTimeMillis() when this point was captured
) {
    fun toPointF(): android.graphics.PointF = android.graphics.PointF(x, y)
}
// =================================================================================
// END BLOCK: TimedPoint data class
// =================================================================================

// =================================================================================
// ENUM: PredictionSource
// SUMMARY: Identifies which algorithm produced a prediction result.
//          PRECISE = Current high-accuracy algorithm (good for slow swipes)
//          SHAPE_CONTEXT = Gboard-style normalized shape + language model (fast swipes)
// =================================================================================
enum class PredictionSource {
    PRECISE,
    SHAPE_CONTEXT
}
// =================================================================================
// END BLOCK: PredictionSource enum
// =================================================================================

// =================================================================================
// DATA CLASS: SwipeResult
// SUMMARY: Packages a prediction word with metadata about how it was generated.
//          - word: The predicted word
//          - source: Which algorithm produced this (PRECISE or SHAPE_CONTEXT)
//          - confidence: Score from 0.0 to 1.0 (higher = more confident)
//          - rawScore: The actual algorithm score (lower = better for our scoring)
// =================================================================================
data class SwipeResult(
    val word: String,
    val source: PredictionSource,
    val confidence: Float = 0.0f,
    val rawScore: Float = Float.MAX_VALUE
)
// =================================================================================
// END BLOCK: SwipeResult data class
// =================================================================================

/**
 * =================================================================================
 * CLASS: PredictionEngine
 * SUMMARY: Handles predictive text suggestions and swipe-to-type gesture decoding.
 *          Implements a SHARK2-inspired dual-channel algorithm with:
 *          1. Uniform path sampling (N points)
 *          2. Template generation for dictionary words
 *          3. Shape channel (scale-normalized pattern matching)
 *          4. Location channel (absolute position matching)
 *          5. Integration scoring with word frequency weighting
 *          
 * Based on: SHARK2 algorithm by Kristensson & Zhai (2004)
 * Reference: http://pokristensson.com/pubs/KristenssonZhaiUIST2004.pdf
 * =================================================================================
 */
class PredictionEngine {

    companion object {
        val instance = PredictionEngine()

        // Tuning Parameters
        private const val SAMPLE_POINTS = 64
        private const val NORMALIZATION_SIZE = 100f
        private const val SEARCH_RADIUS = 70f
        
        // Weights: 
        // Shape: 0.25 -> kept low to allow messy sizing
        // Location: 0.85 -> high trust in key hits
        // Direction: 0.5 -> kept low
        // Turn: 1.5 -> SIGNIFICANTLY INCREASED (was 0.9). Sharp corners are now king.
        // Dwell: 0.6 -> Weight for keys where user lingered longer
        private const val SHAPE_WEIGHT = 0.25f
        private const val DWELL_TIME_WEIGHT = 0.6f  // NEW: Weight for time-based key scoring
        private const val DWELL_THRESHOLD_MS = 80L  // Minimum ms to count as "lingering" on a key
        private const val LOCATION_WEIGHT = 0.85f
        private const val DIRECTION_WEIGHT = 0.5f   
        private const val TURN_WEIGHT = 1.5f        
        
        // Files
        private const val USER_STATS_FILE = "user_stats.json"
        private const val BLOCKED_DICT_FILE = "blocked_words.txt"
        private const val USER_DICT_FILE = "user_words.txt"
        private const val MIN_WORD_LENGTH = 2
        
        // (Moved to instance variable to allow Settings adjustment)

        // =================================================================================
        // SHAPE/CONTEXT ALGORITHM WEIGHTS (Gboard-style - inverted from Precise)
        // =================================================================================
        private const val SHAPE_CONTEXT_SHAPE_WEIGHT = 1.5f      // REDUCED: Allow more fuzziness (was 1.8)
        private const val SHAPE_CONTEXT_LOCATION_WEIGHT = 0.4f   // LOW: Position tolerance
        private const val SHAPE_CONTEXT_DIRECTION_WEIGHT = 0.6f  // Medium: Flow matters
        private const val SHAPE_CONTEXT_TURN_WEIGHT = 1.5f       // HIGH: Corners reliable
        private const val SHAPE_CONTEXT_START_PENALTY = 1.0f     // REDUCED: Forgive sloppy starts
        private const val SHAPE_CONTEXT_END_PENALTY = 0.8f       // REDUCED: Forgive overshoot (e.g. t->y)

    }

    // =================================================================================
    // END BLOCK: TUNING PARAMETERS
    // =================================================================================






    // ... (TrieNode class remains the same) ...

// HELPER: Consonant Anchoring
    private fun isVowel(c: Char): Boolean = "aeiouy".contains(c.lowercaseChar())

    // UPDATE: Add directionVectors and WEIGHTS
    data class WordTemplate(
        val word: String,
        val rank: Int,
        val rawPoints: List<PointF>,
        val rawWeights: List<Float>, // NEW: Consonant/Vowel weights
        var sampledPoints: List<PointF>? = null,
        var sampledWeights: List<Float>? = null, // NEW: Resampled weights
        var normalizedPoints: List<PointF>? = null,
        var directionVectors: List<PointF>? = null
    )




    // =================================================================================
    // DATA STRUCTURES
    // =================================================================================
    
    class TrieNode {
        val children = HashMap<Char, TrieNode>()
        var isEndOfWord = false
        var word: String? = null
        var rank: Int = Int.MAX_VALUE // 0 = Most Frequent
    }

    private val root = TrieNode()
    private val wordList = ArrayList<String>()

    // =================================================================================
    // SETTINGS: PREDICTION AGGRESSION
    // Controls the crossover point between Precise (Neat) and Shape (Sloppy) algorithms.
    // Lower (0.3) = Mostly Shape (Fast/Sloppy)
    // Higher (2.0) = Mostly Precise (Slow/Neat)
    // Default: 0.8f
    // =================================================================================
    var speedThreshold: Float = 0.8f


    private var lastKeyMap: Map<String, PointF>? = null
    // --- USER STATS ---
    private val USER_STATS_FILE = "user_stats.json"
    private val KEY_OFFSETS_FILE = "key_offsets.json" // NEW
    private val userFrequencyMap = HashMap<String, Int>()
    
    // SPATIAL LEARNING: Stores user's average offset (dx, dy) for each key
    private val keyOffsets = HashMap<String, PointF>()
    
        // BACKSPACE LEARNING: Map of <Word, ExpirationTimestamp>
    private val temporaryPenalties = java.util.concurrent.ConcurrentHashMap<String, Long>()
    private val PENALTY_DURATION_MS = 15_000L // Reduced to 15s safety net
    
    fun clearTemporaryPenalties() {
        if (temporaryPenalties.isNotEmpty()) {
            temporaryPenalties.clear()
            android.util.Log.d("DroidOS_Prediction", "Penalties cleared (new input detected)")
        }
    }

    fun penalizeWord(word: String) {
        val clean = word.trim().lowercase(java.util.Locale.ROOT)
        // Set expiration time
        temporaryPenalties[clean] = System.currentTimeMillis() + PENALTY_DURATION_MS
        android.util.Log.d("DroidOS_Prediction", "PENALIZED: '$clean' (Score x10 for 60s)")
    }
    private var lastSwipePath: List<TimedPoint>? = null // Cache last path to learn from

    
    // =================================================================================
    // OPTIMIZATION: Pre-indexed word lookup by first and last letter
    // SUMMARY: Instead of filtering all 10k words, we lookup by first letter then
    //          filter by last letter. This reduces candidate pool by ~96% immediately.
    // =================================================================================
    private val wordsByFirstLetter = HashMap<Char, ArrayList<String>>()
    private val wordsByFirstLastLetter = HashMap<String, ArrayList<String>>()
    // =================================================================================
    // END BLOCK: Pre-indexed word lookup
    // =================================================================================
    
    // Template cache - maps word to its template (lazy-computed per keyboard layout)
    private val templateCache = HashMap<String, WordTemplate>()
    private var lastKeyMapHash = 0  // Track if keyboard layout changed

    // --- CUSTOM DICTIONARY STORAGE ---
    private val blockedWords = java.util.HashSet<String>()
    private val customWords = java.util.HashSet<String>()
    // =================================================================================
    // CUSTOM WORD DISPLAY FORMS
    // SUMMARY: Maps lowercase lookup key to the display form with proper capitalization.
    //          E.g., "droidos" -> "DroidOS", "iphone" -> "iPhone"
    //          This allows swiping "droidos" to output "DroidOS".
    // =================================================================================
    private val customWordDisplayForms = HashMap<String, String>()
    // =================================================================================
    // END BLOCK: Custom word display forms
    // =================================================================================

    // =================================================================================
    // CONTEXT MODEL DATA STRUCTURES
    // SUMMARY: N-gram frequency maps for language model scoring.
    // =================================================================================
    private val bigramCounts = HashMap<String, HashMap<String, Int>>()
    private val unigramCounts = HashMap<String, Int>()
    private var lastContextWord: String? = null
    
    // =================================================================================
    // GRAMMAR ENGINE (Heuristic POS Tagger)
    // SUMMARY: Lightweight tagging for top ~120 structural words to apply grammar rules.
    // =================================================================================
enum class POSTag { NOUN, VERB, ADJECTIVE, PRONOUN, DETERMINER, PREPOSITION, CONJUNCTION, ADVERB, QUESTION, UNKNOWN }

    private val commonPosTags = hashMapOf(
        // DETERMINERS
        "the" to POSTag.DETERMINER, "a" to POSTag.DETERMINER, "an" to POSTag.DETERMINER, 
        "this" to POSTag.DETERMINER, "that" to POSTag.DETERMINER, "these" to POSTag.DETERMINER, 
        "those" to POSTag.DETERMINER, "my" to POSTag.DETERMINER, "your" to POSTag.DETERMINER, 
        "his" to POSTag.DETERMINER, "her" to POSTag.DETERMINER, "its" to POSTag.DETERMINER, 
        "our" to POSTag.DETERMINER, "their" to POSTag.DETERMINER, "all" to POSTag.DETERMINER,
        "some" to POSTag.DETERMINER, "any" to POSTag.DETERMINER, "no" to POSTag.DETERMINER,
        
        // PRONOUNS
        "i" to POSTag.PRONOUN, "you" to POSTag.PRONOUN, "he" to POSTag.PRONOUN, 
        "she" to POSTag.PRONOUN, "it" to POSTag.PRONOUN, "we" to POSTag.PRONOUN, 
        "they" to POSTag.PRONOUN, "me" to POSTag.PRONOUN, "him" to POSTag.PRONOUN,
        "her" to POSTag.PRONOUN, "us" to POSTag.PRONOUN, "them" to POSTag.PRONOUN,
        
        // VERBS (Auxiliary & Common Action)
        "is" to POSTag.VERB, "am" to POSTag.VERB, "are" to POSTag.VERB, 
        "was" to POSTag.VERB, "were" to POSTag.VERB, "be" to POSTag.VERB,
        "been" to POSTag.VERB, "being" to POSTag.VERB,
        "have" to POSTag.VERB, "has" to POSTag.VERB, "had" to POSTag.VERB,
        "do" to POSTag.VERB, "does" to POSTag.VERB, "did" to POSTag.VERB,
        "go" to POSTag.VERB, "going" to POSTag.VERB, "went" to POSTag.VERB, 
        "gone" to POSTag.VERB, "get" to POSTag.VERB, "got" to POSTag.VERB,
        "make" to POSTag.VERB, "know" to POSTag.VERB, "think" to POSTag.VERB, 
        "take" to POSTag.VERB, "see" to POSTag.VERB, "come" to POSTag.VERB, 
        "want" to POSTag.VERB, "look" to POSTag.VERB, "use" to POSTag.VERB,
        "find" to POSTag.VERB, "give" to POSTag.VERB, "tell" to POSTag.VERB,
        "say" to POSTag.VERB, "said" to POSTag.VERB,
        "run" to POSTag.VERB, "play" to POSTag.VERB, "walk" to POSTag.VERB, 
        "rub" to POSTag.VERB, "rib" to POSTag.VERB, // ADDED
        "shady" to POSTag.ADJECTIVE, // ADDED
        "call" to POSTag.VERB, "try" to POSTag.VERB, "need" to POSTag.VERB,
        "can" to POSTag.VERB, "could" to POSTag.VERB, "will" to POSTag.VERB,
        "would" to POSTag.VERB, "should" to POSTag.VERB, "may" to POSTag.VERB,
        "might" to POSTag.VERB, "must" to POSTag.VERB,
        
        // PREPOSITIONS
        "to" to POSTag.PREPOSITION, "of" to POSTag.PREPOSITION, "in" to POSTag.PREPOSITION,
        "for" to POSTag.PREPOSITION, "on" to POSTag.PREPOSITION, "with" to POSTag.PREPOSITION,
        "at" to POSTag.PREPOSITION, "from" to POSTag.PREPOSITION, "by" to POSTag.PREPOSITION,
        "about" to POSTag.PREPOSITION, "as" to POSTag.PREPOSITION, "into" to POSTag.PREPOSITION,
        "like" to POSTag.PREPOSITION, "through" to POSTag.PREPOSITION, "after" to POSTag.PREPOSITION,
        "over" to POSTag.PREPOSITION, "between" to POSTag.PREPOSITION, "out" to POSTag.PREPOSITION,
        "against" to POSTag.PREPOSITION, "during" to POSTag.PREPOSITION, "without" to POSTag.PREPOSITION,
        "before" to POSTag.PREPOSITION, "under" to POSTag.PREPOSITION, "around" to POSTag.PREPOSITION,
        "among" to POSTag.PREPOSITION,
        
        // CONJUNCTIONS
        "and" to POSTag.CONJUNCTION, "but" to POSTag.CONJUNCTION, "or" to POSTag.CONJUNCTION,
        "if" to POSTag.CONJUNCTION, "because" to POSTag.CONJUNCTION, "when" to POSTag.CONJUNCTION,
        "than" to POSTag.CONJUNCTION, "so" to POSTag.CONJUNCTION, "while" to POSTag.CONJUNCTION,
        "since" to POSTag.CONJUNCTION, "although" to POSTag.CONJUNCTION, "though" to POSTag.CONJUNCTION,
        
        // ADVERBS (High Frequency)
        "not" to POSTag.ADVERB, "now" to POSTag.ADVERB, "then" to POSTag.ADVERB,
        "just" to POSTag.ADVERB, "only" to POSTag.ADVERB, "also" to POSTag.ADVERB,
        "very" to POSTag.ADVERB, "here" to POSTag.ADVERB, "there" to POSTag.ADVERB,
        "well" to POSTag.ADVERB, "even" to POSTag.ADVERB, "still" to POSTag.ADVERB,
        "never" to POSTag.ADVERB, "always" to POSTag.ADVERB, "back" to POSTag.ADVERB,
        
        // QUESTION WORDS
        "what" to POSTag.QUESTION, "who" to POSTag.QUESTION, "where" to POSTag.QUESTION,
        "why" to POSTag.QUESTION, "how" to POSTag.QUESTION, "which" to POSTag.QUESTION
    )
    // =================================================================================
    // END BLOCK: Context model data structures
    // =================================================================================
    // Cache for the top 1000 words to make "Hail Mary" pass instant
    private val commonWordsCache = ArrayList<String>()
    // Throttle template failure logging
    private var lastTemplateMissLog = 0L
    
    // =================================================================================
    // END DATA STRUCTURES
    // =================================================================================



    init {
        loadDefaults()
    }



    private fun loadDefaults() {
        val commonWords = listOf(
            "the", "be", "to", "of", "and", "a", "in", "that", "have", "i",
            "it", "for", "not", "on", "with", "he", "as", "you", "do", "at",
            "this", "but", "his", "by", "from", "they", "we", "say", "her",
            "she", "or", "an", "will", "my", "one", "all", "would", "there",
            "their", "what", "so", "up", "out", "if", "about", "who", "get",
            "which", "go", "me", "when", "make", "can", "like", "time", "no",
            "just", "him", "know", "take", "people", "into", "year", "your",
            "good", "some", "could", "them", "see", "other", "than", "then",
            "now", "look", "only", "come", "its", "over", "think", "also",
            "back", "after", "use", "two", "how", "our", "work", "first",
            "well", "way", "even", "new", "want", "because", "any", "these",
            "give", "day", "most", "us", "is", "was", "are", "been", "has",
            "more", "or", "had", "did", "said", "each", "she", "may", "find",
            "long", "down", "did", "get", "made", "live", "back", "little",
            "only", "round", "man", "year", "came", "show", "every", "good",
            "great", "help", "through", "much", "before", "line", "right", 
            "too", "old", "mean", "same", "tell", "boy", "follow", "very",
            "just", "why", "ask", "went", "men", "read", "need", "land",
            "here", "home", "big", "high", "such", "again", "turn", "hand",
            "run", "store", "what", "where", "how", "off", "play", "end", // Added missing words            "play", "small", "end", "put", "while", "next", "sound", "below",
            // Common mobile/tech words
            "swipe", "keyboard", "trackpad", "android", "phone", "text", "type",
            "hello", "yes", "no", "ok", "okay", "thanks", "please", "sorry",
            "love", "like", "cool", "nice", "awesome", "great", "good", "bad"
        )
        for ((index, word) in commonWords.withIndex()) {
            insert(word, index)
        }
    }


// =================================================================================
    // USER STATS & PRIORITY LOGIC
    // =================================================================================
    
    private fun loadUserStats(context: Context) {
        try {
            val file = java.io.File(context.filesDir, USER_STATS_FILE)
            if (file.exists()) {
                val content = file.readText()
                // Simple parsing: "word":count
                content.replace("{", "").replace("}", "").split(",").forEach {
                    val parts = it.split(":")
                    if (parts.size == 2) {
                        val w = parts[0].trim().replace("\"", "")
                        val c = parts[1].trim().toIntOrNull() ?: 0
                        userFrequencyMap[w] = c
                    }
                }
                android.util.Log.d("DroidOS_Prediction", "Loaded stats for ${userFrequencyMap.size} words")
            }
        } catch (e: Exception) {
            android.util.Log.e("DroidOS_Prediction", "Failed to load user stats", e)
        }
    }

    private fun saveUserStats(context: Context) {
        Thread {
            try {
                val sb = StringBuilder("{")
                synchronized(userFrequencyMap) {
                    var first = true
                    for ((k, v) in userFrequencyMap) {
                        if (!first) sb.append(",")
                        sb.append("\"$k\":$v")
                        first = false
                    }
                }
                sb.append("}")
                val file = java.io.File(context.filesDir, USER_STATS_FILE)
                file.writeText(sb.toString())
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }.start()
    }

    /**
     * Call this when the user clicks a word in the suggestion bar.
     * Boosts the word's priority for future predictions.
     */

/**
     * Call this when the user clicks a word in the suggestion bar.
     * Boosts the word's priority for future predictions.
     * NOTE: This no longer auto-learns new words. Use learnWord() for that.
     */


    fun recordSelection(context: Context, word: String) {
        // android.util.Log.d("DroidOS_Debug", "SELECT: recordSelection called for '$word'")
        if (word.isBlank()) return
        val clean = word.lowercase(Locale.ROOT)
        
        synchronized(userFrequencyMap) {
            val count = userFrequencyMap.getOrDefault(clean, 0)
            userFrequencyMap[clean] = count + 1
        }

        // NEW: Spatial Learning
        // If we have the swipe path that generated this word, learn the offsets.
        if (lastSwipePath != null) {
             // android.util.Log.d("DroidOS_Heatmap", "LEARN: Learning triggered for '$clean'. Path points: ${lastSwipePath!!.size}")
             learnKeyOffsets(context, clean, lastSwipePath!!)
             lastSwipePath = null // Consumed
        } else {
             // android.util.Log.d("DroidOS_Debug", "FAIL: lastSwipePath was NULL when selecting '$clean'")
        }
        
        saveUserStats(context)
    }



    fun loadDictionary(context: Context) {
        Thread {
            try {
                loadUserStats(context)
                loadKeyOffsets(context)
                val start = System.currentTimeMillis()
                val newRoot = TrieNode()
                val newWordList = ArrayList<String>()
                val newBlocked = java.util.HashSet<String>()
                val newCustom = java.util.HashSet<String>()
                var lineCount = 0


                val newWordsByFirstLetter = HashMap<Char, ArrayList<String>>()
                val newWordsByFirstLastLetter = HashMap<String, ArrayList<String>>()
                // FIX: Declare here so it is accessible in the commit block
                val newDisplayForms = HashMap<String, String>()


                // =================================================================================
                // LOAD CUSTOM LISTS (User & Blocked)
                // SUMMARY: Loads user's custom words and blocked words from persistent storage.
                // =================================================================================
                try {
                    val blockFile = java.io.File(context.filesDir, BLOCKED_DICT_FILE)
                    if (blockFile.exists()) {
                        val blockedLines = blockFile.readLines().map { it.trim().lowercase(java.util.Locale.ROOT) }.filter { it.isNotEmpty() }
                        newBlocked.addAll(blockedLines)
                        android.util.Log.d("DroidOS_Prediction", "LOAD: Blocked words file found, ${blockedLines.size} words")
                    } else {
                        android.util.Log.d("DroidOS_Prediction", "LOAD: No blocked words file exists yet")
                    }

                    val userFile = java.io.File(context.filesDir, USER_DICT_FILE)
                    if (userFile.exists()) {
                        val userLines = userFile.readLines().map { it.trim() }.filter { it.isNotEmpty() }
                        
                        // FILTER: Check each user word against garbage filter on load
                        // Also build display forms map
                        for (originalForm in userLines) {
                            val lookupForm = originalForm.lowercase(java.util.Locale.ROOT)
                            val trieKey = lookupForm.replace("'", "")
                            
                            if (!looksLikeGarbage(trieKey)) {
                                newCustom.add(lookupForm)
                                // Store display form mapping
                                newDisplayForms[lookupForm] = originalForm
                                newDisplayForms[trieKey] = originalForm
                            } else {
                                android.util.Log.d("DroidOS_Prediction", "Pruned garbage from user dict: $originalForm")
                            }
                        }
                        android.util.Log.d("DroidOS_Prediction", "LOAD: User words file found, ${newCustom.size} valid words")
                    } else {
                        android.util.Log.d("DroidOS_Prediction", "LOAD: No user words file exists yet")
                    }
                } catch (e: Exception) {
                    android.util.Log.e("DroidOS_Prediction", "Failed to load user lists", e)
                }

                // 2. Load Main Dictionary (Assets) - Filtering Blocked words
                try {
                    context.assets.open("dictionary.txt").bufferedReader().useLines { lines ->
                        lines.forEachIndexed { index, line ->
                            val word = line.trim().lowercase(java.util.Locale.ROOT)
                            // SKIP if blocked
                            if (!newBlocked.contains(word) && word.isNotEmpty() && word.all { it.isLetter() } && word.length >= MIN_WORD_LENGTH) {
                                newWordList.add(word)
                                lineCount++

                                var current = newRoot
                                for (char in word) {
                                    current = current.children.computeIfAbsent(char) { TrieNode() }
                                }
                                current.isEndOfWord = true
                                current.word = word
                                if (index < current.rank) current.rank = index

                                if (word.length >= 2) {
                                    val firstChar = word.first()
                                    newWordsByFirstLetter.getOrPut(firstChar) { ArrayList() }.add(word)
                                    val key = "${word.first()}${word.last()}"
                                    newWordsByFirstLastLetter.getOrPut(key) { ArrayList() }.add(word)
                                }
                            }
                        }
                    }
                } catch (e: Exception) {
                    android.util.Log.e("DroidOS_Prediction", "Dictionary asset load failed: ${e.message}")
                }

                // 3. Merge Custom Words
                for (word in newCustom) {
                    if (!newWordList.contains(word)) {
                        newWordList.add(word)
                        var current = newRoot
                        for (char in word) {
                            current = current.children.computeIfAbsent(char) { TrieNode() }
                        }
                        current.isEndOfWord = true
                        current.word = word
                        current.rank = 0 // High priority

                        if (word.length >= 2) {
                            val firstChar = word.first()
                            newWordsByFirstLetter.getOrPut(firstChar) { ArrayList() }.add(word)
                            val key = "${word.first()}${word.last()}"
                            newWordsByFirstLastLetter.getOrPut(key) { ArrayList() }.add(word)
                        }
                    }
                }

                // 4. Merge Hardcoded Defaults
                val existingDefaults = synchronized(this) { ArrayList(wordList) }
                for (defaultWord in existingDefaults) {
                    val lower = defaultWord.lowercase(java.util.Locale.ROOT)
                    if (!newBlocked.contains(lower) && !newWordList.contains(lower)) {
                        newWordList.add(lower)
                        var current = newRoot
                        for (char in lower) {
                            current = current.children.computeIfAbsent(char) { TrieNode() }
                        }
                        current.isEndOfWord = true
                        current.word = lower
                        if (current.rank > 100) current.rank = 50
                    }
                }

                // 5. Commit Changes
                synchronized(this) {
                    wordList.clear()
                    wordList.addAll(newWordList)
                    root.children.clear()
                    root.children.putAll(newRoot.children)

                    wordsByFirstLetter.clear()
                    wordsByFirstLetter.putAll(newWordsByFirstLetter)
                    wordsByFirstLastLetter.clear()
                    wordsByFirstLastLetter.putAll(newWordsByFirstLastLetter)

                    blockedWords.clear()
                    blockedWords.addAll(newBlocked)
                    customWords.clear()
                    customWords.addAll(newCustom)
                    
                    // Load display forms
                    customWordDisplayForms.clear()
                    customWordDisplayForms.putAll(newDisplayForms)
                    customWords.addAll(newCustom)

                    templateCache.clear()

                    // Populate Common Words Cache (Top 1000)
                    commonWordsCache.clear()
                    commonWordsCache.addAll(
                        wordList.sortedBy { getWordRank(it) }.take(1000)
                    )
                }
                // =================================================================================
                // OPTIMIZATION: Pre-warm template cache for common words
                // SUMMARY: Pre-compute templates for top 500 words to eliminate lag on first swipe.
                //          This runs in background so doesn't block UI.
                // =================================================================================
                // Note: Templates require keyMap which we don't have here.
                // Templates will be created on first use, but the word indexes are ready.
                // =================================================================================
                android.util.Log.d("DroidOS_Prediction", "Dictionary Loaded: $lineCount asset + ${newCustom.size} user words + ${newBlocked.size} blocked. Common Cache: ${commonWordsCache.size}")

            } catch (e: Exception) {
                e.printStackTrace()
            }
        }.start()
    }




// =================================================================================
    // FUNCTION: learnWord
    // SUMMARY: Learns a new word and saves to user_words.txt
    //          
    // SMART CAPITALIZATION:
    //   - If at sentence start: strip first-letter cap, keep internal caps
    //     E.g., "DroidOS" at start  stored as "droidOS" 
    //   - If mid-sentence: keep all caps as typed
    //     E.g., "DroidOS" mid-sentence  stored as "DroidOS"
    //   - When suggesting, always use the stored display form
    //
    // @param isSentenceStart: true if word was typed at beginning of sentence
    // =================================================================================
    fun learnWord(context: Context, word: String, isSentenceStart: Boolean = false) {
        if (word.length < 2) return

        val originalWord = word.trim()
        
        // =======================================================================
        // SMART CAPITALIZATION
        // If at sentence start, the first letter being capital is automatic,
        // so we should store without that automatic cap to get the "true" form.
        // E.g., User types "DroidOS" at start  they want "droidOS" normally
        // But if typed mid-sentence as "DroidOS"  they want "DroidOS" always
        // =======================================================================
        val displayForm = if (isSentenceStart && originalWord.isNotEmpty() && originalWord[0].isUpperCase()) {
            // Strip the automatic sentence-start capitalization
            originalWord[0].lowercaseChar() + originalWord.substring(1)
        } else {
            // Keep as-is (mid-sentence or already lowercase)
            originalWord
        }
        // =======================================================================
        // END BLOCK: Smart capitalization
        // =======================================================================
        
        val lookupWord = displayForm.lowercase(java.util.Locale.ROOT)
        val trieKey = lookupWord.replace("'", "")  // For trie lookup

        // Don't learn garbage
        if (looksLikeGarbage(trieKey)) {
             android.util.Log.d("DroidOS_Prediction", "Ignored garbage input: $originalWord")
             return
        }

        // Don't relearn if already known (but allow updating display form)
        val alreadyKnown = hasWord(trieKey) || hasWord(lookupWord)
        
        Thread {
            try {
                synchronized(this) {
                    customWords.add(lookupWord)
                    blockedWords.remove(lookupWord)
                    blockedWords.remove(trieKey)
                    
                    // Store the display form for this word
                    customWordDisplayForms[lookupWord] = displayForm
                    customWordDisplayForms[trieKey] = displayForm
                    
                    // Insert base form (without apostrophe) for swipe matching
                    if (!alreadyKnown) {
                        insert(trieKey, 0)
                        
                        // Also insert with apostrophe if present
                        if (lookupWord.contains("'")) {
                            insert(lookupWord, 0)
                        }
                    }

                    // FIX: File I/O moved INSIDE synchronized block to prevent race conditions
                    val file = java.io.File(context.filesDir, USER_DICT_FILE)
                    
                    // If already known, we need to update the file (remove old, add new)
                    if (alreadyKnown) {
                        val existingLines = if (file.exists()) file.readLines() else emptyList()
                        val updatedLines = existingLines.filter { 
                            it.trim().lowercase(java.util.Locale.ROOT).replace("'", "") != trieKey 
                        } + displayForm
                        file.writeText(updatedLines.joinToString("\n") + "\n")
                        android.util.Log.d("DroidOS_Prediction", "Updated word: '$displayForm' (was in dict, updated display form)")
                    } else {
                        file.appendText("$displayForm\n")
                        android.util.Log.d("DroidOS_Prediction", "Learned word: '$displayForm' (lookup: '$trieKey', sentenceStart=$isSentenceStart)")
                    }

                    // Safe to call here (it uses synchronized data)
                    saveSetToFile(context, BLOCKED_DICT_FILE, blockedWords)
                }

            } catch (e: Exception) {
                e.printStackTrace()
            }
        }.start()
    }
    // =================================================================================
    // END BLOCK: learnWord with smart capitalization
    // =================================================================================

// =================================================================================
    // FUNCTION: getDisplayForm
    // SUMMARY: Returns the proper display form for a custom word.
    //          E.g., "droidos" -> "DroidOS", "iphone" -> "iPhone"
    //          Returns the input unchanged if not a custom word.
    // =================================================================================
    fun getDisplayForm(word: String): String {
        val lookup = word.lowercase(java.util.Locale.ROOT)
        val lookupNoApostrophe = lookup.replace("'", "")
        
        return customWordDisplayForms[lookup] 
            ?: customWordDisplayForms[lookupNoApostrophe]
            ?: word
    }
    // =================================================================================
    // END BLOCK: getDisplayForm
    // =================================================================================

    // =================================================================================
    // FUNCTION: saveSetToFile
    // SUMMARY: Saves a set of words to a file in the app's private storage.
    // =================================================================================
    private fun saveSetToFile(context: Context, filename: String, data: Set<String>) {
        try {
            val file = java.io.File(context.filesDir, filename)
            // FIX: Append newline to prevent next write from merging with last word (e.g. can'twon't)
            val content = data.filter { it.isNotEmpty() }.joinToString("\n") + "\n"
            file.writeText(content)
            android.util.Log.d("DroidOS_Prediction", "SAVEFILE: Wrote ${data.size} items to $filename")
        } catch (e: Exception) {
            android.util.Log.e("DroidOS_Prediction", "SAVEFILE FAILED: $filename - ${e.message}", e)
        }
    }
    // =================================================================================
    // END BLOCK: saveSetToFile
    // =================================================================================

    // =================================================================================
    // FILTER: GARBAGE DETECTION
    // Rule: Must have at least one vowel/y OR be in the whitelist.
    // =================================================================================
    private val VALID_VOWELLESS = setOf(
        "hmm", "shh", "psst", "brr", "pfft", "nth", "src", "jpg", "png", "gif",
        "txt", "xml", "pdf", "css", "html", "tv", "pc", "ok", "id", "cv", "ad", "ex", "vs", "mr", "dr", "ms"
    )

    // =================================================================================
    // FUNCTION: looksLikeGarbage
    // SUMMARY: Filters random letter combinations. Must have vowel or be whitelisted.
    // UPDATED: Strips apostrophes before checking (don't -> dont has vowel)
    // =================================================================================
    private fun looksLikeGarbage(word: String): Boolean {
        val checkWord = word.replace("'", "")
        if (checkWord.length > 1) {
            val hasVowel = checkWord.any { "aeiouyAEIOUY".contains(it) }
            if (!hasVowel) {
                if (VALID_VOWELLESS.contains(checkWord.lowercase(java.util.Locale.ROOT))) return false
                return true
            }
        }
        return false
    }
    // =================================================================================
    // END BLOCK: looksLikeGarbage
    // =================================================================================

    fun hasWord(word: String): Boolean {
        return wordList.contains(word.lowercase(Locale.ROOT))
    }

    // =================================================================================
    // FUNCTION: isWordBlocked
    // SUMMARY: Checks if a word is in the blocked list.
    // =================================================================================
    fun isWordBlocked(word: String): Boolean {
        return blockedWords.contains(word.lowercase(Locale.ROOT))
    }
// =================================================================================
    // END BLOCK: isWordBlocked
    // =================================================================================

    // =================================================================================
    // FUNCTION: isCustomWord
    // SUMMARY: Checks if a word is in the user's custom dictionary.
    //          Used to style user-added words differently (italic) in prediction bar.
    // =================================================================================
    fun isCustomWord(word: String): Boolean {
        val lower = word.lowercase(Locale.ROOT)
        val withoutApostrophe = lower.replace("'", "")
        return customWords.contains(lower) || customWords.contains(withoutApostrophe)
    }
    // =================================================================================
    // END BLOCK: isCustomWord
    // =================================================================================    // =================================================================================
    // FUNCTION: insert
    // SUMMARY: Inserts a word into the Trie and the first/last letter index.
    // =================================================================================
    fun insert(word: String, rank: Int) {
        val lower = word.lowercase(Locale.ROOT)
        if (lower.length < 2) return  // Skip single-letter words
        
        var node = root
        for (c in lower) {
            node = node.children.getOrPut(c) { TrieNode() }
        }
        node.isEndOfWord = true
        node.word = lower
        node.rank = rank
        
        // OPTIMIZATION: Add to first-letter index
        val firstChar = lower.first()
        wordsByFirstLetter.getOrPut(firstChar) { ArrayList() }.add(lower)
        
        // OPTIMIZATION: Add to first+last letter index for fast lookup
        val key = "${lower.first()}${lower.last()}"
        wordsByFirstLastLetter.getOrPut(key) { ArrayList() }.add(lower)
    }
    // =================================================================================
    // END BLOCK: insert
    // =================================================================================

    /**
     * Returns a list of suggested words for the given prefix, sorted by popularity.
     */
    // =================================================================================
    // FUNCTION: getSuggestions
    // SUMMARY: Returns suggested words for a given prefix, sorted by popularity.
    //          Filters out blocked words to prevent them from appearing in suggestions.

// =================================================================================
    // FUNCTION: getSuggestions (Updated for Priority Sort)
    // =================================================================================


    fun getSuggestions(prefix: String, maxResults: Int = 3): List<String> {
        if (prefix.isEmpty()) return emptyList()
        val cleanPrefix = prefix.lowercase(java.util.Locale.ROOT)

        var current = root
        for (char in cleanPrefix) {
            current = current.children[char] ?: return emptyList()
        }

        val candidates = ArrayList<Pair<String, Int>>()
        collectCandidates(current, candidates)
        
        val sortedCandidates = candidates.sortedWith(Comparator { a, b ->
            val wordA = a.first
            val wordB = b.first
            
            val countA = userFrequencyMap[wordA] ?: 0
            val countB = userFrequencyMap[wordB] ?: 0
            
            if (countA != countB) return@Comparator countB - countA
            val rankA = a.second
            val rankB = b.second
            if (rankA != rankB) return@Comparator rankA - rankB
            wordA.length - wordB.length
        })

        return sortedCandidates
            .filter { !blockedWords.contains(it.first.lowercase(java.util.Locale.ROOT)) }
            .distinctBy { it.first }
            .take(maxResults)
            .map { it.first }
    }



    // =================================================================================
    // FUNCTION: collectCandidates
    // SUMMARY: Recursively collects word candidates from trie nodes.
    //          Skips blocked words during traversal for efficiency.
    // =================================================================================
    private fun collectCandidates(node: TrieNode, results: MutableList<Pair<String, Int>>) {
        if (node.isEndOfWord) {
            node.word?.let { word ->
                // Skip blocked words
                if (!blockedWords.contains(word)) {
                    results.add(word to node.rank)
                }
            }
        }
        for (child in node.children.values) {
            collectCandidates(child, results)
        }
    }
    // =================================================================================
    // END BLOCK: collectCandidates
    // =================================================================================

    // =================================================================================
    // SHARK2-INSPIRED SWIPE DECODER LOGIC
    // =================================================================================
    
    /**
     * Main entry point for decoding a swipe gesture into word candidates.
     * Implements SHARK2-style dual-channel matching with:
     * 1. Path sampling to uniform N points
     * 2. Candidate pruning by start/end keys
     * 3. Shape channel scoring (normalized patterns)
     * 4. Location channel scoring (absolute positions)  
     * 5. Integration with frequency weighting
     */
    // =================================================================================
    // FUNCTION: decodeSwipe (Adaptive Length + Robust Neighbors)
    // =================================================================================
// =================================================================================
    // FUNCTION: decodeSwipe (v6 - Turn-Aware Scoring)
    // SUMMARY: Based on original working version with:
    //          - NEW turn detection for shortcut, android, circle
    //          - Conservative dwell for as/ass, to/too
    //          - Original candidate collection and length filtering
    // =================================================================================
    fun decodeSwipe(swipePath: List<PointF>, keyMap: Map<String, PointF>): List<String> {
        if (swipePath.size < 3 || keyMap.isEmpty()) return emptyList()
        if (wordList.isEmpty()) {
            loadDefaults()
            return emptyList()
        }

        val keyMapHash = keyMap.hashCode()
        if (keyMapHash != lastKeyMapHash) {
            templateCache.clear()
            lastKeyMapHash = keyMapHash
        }

        val inputLength = getPathLength(swipePath)
        if (inputLength < 10f) return emptyList()

        // =======================================================================
        // DWELL DETECTION (Conservative - for to/too, as/ass)
        // =======================================================================
        var dwellScore = 0f
        if (swipePath.size > 12) {
            val tailSize = maxOf(12, swipePath.size / 4)
            val tailStart = maxOf(0, swipePath.size - tailSize)
            val tail = swipePath.subList(tailStart, swipePath.size)
            
            var tailLength = 0f
            for (i in 1 until tail.size) {
                tailLength += hypot(tail[i].x - tail[i-1].x, tail[i].y - tail[i-1].y)
            }
            
            val avgMovementPerPoint = tailLength / tail.size
            dwellScore = when {
                avgMovementPerPoint < 2f -> 1.0f
                avgMovementPerPoint < 4f -> 0.6f
                avgMovementPerPoint < 7f -> 0.2f
                else -> 0f
            }
        }
        val isDwellingAtEnd = dwellScore >= 0.6f
        // =======================================================================
        // END DWELL DETECTION
        // =======================================================================

        val sampledInput = samplePath(swipePath, SAMPLE_POINTS)
        val normalizedInput = normalizePath(sampledInput)
        val inputDirections = calculateDirectionVectors(sampledInput)

        // NEW: Calculate turn points for input
        val inputTurns = detectTurns(inputDirections)

        // NEW: Extract sequence of keys the path passes through
        // This is CRITICAL for distinguishing "awake" vs "awesome"

        val pathKeys = extractPathKeys(sampledInput, keyMap, 8)

        val startPoint = sampledInput.first()
        val endPoint = sampledInput.last()

        // FIX: Define startKey and endKey (Missing in previous build)
        val startKey = findClosestKey(startPoint, keyMap)
        val endKey = findClosestKey(endPoint, keyMap)
        
// =======================================================================
        // CANDIDATE COLLECTION (Enhanced with Path Key Matching)
        // SUMMARY: Collects candidates using:
        //          1. Start/End neighbor search (original)
        //          2. PREFIX INJECTION (original)  
        //          3. PATH KEY INJECTION - NEW: Add words containing detected path keys
        //             This ensures "awake" is included when path shows aw...
        //          4. User History (original)
        // =======================================================================
        val candidates = HashSet<String>()
        
        // 1. Neighbor Search (original)
        val nearbyStart = findNearbyKeys(startPoint, keyMap, 80f)
        val nearbyEnd = findNearbyKeys(endPoint, keyMap, 80f)
        
        for (s in nearbyStart) {
            for (e in nearbyEnd) {
                wordsByFirstLastLetter["${s}${e}"]?.let { candidates.addAll(it) }
            }
        }
        
        // 2. PREFIX INJECTION (original)
        if (startKey != null) {
            wordsByFirstLetter[startKey.first()]?.let { words ->
                candidates.addAll(words.sortedByDescending { userFrequencyMap[it] ?: 0 }.take(25))
            }
        }

                // 3. PATH KEY INJECTION (Enhanced)

                // If path shows specific intermediate keys, add words that contain those keys.

                // We increased limits (30->150) to ensure "awake" isn't pushed out by common words.

                if (pathKeys.size >= 2) {

                    val secondKey = pathKeys.getOrNull(1)?.firstOrNull()?.lowercaseChar()

                    if (secondKey != null && startKey != null) {

                        wordsByFirstLetter[startKey.first()]?.let { words ->

                            val matchingWords = words.filter { word ->

                                word.length >= 2 && word.drop(1).contains(secondKey)

                            }.sortedByDescending { userFrequencyMap[it] ?: 0 }.take(150) // Increased from 30

                            candidates.addAll(matchingWords)

                        }

                    }

        

                    // Also check third key if present

                    val thirdKey = pathKeys.getOrNull(2)?.firstOrNull()?.lowercaseChar()

                    if (thirdKey != null && startKey != null && thirdKey != secondKey) {

                        wordsByFirstLetter[startKey.first()]?.let { words ->

                            val matchingWords = words.filter { word ->

                                word.length >= 3 && word.drop(1).contains(thirdKey)

                            }.sortedByDescending { userFrequencyMap[it] ?: 0 }.take(150) // Increased from 20

                            candidates.addAll(matchingWords)

                        }

                    }

                    

                    // 3.5 STRICT SEQUENCE MATCH (New)

                    // If we have a complex path (e.g. a->w->a->e), specifically look for words

                    // that contain ALL these keys in relative order.

                    if (pathKeys.size >= 3 && startKey != null) {

                        wordsByFirstLetter[startKey.first()]?.let { words ->

                            // Get all intermediate keys (excluding start)

                            val requiredKeys = pathKeys.drop(1).map { it.firstOrNull()?.lowercaseChar() }.filterNotNull()

                            

                            val strictMatches = words.filter { word ->

                                var lastIdx = 0

                                var matches = true

                                for (rk in requiredKeys) {

                                    val idx = word.indexOf(rk, lastIdx)

                                    if (idx == -1) { 

                                        matches = false; break 

                                    }

                                    lastIdx = idx + 1

                                }

                                matches

                            }.take(50) // Force include these specific matches

                            

                            if (strictMatches.isNotEmpty()) {

                                candidates.addAll(strictMatches)

                                android.util.Log.d("DroidOS_PathKeys", "Strict Match found: ${strictMatches.take(5)}")

                            }

                        }

                    }

                }

        

                // 4. User History (original)

                synchronized(userFrequencyMap) {

                    candidates.addAll(userFrequencyMap.entries

                        .sortedByDescending { it.value }

                        .take(30) // Increased from 15

                        .map { it.key })

                }

        

                // Debug: Log total candidates

                android.util.Log.d("DroidOS_PathKeys", "Total candidates: ${candidates.size}")

        

                // =======================================================================

                // END CANDIDATE COLLECTION

                // =======================================================================

        

                // --- SCORING ---

                val scored = candidates

                    .filter { !isWordBlocked(it) && it.length >= MIN_WORD_LENGTH }

                    .sortedWith(compareByDescending<String> { userFrequencyMap[it] ?: 0 }.thenBy { getWordRank(it) })

                    .take(400) // Increased from 150 to prevent dropping valid low-frequency words

                    .mapNotNull { word ->
                val template = getOrCreateTemplate(word, keyMap) ?: return@mapNotNull null
                
                // --- ADAPTIVE LENGTH FILTER (Original) ---
                val tLen = getPathLength(template.rawPoints)
                val ratio = tLen / inputLength
                
                val maxRatio = if (inputLength < 150f) 1.5f else 5.0f
                if (ratio > maxRatio || ratio < 0.4f) return@mapNotNull null

                
                if (template.sampledPoints == null || template.normalizedPoints == null || template.directionVectors == null) {
                    template.sampledPoints = samplePath(template.rawPoints, SAMPLE_POINTS)
                    template.normalizedPoints = normalizePath(template.sampledPoints!!)
                    template.directionVectors = calculateDirectionVectors(template.sampledPoints!!)
                }
                
                val shapeScore = calculateShapeScore(normalizedInput, template.normalizedPoints!!)
                val locScore = calculateLocationScore(sampledInput, template.sampledPoints!!)
                val dirScore = calculateDirectionScore(inputDirections, template.directionVectors!!)

                // NEW: Turn matching score
                val templateTurns = detectTurns(template.directionVectors!!)
                val turnScore = calculateTurnScore(inputTurns, templateTurns)

                // NEW: Path key matching score - penalizes words where path doesn't match
                // This distinguishes "awake" (path goes through w) from "awesome" (path would need s)
                val pathKeyScore = calculatePathKeyScore(pathKeys, word)

                val integrationScore = (shapeScore * SHAPE_WEIGHT) +
                                       (locScore * LOCATION_WEIGHT) +
                                       (dirScore * DIRECTION_WEIGHT) +
                                       (turnScore * TURN_WEIGHT) +
                                       (pathKeyScore * 0.8f)  // NEW: Path key matching weight
                

                // --- BOOSTS (Original) ---
                val rank = template.rank
                val freqBonus = 1.0f / (1.0f + 0.15f * ln((rank + 1).toFloat()))
                
                // CHANGED: Reset user history boost to neutral (1.0f). 
                // This stops user-added words (like "texting") from overriding better geometric matches (like "testing").
                var userBoost = 1.0f
                
                // DOUBLE LETTER BOOST (Conservative - only 3+ letter words)
                val hasEndDouble = word.length >= 3 && 
                    word.last().lowercaseChar() == word[word.length - 2].lowercaseChar()
                
                if (hasEndDouble && isDwellingAtEnd) {
                    userBoost *= (1.10f + dwellScore * 0.15f)
                }
                
                // EXACT KEY MATCH BONUS
                if (startKey != null && word.startsWith(startKey, ignoreCase = true)) userBoost *= 1.15f
                if (endKey != null && word.endsWith(endKey, ignoreCase = true)) userBoost *= 1.15f
                
                // LONG WORD BONUS
                if (word.length >= 6) userBoost *= 1.15f



                val finalScore = (integrationScore * (1.0f - 0.5f * freqBonus)) / userBoost
                Pair(word, finalScore)
            }
        
        // FIX: Apply getDisplayForm to ensure capitalized words (e.g. Katsuya) are returned correctly
        val results = scored.sortedBy { it.second }.distinctBy { it.first }.take(3).map { it.first }
        return results.map { getDisplayForm(it) }
    }

    // =================================================================================
    // END BLOCK: Boost Calculation (and decodeSwipe)
    // =================================================================================

    // =================================================================================
    // FUNCTION: decodeSwipeTimed (Time-Weighted Swipe Decoding)
    // SUMMARY: Enhanced version of decodeSwipe that uses timestamp data to detect
    //          when users linger on specific keys. This allows disambiguation of
    //          similar words like "for" vs "four" - lingering on "u" boosts "four".
    //          
    // HOW IT WORKS:
    //   1. Converts TimedPoints to regular path for geometric analysis
    //   2. Calculates dwell time on each key the path crosses
    //   3. Keys with longer dwell times get boosted in scoring
    //   4. Final score combines geometric + frequency + dwell time weights
    // =================================================================================

    // =================================================================================
    // FUNCTION: decodeSwipeTimed (PHASE 2 - Returns Dual Results)
    // SUMMARY: Now returns SwipeResult list from the dual algorithm.
    //          The winning algorithm is selected based on swipe speed.
    //          Source info is used for color-coding in the UI.
    // =================================================================================
    fun decodeSwipeTimed(timedPath: List<TimedPoint>, keyMap: Map<String, PointF>): List<SwipeResult> {
        if (timedPath.size < 3 || keyMap.isEmpty()) return emptyList()
        
        // Use the dual decoder which runs both algorithms and picks winner
        return decodeSwipeDual(timedPath, keyMap)
    }
    // =================================================================================
    // END BLOCK: decodeSwipeTimed
    // =================================================================================

    // =================================================================================
    // FUNCTION: calculateKeyDwellTimes
    // SUMMARY: Analyzes a timed swipe path to calculate how long the user spent
    //          near each key. Returns a map of key -> total milliseconds.
    //          Used to boost keys where user intentionally lingered.
    // =================================================================================
    private fun calculateKeyDwellTimes(
        timedPath: List<TimedPoint>, 
        keyMap: Map<String, PointF>
    ): Map<String, Long> {
        val dwellTimes = HashMap<String, Long>()
        if (timedPath.size < 2) return dwellTimes
        
        val KEY_PROXIMITY_RADIUS = 50f  // Pixels - consider "on key" if within this radius
        
        for (i in 1 until timedPath.size) {
            val prev = timedPath[i - 1]
            val curr = timedPath[i]
            val timeDelta = curr.timestamp - prev.timestamp
            
            // Skip if timestamp jump is too large (likely a pause/resume)
            if (timeDelta > 500) continue
            
            // Find which key this point is closest to
            val point = PointF(curr.x, curr.y)
            var closestKey: String? = null
            var closestDist = Float.MAX_VALUE
            
            for ((key, center) in keyMap) {
                val dist = hypot(point.x - center.x, point.y - center.y)
                if (dist < closestDist && dist < KEY_PROXIMITY_RADIUS) {
                    closestDist = dist
                    closestKey = key
                }
            }
            
            // Add time spent near this key
            if (closestKey != null) {
                dwellTimes[closestKey] = (dwellTimes[closestKey] ?: 0L) + timeDelta
            }
        }
        
        return dwellTimes
    }
    // =================================================================================
    // END BLOCK: calculateKeyDwellTimes
    // =================================================================================

    // =================================================================================
    // FUNCTION: decodeSwipeWithDwell
    // SUMMARY: Modified version of decodeSwipe that incorporates dwell time scoring.
    //          Words containing keys with high dwell times get boosted.
    //          This is the core logic that makes "lingering on U" select "four" over "for".
    // =================================================================================
    private fun decodeSwipeWithDwell(
        swipePath: List<PointF>, 
        keyMap: Map<String, PointF>,
        keyDwellTimes: Map<String, Long>
    ): List<String> {
        if (swipePath.size < 3 || keyMap.isEmpty()) return emptyList()
        if (wordList.isEmpty()) {
            loadDefaults()
            return emptyList()
        }

        val keyMapHash = keyMap.hashCode()
        if (keyMapHash != lastKeyMapHash) {
            templateCache.clear()
            lastKeyMapHash = keyMapHash
        }

        val inputLength = getPathLength(swipePath)
        if (inputLength < 10f) return emptyList()

        // =======================================================================
        // DWELL DETECTION (Conservative - for to/too, as/ass)
        // =======================================================================
        var dwellScore = 0f
        if (swipePath.size > 12) {
            val tailSize = maxOf(12, swipePath.size / 4)
            val tailStart = maxOf(0, swipePath.size - tailSize)
            val tail = swipePath.subList(tailStart, swipePath.size)
            
            var tailLength = 0f
            for (i in 1 until tail.size) {
                tailLength += hypot(tail[i].x - tail[i-1].x, tail[i].y - tail[i-1].y)
            }
            
            val avgMovementPerPoint = tailLength / tail.size
            dwellScore = when {
                avgMovementPerPoint < 2f -> 1.0f
                avgMovementPerPoint < 4f -> 0.6f
                avgMovementPerPoint < 7f -> 0.2f
                else -> 0f
            }
        }
        val isDwellingAtEnd = dwellScore >= 0.6f
        // =======================================================================
        // END DWELL DETECTION
        // =======================================================================

        val sampledInput = samplePath(swipePath, SAMPLE_POINTS)
        if (sampledInput.isEmpty()) return emptyList()
        
        val normalizedInput = normalizePath(sampledInput)
        if (normalizedInput.isEmpty()) return emptyList()
        
        val inputDirections = calculateDirectionVectors(sampledInput)
        if (inputDirections.isEmpty()) return emptyList()

        val inputTurns = detectTurns(inputDirections)
        val pathKeys = extractPathKeys(sampledInput, keyMap, 8)

        val startPoint = sampledInput.first()
        val endPoint = sampledInput.last()
        val startKey = findClosestKey(startPoint, keyMap)
        val endKey = findClosestKey(endPoint, keyMap)
        
        // =======================================================================
        // CANDIDATE COLLECTION (same as original)
        // =======================================================================
        val candidates = HashSet<String>()
        
        val nearbyStart = findNearbyKeys(startPoint, keyMap, 80f)
        val nearbyEnd = findNearbyKeys(endPoint, keyMap, 80f)
        
        for (s in nearbyStart) {
            for (e in nearbyEnd) {
                wordsByFirstLastLetter["${s}${e}"]?.let { candidates.addAll(it) }
            }
        }
        
        if (startKey != null) {
            wordsByFirstLetter[startKey.first()]?.let { words ->
                candidates.addAll(words.sortedByDescending { userFrequencyMap[it] ?: 0 }.take(25))
            }
        }

        if (pathKeys.size >= 2) {
            val secondKey = pathKeys.getOrNull(1)?.firstOrNull()?.lowercaseChar()
            if (secondKey != null && startKey != null) {
                wordsByFirstLetter[startKey.first()]?.let { words ->
                    val matchingWords = words.filter { word ->
                        word.length >= 2 && word.drop(1).contains(secondKey)
                    }.sortedByDescending { userFrequencyMap[it] ?: 0 }.take(150)
                    candidates.addAll(matchingWords)
                }
            }
            
            val thirdKey = pathKeys.getOrNull(2)?.firstOrNull()?.lowercaseChar()
            if (thirdKey != null && startKey != null && thirdKey != secondKey) {
                wordsByFirstLetter[startKey.first()]?.let { words ->
                    val matchingWords = words.filter { word ->
                        word.length >= 3 && word.drop(1).contains(thirdKey)
                    }.sortedByDescending { userFrequencyMap[it] ?: 0 }.take(150)
                    candidates.addAll(matchingWords)
                }
            }
            
            if (pathKeys.size >= 3 && startKey != null) {
                wordsByFirstLetter[startKey.first()]?.let { words ->
                    val requiredKeys = pathKeys.drop(1).map { it.firstOrNull()?.lowercaseChar() }.filterNotNull()
                    val strictMatches = words.filter { word ->
                        var lastIdx = 0
                        var matches = true
                        for (rk in requiredKeys) {
                            val idx = word.indexOf(rk, lastIdx)
                            if (idx == -1) { 
                                matches = false; break 
                            }
                            lastIdx = idx + 1
                        }
                        matches
                    }.take(50)
                    
                    if (strictMatches.isNotEmpty()) {
                        candidates.addAll(strictMatches)
                    }
                }
            }
        }

        synchronized(userFrequencyMap) {
            candidates.addAll(userFrequencyMap.entries
                .sortedByDescending { it.value }
                .take(30)
                .map { it.key })
        }
        // =======================================================================
        // END CANDIDATE COLLECTION
        // =======================================================================

        // =======================================================================
        // SCORING WITH DWELL TIME BOOST
        // =======================================================================
        val scored = candidates
            .filter { !isWordBlocked(it) && it.length >= MIN_WORD_LENGTH }
            .sortedWith(compareByDescending<String> { userFrequencyMap[it] ?: 0 }.thenBy { getWordRank(it) })
            .take(400)
            .mapNotNull { word ->
                val template = getOrCreateTemplate(word, keyMap) ?: return@mapNotNull null
                
                val tLen = getPathLength(template.rawPoints)
                val ratio = tLen / inputLength
                
                val maxRatio = if (inputLength < 150f) 1.5f else 5.0f
                if (ratio > maxRatio || ratio < 0.4f) return@mapNotNull null

                // FIX: Check ALL cached properties, not just sampledPoints
                // Old cache entries may have sampledPoints but not directionVectors
                if (template.sampledPoints == null || template.normalizedPoints == null || template.directionVectors == null || template.sampledWeights == null) {
                    // Use new sampler that handles weights
                    val (pts, wts) = sampleTemplate(template.rawPoints, template.rawWeights, SAMPLE_POINTS)
                    template.sampledPoints = pts
                    template.sampledWeights = wts
                    
                    template.normalizedPoints = normalizePath(template.sampledPoints!!)
                    template.directionVectors = calculateDirectionVectors(template.sampledPoints!!)
                }
                
                // These are now guaranteed to be non-null
                val shapeScore = calculateShapeScore(normalizedInput, template.normalizedPoints!!)
                // Pass weights to location scorer
                val locScore = calculateLocationScore(sampledInput, template.sampledPoints!!, template.sampledWeights)
                val dirScore = calculateDirectionScore(inputDirections, template.directionVectors!!)


                val templateTurns = detectTurns(template.directionVectors!!)
                val turnScore = calculateTurnScore(inputTurns, templateTurns)

                // NEW: Path key matching score - penalizes words where path doesn't match
                // This distinguishes "awake" (path goes through w) from "awesome" (path would need s)
                val pathKeyScore = calculatePathKeyScore(pathKeys, word)

                // =======================================================================
                // NEW: DWELL TIME SCORING
                // Calculate how much the user's dwell times match this word's letters.
                // If user lingered on "U", words containing "U" get boosted.
                // =======================================================================
                val dwellBoost = calculateDwellBoost(word, keyDwellTimes)
                
                // =======================================================================
                // NEW: CONTEXT & GRAMMAR BOOST (Ported from Shape Algorithm)
                // Applies n-gram and POS tagging logic to the precise algorithm
                // =======================================================================
                val nGramBoost = getContextBoost(word)
                val grammarBoost = getGrammarBoost(word)
                val totalContextBoost = (nGramBoost * grammarBoost).coerceAtMost(2.5f)
                
                // =======================================================================
                // END DWELL & CONTEXT
                // =======================================================================

                val integrationScore = (shapeScore * SHAPE_WEIGHT) +

                                       (locScore * LOCATION_WEIGHT) +
                                       (dirScore * DIRECTION_WEIGHT) +
                                       (turnScore * TURN_WEIGHT) +
                                       (pathKeyScore * 0.8f)
                
                val rank = template.rank
                val freqBonus = 1.0f / (1.0f + 0.15f * ln((rank + 1).toFloat()))
                
                var userBoost = 1.0f
                
                val hasEndDouble = word.length >= 3 && 
                    word.last().lowercaseChar() == word[word.length - 2].lowercaseChar()
                
                if (hasEndDouble && isDwellingAtEnd) {
                    userBoost *= (1.10f + dwellScore * 0.15f)
                }
                
                if (startKey != null && word.startsWith(startKey, ignoreCase = true)) userBoost *= 1.15f
                if (endKey != null && word.endsWith(endKey, ignoreCase = true)) userBoost *= 1.15f
                if (word.length >= 6) userBoost *= 1.15f

                // =======================================================================
                // APOSTROPHE VARIANT BOOST
                // If user has a custom word with apostrophe (don't) and we're matching
                // the base form (dont), boost the apostrophe version significantly.
                // This makes swiping "dont" return "don't" if learned.
                // =======================================================================
                val wordWithApostrophe = findApostropheVariant(word)
                if (wordWithApostrophe != null) {
                    userBoost *= 1.5f  // Strong boost for apostrophe variants
                    android.util.Log.d("DroidOS_Apostrophe", "Boosting '$word' -> '$wordWithApostrophe'")
                }
                // =======================================================================
                // END BLOCK: APOSTROPHE VARIANT BOOST
                // =======================================================================

                // Apply Context Boost
                userBoost *= totalContextBoost

                // Apply dwell boost - words matching user's lingered keys score better
                userBoost *= dwellBoost

                var finalScore = (integrationScore * (1.0f - 0.5f * freqBonus)) / userBoost

                // APPLY PENALTY
                val penaltyEnd = temporaryPenalties[word] ?: 0L
                if (System.currentTimeMillis() < penaltyEnd) {
                    finalScore *= 10.0f // Massive penalty to push it to bottom
                }

                Pair(word, finalScore)
            }
        
        // =======================================================================
        // POST-PROCESS: Apply display forms and apostrophe variants
        // =======================================================================
        val results = scored.sortedBy { it.second }.distinctBy { it.first }.take(3).map { it.first }
        
        return results.map { word ->
            val apostropheVariant = findApostropheVariant(word)
            val base = apostropheVariant ?: word
            // FIX: Apply display form to ensure proper capitalization (Katsuya, iPhone, etc.)
            getDisplayForm(base)
        }
    }

    // =================================================================================
    // END BLOCK: decodeSwipeWithDwell
    // =================================================================================

    // =================================================================================
    // FUNCTION: calculateDwellBoost
    // SUMMARY: Calculates a boost factor for a word based on how well it matches
    //          the user's key dwell times. Words containing keys the user lingered
    //          on get a higher boost (lower score = better in this system, so we
    //          return values > 1.0 to boost, < 1.0 to penalize).
    //          
    // EXAMPLE: User types "for" path but lingers on "U" for 150ms
    //          - "for" has no U -> dwellBoost = 1.0 (neutral)
    //          - "four" has U -> dwellBoost = 1.2 (boosted, wins!)
    // =================================================================================
    private fun calculateDwellBoost(word: String, keyDwellTimes: Map<String, Long>): Float {
        if (keyDwellTimes.isEmpty()) return 1.0f
        
        var boost = 1.0f
        val wordLower = word.lowercase()
        
        // Find keys with significant dwell time
        val significantDwells = keyDwellTimes.filter { it.value > DWELL_THRESHOLD_MS }
        
        for ((key, dwellMs) in significantDwells) {
            val keyChar = key.lowercase().firstOrNull() ?: continue
            
            // Calculate boost based on dwell time
            // 100ms = small boost (1.05), 200ms = medium (1.15), 300ms+ = strong (1.25)
            val dwellFactor = when {
                dwellMs > 300 -> 1.25f
                dwellMs > 200 -> 1.15f
                dwellMs > 150 -> 1.10f
                dwellMs > 100 -> 1.05f
                else -> 1.02f
            }
            
            if (wordLower.contains(keyChar)) {
                // Word contains this lingered-on key - BOOST it
                boost *= dwellFactor
                android.util.Log.d("DroidOS_Dwell", "BOOST '$word': contains '$keyChar' (${dwellMs}ms) -> boost $dwellFactor")
            } else {
                // Word does NOT contain this lingered-on key - slight penalty
                // This helps "four" beat "for" when user lingered on "u"
                val penalty = 1.0f / (dwellFactor * 0.5f + 0.5f)  // Gentler penalty
                boost *= penalty
                android.util.Log.d("DroidOS_Dwell", "PENALTY '$word': missing '$keyChar' (${dwellMs}ms) -> penalty $penalty")
            }
        }
        
        return boost.coerceIn(0.5f, 2.0f)  // Clamp to reasonable range
    }
    // =================================================================================
    // END BLOCK: calculateDwellBoost
    // =================================================================================

    // =================================================================================
    // FUNCTION: findApostropheVariant
    // SUMMARY: Checks if a user-learned word with apostrophe exists for this base word.
    //          E.g., "dont" -> "don't", "wont" -> "won't", "im" -> "i'm"
    //          Returns the apostrophe variant if found in customWords, null otherwise.
    // =================================================================================
    private fun findApostropheVariant(baseWord: String): String? {
        val lower = baseWord.lowercase(java.util.Locale.ROOT)
        
        // Common contraction patterns
        val patterns = listOf(
            // n't contractions
            Pair("nt$", "n't"),      // dont -> don't, wont -> won't, cant -> can't
            // 'm contractions  
            Pair("^im$", "i'm"),     // im -> i'm
            // 'll contractions
            Pair("ll$", "'ll"),      // well could match, so be careful
            // 're contractions
            Pair("re$", "'re"),      // youre -> you're, were -> we're
            // 've contractions
            Pair("ve$", "'ve"),      // wouldve -> would've
            // 's contractions
            Pair("s$", "'s"),        // its -> it's, thats -> that's
        )
        
        // Check common contractions first
        for ((pattern, replacement) in patterns) {
            val regex = Regex(pattern)
            if (regex.containsMatchIn(lower)) {
                val variant = lower.replace(regex, replacement)
                if (customWords.contains(variant)) {
                    return variant
                }
            }
        }
        
        // Also check if any custom word without apostrophe matches this word
        for (customWord in customWords) {
            if (customWord.contains("'")) {
                val withoutApostrophe = customWord.replace("'", "")
                if (withoutApostrophe == lower) {
                    return customWord
                }
            }
        }
        
        return null
    }
    // =================================================================================
    // END BLOCK: calculateDwellBoost
    // =================================================================================

    // =================================================================================
    // FUNCTION: decodeSwipePreview (FAST - for live updates)
    // SUMMARY: Lightweight version of decodeSwipe for real-time preview during swiping.
    //          Uses fewer candidates and simpler scoring for speed.
    //          Returns top 3 predictions based on current path (may be incomplete).
    // =================================================================================
    fun decodeSwipePreview(swipePath: List<PointF>, keyMap: Map<String, PointF>): List<String> {
        if (swipePath.size < 5 || keyMap.isEmpty()) return emptyList()
        if (wordList.isEmpty()) return emptyList()

        val keyMapHash = keyMap.hashCode()
        if (keyMapHash != lastKeyMapHash) {
            templateCache.clear()
            lastKeyMapHash = keyMapHash
        }

        val inputLength = getPathLength(swipePath)
        if (inputLength < 20f) return emptyList()

        val sampledInput = samplePath(swipePath, SAMPLE_POINTS)
        val inputDirections = calculateDirectionVectors(sampledInput)

        val startPoint = sampledInput.first()
        val endPoint = sampledInput.last()

        val startKey = findClosestKey(startPoint, keyMap)
        val endKey = findClosestKey(endPoint, keyMap)

        // Extract path keys for intermediate matching (fewer samples for speed)
        val pathKeys = extractPathKeys(sampledInput, keyMap, 6)

        // DEBUG: Log path keys for live preview
        if (pathKeys.isNotEmpty()) {
            android.util.Log.d("DroidOS_Preview", "PREVIEW Keys: ${pathKeys.joinToString("")}")
        }

        // FAST CANDIDATE COLLECTION - fewer candidates for speed
        val candidates = HashSet<String>()

        // 1. Neighbor Search (smaller radius for speed)
        val nearbyStart = findNearbyKeys(startPoint, keyMap, 60f)
        val nearbyEnd = findNearbyKeys(endPoint, keyMap, 60f)

        for (s in nearbyStart) {
            for (e in nearbyEnd) {
                wordsByFirstLastLetter["${s}${e}"]?.let { candidates.addAll(it) }
            }
        }

        // 2. PREFIX INJECTION (fewer candidates)
        if (startKey != null) {
            wordsByFirstLetter[startKey.first()]?.let { words ->
                candidates.addAll(words.sortedByDescending { userFrequencyMap[it] ?: 0 }.take(15))
            }
        }
        if (pathKeys.size >= 2) {
            val secondKey = pathKeys.getOrNull(1)?.firstOrNull()?.lowercaseChar()
            if (secondKey != null && startKey != null) {
                wordsByFirstLetter[startKey.first()]?.let { words ->
                    val matchingWords = words.filter { word ->
                        word.length >= 2 && word.drop(1).contains(secondKey)
                    }.sortedByDescending { userFrequencyMap[it] ?: 0 }.take(20)
                    candidates.addAll(matchingWords)
                }
            }
        }
        // FAST SCORING - simplified for speed
        val scored = candidates
            .filter { !isWordBlocked(it) && it.length >= MIN_WORD_LENGTH }
            .sortedWith(compareByDescending<String> { userFrequencyMap[it] ?: 0 }.thenBy { getWordRank(it) })
            .take(50)  // Fewer candidates for speed
            .mapNotNull { word ->
                val template = getOrCreateTemplate(word, keyMap) ?: return@mapNotNull null

                // Quick length filter
                val tLen = getPathLength(template.rawPoints)
                val ratio = tLen / inputLength
                if (ratio > 3.0f || ratio < 0.3f) return@mapNotNull null


                if (template.sampledPoints == null || template.normalizedPoints == null || template.directionVectors == null) {

                    template.sampledPoints = samplePath(template.rawPoints, SAMPLE_POINTS)
                    template.normalizedPoints = normalizePath(template.sampledPoints!!)
                    template.directionVectors = calculateDirectionVectors(template.sampledPoints!!)
                }

                // SIMPLIFIED SCORING - location, direction, and path key matching for speed
                val locScore = calculateLocationScore(sampledInput, template.sampledPoints!!)
                val dirScore = calculateDirectionScore(inputDirections, template.directionVectors!!)

                // Add path key score for better intermediate key matching
                val pathKeyScore = calculatePathKeyScore(pathKeys, word)

                val integrationScore = locScore * 0.4f + dirScore * 0.2f + pathKeyScore * 0.6f  // Path keys most important for preview

                // Basic boosts
                val rank = template.rank
                val freqBonus = 1.0f / (1.0f + 0.1f * ln((rank + 1).toFloat()))

                var boost = 1.0f
                if (startKey != null && word.startsWith(startKey, ignoreCase = true)) boost *= 1.2f
                if (endKey != null && word.endsWith(endKey, ignoreCase = true)) boost *= 1.2f
                if ((userFrequencyMap[word] ?: 0) > 0) boost *= 1.3f

                val finalScore = (integrationScore * (1.0f - 0.3f * freqBonus)) / boost
                Pair(word, finalScore)
            }

// =======================================================================
        // POST-PROCESS: Apply display forms and apostrophe variants
        // 1. First check for apostrophe variant (cant -> can't)
        // 2. Then apply display form for proper capitalization (droidos -> DroidOS)
        // =======================================================================
        val results = scored.sortedBy { it.second }.distinctBy { it.first }.take(3).map { it.first }
        
        return results.map { word ->
            val withApostrophe = findApostropheVariant(word)
            val baseWord = withApostrophe ?: word
            // Apply display form for custom words (preserves DroidOS, iPhone, etc.)
            getDisplayForm(baseWord)
        }
        // =======================================================================
        // END BLOCK: Display form application
        // =======================================================================
    }
    // =================================================================================
    // END BLOCK: decodeSwipeWithDwellPreview
    // =================================================================================    // =================================================================================
    // FUNCTION: findClosestKey
    // SUMMARY: Finds the single closest key to a point. Fast O(n) where n = key count.
    // =================================================================================
    private fun findClosestKey(point: PointF, keyMap: Map<String, PointF>): String? {
        var closestKey: String? = null
        var closestDist = Float.MAX_VALUE
        
        for ((key, pos) in keyMap) {
            if (key.length != 1 || !Character.isLetter(key[0])) continue
            val dist = hypot(point.x - pos.x, point.y - pos.y)
            if (dist < closestDist) {
                closestDist = dist
                closestKey = key
            }
        }
        return closestKey
    }
    // =================================================================================
    // END BLOCK: findClosestKey
    // =================================================================================

    // =================================================================================
    // FUNCTION: findNearbyKeys
    // SUMMARY: Finds all letter keys within a radius of a point.
    // =================================================================================
    private fun findNearbyKeys(point: PointF, keyMap: Map<String, PointF>, radius: Float): List<String> {
        return keyMap.entries
            .filter { (key, pos) -> 
                key.length == 1 && Character.isLetter(key[0]) &&
                hypot(point.x - pos.x, point.y - pos.y) <= radius
            }
            .map { it.key }
    }
    // =================================================================================
    // END BLOCK: findNearbyKeys
    // =================================================================================



    // =================================================================================
    // FUNCTION: extractPathKeys (v4 - Sharp Turns Only, No Sampling)
    // SUMMARY: Extracts ONLY the key waypoints: Start, Sharp Turns, and End.
    //          Does NOT sample intermediate points (which creates noise).
    //          A sharp turn is where direction changes significantly (dot < 0.4).
    //          This prevents picking up 's' when swiping diagonally from 'a' to 'k'.
    //
    //          Example: "awake" swipe path has sharp turns at w, a, k
    //          Result: awake (not awaske)
    // =================================================================================
    private fun extractPathKeys(path: List<PointF>, keyMap: Map<String, PointF>, maxKeys: Int): List<String> {
        if (path.size < 3) return emptyList()

        val keys = ArrayList<String>()

        // 1. Always add Start Key
        val startKey = findClosestKey(path.first(), keyMap)
        if (startKey != null) {
            keys.add(startKey.lowercase())
        }

        // 2. Find ONLY sharp turns (significant direction changes)
        // Use a larger window (5 points) to avoid noise from jitter
        val windowSize = 5
        var lastTurnIdx = 0

        for (i in windowSize until path.size - windowSize) {
            // Vector from 5 points ago to current point
            val p1 = path[i - windowSize]
            val p2 = path[i]
            val p3 = path[i + windowSize]

            val v1x = p2.x - p1.x
            val v1y = p2.y - p1.y
            val v2x = p3.x - p2.x
            val v2y = p3.y - p2.y

            val len1 = kotlin.math.hypot(v1x, v1y)
            val len2 = kotlin.math.hypot(v2x, v2y)

            // Need significant movement to count as a direction
            if (len1 > 15f && len2 > 15f) {
                val dot = (v1x * v2x + v1y * v2y) / (len1 * len2)

                                    // SHARP turn only: dot < 0.6 means angle > ~53 degrees
                                    // Relaxed from 0.4 to catch 'k' in 'awake' and 'x' in 'expect'
                                    if (dot < 0.6f) {
                                        // Minimum distance from last turn to avoid duplicates
                                        if (i - lastTurnIdx > windowSize * 2) {                        val key = findClosestKey(p2, keyMap)?.lowercase()
                        if (key != null && (keys.isEmpty() || keys.last() != key)) {
                            keys.add(key)
                            lastTurnIdx = i
                        }
                    }
                }
            }
        }

        // 3. Always add End Key
        val endKey = findClosestKey(path.last(), keyMap)?.lowercase()
        if (endKey != null && (keys.isEmpty() || keys.last() != endKey)) {
            keys.add(endKey)
        }

        // DEBUG: Log extracted keys
        android.util.Log.d("DroidOS_PathKeys", "Extracted: ${keys.joinToString("")} from ${path.size} pts (Sharp turns only)")

        return keys.take(maxKeys)
    }
    // =================================================================================
    // END BLOCK: extractPathKeys
    // =================================================================================


    // =================================================================================
    // FUNCTION: calculatePathKeyScore (v6 - Fuzzy Neighbor Matching)
    // SUMMARY: Penalizes words that don't match path keys.
    //          UPDATED: Now uses areKeysAdjacent() to forgive "fat finger" errors.
    //          e.g. Path has 'g', Word has 'h' -> Match (because g-h are neighbors)
    // =================================================================================
    private fun calculatePathKeyScore(pathKeys: List<String>, word: String): Float {
        if (pathKeys.isEmpty()) return 0f
        
        val wordChars = word.lowercase()
        var penalty = 0f
        
        // CRITICAL: Check if the FIRST path keys match the FIRST word letters
        val firstPathKey = pathKeys.firstOrNull()?.firstOrNull()
        val firstWordChar = wordChars.firstOrNull()
        
        if (firstPathKey != null && firstWordChar != null && firstPathKey != firstWordChar) {
            // First key mismatch - Check adjacency (Fuzzy Match)
            if (areKeysAdjacent(firstPathKey, firstWordChar)) {
                 penalty += 1.0f // Mild penalty for neighbor start
            } else {
                 penalty += 5.0f // Big penalty for wrong start
            }
        }
        
        // Check SECOND path key
        if (pathKeys.size >= 2 && wordChars.length >= 2) {
            val secondPathKey = pathKeys[1].firstOrNull()
            val secondWordChar = wordChars[1]
            
            if (secondPathKey != null && secondPathKey != secondWordChar) {
                // Fuzzy check for second key
                if (areKeysAdjacent(secondPathKey, secondWordChar)) {
                    penalty += 0.5f 
                } else {
                    penalty += 4.0f
                }
            }
        }
        
        // Check THIRD path key
        if (pathKeys.size >= 3 && wordChars.length >= 3) {
            val thirdPathKey = pathKeys[2].firstOrNull()
            val thirdWordChar = wordChars[2]
            
            if (thirdPathKey != null && thirdWordChar != null && thirdPathKey != thirdWordChar) {
                if (areKeysAdjacent(thirdPathKey, thirdWordChar)) {
                    penalty += 0.2f
                } else {
                    penalty += 2.0f
                }
            }
        }
        
        // Subsequence matching (rest of the path)
        var pathIdx = 0
        var wordIdx = 0
        var matchedKeys = 0
        
        while (pathIdx < pathKeys.size && wordIdx < wordChars.length) {
            val pKey = pathKeys[pathIdx].firstOrNull() ?: continue
            val wChar = wordChars[wordIdx]
            
            if (pKey == wChar) {
                matchedKeys++
                pathIdx++
                wordIdx++
            } else {
                wordIdx++
            }
        }
        
        // Penalty for unmatched path keys
        val unmatchedKeys = pathKeys.size - matchedKeys
        penalty += unmatchedKeys * 2.0f 
        
        // Length penalty
        if (wordChars.length > pathKeys.size * 2.5) {
            penalty += 0.5f
        }
        
        return penalty
    }

    // =================================================================================
    // FUNCTION: areKeysAdjacent
    // SUMMARY: Checks if two keys are adjacent on a QWERTY keyboard.
    //          Used for typo tolerance - adjacent mismatches are less severe.
    // =================================================================================
    private fun areKeysAdjacent(key1: Char, key2: Char): Boolean {
        val adjacencyMap = mapOf(
            'q' to setOf('w', 'a'),
            'w' to setOf('q', 'e', 'a', 's'),
            'e' to setOf('w', 'r', 's', 'd'),
            'r' to setOf('e', 't', 'd', 'f'),
            't' to setOf('r', 'y', 'f', 'g'),
            'y' to setOf('t', 'u', 'g', 'h'),
            'u' to setOf('y', 'i', 'h', 'j'),
            'i' to setOf('u', 'o', 'j', 'k'),
            'o' to setOf('i', 'p', 'k', 'l'),
            'p' to setOf('o', 'l'),
            'a' to setOf('q', 'w', 's', 'z'),
            's' to setOf('a', 'w', 'e', 'd', 'z', 'x'),
            'd' to setOf('s', 'e', 'r', 'f', 'x', 'c'),
            'f' to setOf('d', 'r', 't', 'g', 'c', 'v'),
            'g' to setOf('f', 't', 'y', 'h', 'v', 'b'),
            'h' to setOf('g', 'y', 'u', 'j', 'b', 'n'),
            'j' to setOf('h', 'u', 'i', 'k', 'n', 'm'),
            'k' to setOf('j', 'i', 'o', 'l', 'm'),
            'l' to setOf('k', 'o', 'p'),
            'z' to setOf('a', 's', 'x'),
            'x' to setOf('z', 's', 'd', 'c'),
            'c' to setOf('x', 'd', 'f', 'v'),
            'v' to setOf('c', 'f', 'g', 'b'),
            'b' to setOf('v', 'g', 'h', 'n'),
            'n' to setOf('b', 'h', 'j', 'm'),
            'm' to setOf('n', 'j', 'k')
        )
        
        val adjacent1 = adjacencyMap[key1.lowercaseChar()] ?: emptySet()
        return key2.lowercaseChar() in adjacent1
    }
    // =================================================================================
    // END BLOCK: areKeysAdjacent
    // =================================================================================
    // =================================================================================
    // END BLOCK: calculatePathKeyScore
    // =================================================================================

    // =================================================================================
    // FUNCTION: getOrCreateTemplate
    // SUMMARY: Gets or creates a word template with key positions. Returns null if any
    //          character in the word is missing from the keyMap. Logs first failure per
    //          batch to avoid log spam while still providing diagnostic info.
    // =================================================================================

    // =================================================================================
    // FUNCTION: getOrCreateTemplate (With Micro-Loops for Double Letters)
    // =================================================================================
    private fun getOrCreateTemplate(word: String, keyMap: Map<String, PointF>): WordTemplate? {
        templateCache[word]?.let { return it }

        val rawPoints = ArrayList<PointF>()
        val rawWeights = ArrayList<Float>()
        var lastKeyPos: PointF? = null
        
        for (char in word) {
            val keyPos = keyMap[char.toString().uppercase()] ?: keyMap[char.toString().lowercase()] ?: return null
            
            // Consonant Anchoring: Vowels = 0.6, Consonants = 1.0
            val weight = if (isVowel(char)) 0.6f else 1.0f
            
            // NEW: Apply learned user offset (Fat Finger Correction)
            val offset = keyOffsets[char.toString().lowercase()] ?: PointF(0f, 0f)
            val adjustedX = keyPos.x + offset.x
            val adjustedY = keyPos.y + offset.y

            // DOUBLE LETTER LOGIC:
            if (lastKeyPos != null && keyPos.x == lastKeyPos.x && keyPos.y == lastKeyPos.y) {
                rawPoints.add(PointF(adjustedX + 15f, adjustedY + 15f))
                rawWeights.add(weight)
            }
            
            rawPoints.add(PointF(adjustedX, adjustedY))
            rawWeights.add(weight)
            
            lastKeyPos = keyPos

            if (lastKeyPos != null && keyPos.x == lastKeyPos.x && keyPos.y == lastKeyPos.y) {
                rawPoints.add(PointF(keyPos.x + 15f, keyPos.y + 15f))
                rawWeights.add(weight)
            }
            
            rawPoints.add(PointF(keyPos.x, keyPos.y))
            rawWeights.add(weight)
            
            lastKeyPos = keyPos
        }

        if (rawPoints.size < 2) return null

        // (Debug log removed to prevent spam)

        val t = WordTemplate(word, getWordRank(word), rawPoints, rawWeights)
        templateCache[word] = t
        return t
    }

    // =================================================================================
    // END BLOCK: getOrCreateTemplate
    // =================================================================================

/**
     * Calculates the total absolute length of a path in pixels.
     */
    private fun getPathLength(points: List<PointF>): Float {
        if (points.size < 2) return 0f
        var length = 0f
        for (i in 0 until points.size - 1) {
            length += hypot(points[i+1].x - points[i].x, points[i+1].y - points[i].y)
        }
        return length
    }
    /**
     * Uniformly sample N points along a path.
     * This makes paths of different lengths comparable.
     */
    private fun samplePath(path: List<PointF>, numSamples: Int): List<PointF> {
        // [Existing samplePath code...]
        if (path.size < 2) return path
        if (path.size == numSamples) return path
        
        // Calculate total path length
        var totalLength = 0f
        for (i in 1 until path.size) {
            totalLength += hypot(path[i].x - path[i-1].x, path[i].y - path[i-1].y)
        }
        
        if (totalLength < 0.001f) {
            // Path is essentially a point - return copies of first point
            return List(numSamples) { PointF(path[0].x, path[0].y) }
        }
        
        val segmentLength = totalLength / (numSamples - 1)
        val sampled = ArrayList<PointF>(numSamples)
        sampled.add(PointF(path[0].x, path[0].y))
        
        var currentDist = 0f
        var pathIndex = 0
        var targetDist = segmentLength
        
        while (sampled.size < numSamples - 1 && pathIndex < path.size - 1) {
            val p1 = path[pathIndex]
            val p2 = path[pathIndex + 1]
            val segLen = hypot(p2.x - p1.x, p2.y - p1.y)
            
            while (currentDist + segLen >= targetDist && sampled.size < numSamples - 1) {
                val ratio = (targetDist - currentDist) / segLen
                val x = p1.x + ratio * (p2.x - p1.x)
                val y = p1.y + ratio * (p2.y - p1.y)
                sampled.add(PointF(x, y))
                targetDist += segmentLength
            }
            
            currentDist += segLen
            pathIndex++
        }
        
        // Ensure we have exactly numSamples by adding the last point
        while (sampled.size < numSamples) {
            sampled.add(PointF(path.last().x, path.last().y))
        }
        
        return sampled
    }

    /**
     * Samples both Points AND Weights uniformly.
     */
    private fun sampleTemplate(path: List<PointF>, weights: List<Float>, numSamples: Int): Pair<List<PointF>, List<Float>> {
        if (path.size < 2 || weights.size != path.size) return Pair(path, weights)
        
        var totalLength = 0f
        for (i in 1 until path.size) {
            totalLength += hypot(path[i].x - path[i-1].x, path[i].y - path[i-1].y)
        }
        
        if (totalLength < 0.001f) {
            return Pair(
                List(numSamples) { PointF(path[0].x, path[0].y) },
                List(numSamples) { weights[0] }
            )
        }
        
        val segmentLength = totalLength / (numSamples - 1)
        val sampledPoints = ArrayList<PointF>(numSamples)
        val sampledWeights = ArrayList<Float>(numSamples)
        
        sampledPoints.add(PointF(path[0].x, path[0].y))
        sampledWeights.add(weights[0])
        
        var currentDist = 0f
        var pathIndex = 0
        var targetDist = segmentLength
        
        while (sampledPoints.size < numSamples - 1 && pathIndex < path.size - 1) {
            val p1 = path[pathIndex]
            val p2 = path[pathIndex + 1]
            val w1 = weights[pathIndex]
            val w2 = weights[pathIndex + 1]
            val segLen = hypot(p2.x - p1.x, p2.y - p1.y)
            
            while (currentDist + segLen >= targetDist && sampledPoints.size < numSamples - 1) {
                val ratio = (targetDist - currentDist) / segLen
                
                // Interpolate Point
                val x = p1.x + ratio * (p2.x - p1.x)
                val y = p1.y + ratio * (p2.y - p1.y)
                sampledPoints.add(PointF(x, y))
                
                // Interpolate Weight
                val w = w1 + ratio * (w2 - w1)
                sampledWeights.add(w)
                
                targetDist += segmentLength
            }
            
            currentDist += segLen
            pathIndex++
        }
        
        while (sampledPoints.size < numSamples) {
            sampledPoints.add(PointF(path.last().x, path.last().y))
            sampledWeights.add(weights.last())
        }
        
        return Pair(sampledPoints, sampledWeights)
    }
    
    /**
     * Normalize a path to fit within a square of size NORMALIZATION_SIZE.
     * This removes scale and translation differences for shape comparison.
     */
    private fun normalizePath(path: List<PointF>): List<PointF> {
        if (path.isEmpty()) return path
        
        // Find bounding box
        var minX = Float.MAX_VALUE
        var maxX = Float.MIN_VALUE
        var minY = Float.MAX_VALUE
        var maxY = Float.MIN_VALUE
        
        for (pt in path) {
            minX = min(minX, pt.x)
            maxX = max(maxX, pt.x)
            minY = min(minY, pt.y)
            maxY = max(maxY, pt.y)
        }
        
        val width = maxX - minX
        val height = maxY - minY
        val maxDim = max(width, height)
        
        if (maxDim < 0.001f) {
            // All points are the same - return centered points
            return path.map { PointF(NORMALIZATION_SIZE / 2, NORMALIZATION_SIZE / 2) }
        }
        
        // Scale to NORMALIZATION_SIZE and center at origin
        val scale = NORMALIZATION_SIZE / maxDim
        val centerX = (minX + maxX) / 2
        val centerY = (minY + maxY) / 2
        
        return path.map { pt ->
            PointF(
                (pt.x - centerX) * scale + NORMALIZATION_SIZE / 2,
                (pt.y - centerY) * scale + NORMALIZATION_SIZE / 2
            )
        }
    }
    
    /**
     * Calculate shape score between two normalized paths.
     * Uses average point-to-point distance.
     * Lower score = better match.
     */
    private fun calculateShapeScore(input: List<PointF>, template: List<PointF>): Float {
        if (input.size != template.size) return Float.MAX_VALUE
        
        var totalDist = 0f
        for (i in input.indices) {
            val dx = input[i].x - template[i].x
            val dy = input[i].y - template[i].y
            totalDist += sqrt(dx * dx + dy * dy)
        }
        
        return totalDist / input.size
    }
    
    /**
     * Calculate location score between two paths (absolute positions).
     * Uses average point-to-point distance with position weighting.
     * Points at the beginning and end are weighted more heavily.
     * Lower score = better match.
     */

    /**
     * Calculate location score with Consonant Anchoring support.
     * @param templateWeights List of weights (1.0 for consonants, 0.6 for vowels). Can be null for backwards compat.
     */
    private fun calculateLocationScore(input: List<PointF>, template: List<PointF>, templateWeights: List<Float>? = null): Float {
        var totalDist = 0f
        var totalWeight = 0f
        val size = input.size
        
        for (i in input.indices) {
            val dist = hypot(input[i].x - template[i].x, input[i].y - template[i].y)
            
            // --- ENDPOINT WEIGHTING (Strict) ---
            val posWeight = when {
                i < size * 0.15 -> 3.0f
                i > size * 0.85 -> 5.0f 
                else -> 1.0f
            }
            
            // --- CONSONANT ANCHORING ---
            // Consonants = 1.0, Vowels = 0.6
            // Multiply position weight by character weight
            val charWeight = templateWeights?.getOrElse(i) { 1.0f } ?: 1.0f
            
            val combinedWeight = posWeight * charWeight
            
            totalDist += dist * combinedWeight
            totalWeight += combinedWeight
        }
        return if (totalWeight > 0) totalDist / totalWeight else totalDist
    }



    // =================================================================================
    // NEW: DIRECTION SCORING HELPERS
    // =================================================================================
    

    private fun calculateDirectionVectors(path: List<PointF>): List<PointF> {
        val vectors = ArrayList<PointF>()
        for (i in 0 until path.size - 1) {
            val dx = path[i+1].x - path[i].x
            val dy = path[i+1].y - path[i].y
            val len = hypot(dx, dy)
            if (len > 0.001f) {
                vectors.add(PointF(dx/len, dy/len))
            } else {
                // Return 0,0 for stationary segments (handled by Score function now)
                vectors.add(PointF(0f, 0f))
            }
        }
        return vectors
    }

    // =================================================================================
    // FUNCTION: calculateDirectionScore (Fixed for Double Letters & Pauses)
    // =================================================================================

    // =================================================================================
    // FUNCTION: calculateDirectionScore (Linear + Stationary Skip)
    // =================================================================================
    private fun calculateDirectionScore(input: List<PointF>, template: List<PointF>): Float {
        var totalScore = 0f
        var validPoints = 0
        
        val count = min(input.size, template.size)
        if (count == 0) return 0f

        for (i in 0 until count) {
            val v1 = input[i]
            val v2 = template[i]
            
            // Skip stationary segments (Pause/Tap)
            if ((v2.x == 0f && v2.y == 0f) || (v1.x == 0f && v1.y == 0f)) {
                continue
            }

            // Dot Product: 1.0 = aligned, -1.0 = opposite
            val dot = v1.x * v2.x + v1.y * v2.y
            
            // Penalty: Linear (Robust for complex words like "Either")
            // Reverted from Squared to forgive messy scribbles.
            totalScore += (1.0f - dot)
            validPoints++
        }
        
        return if (validPoints > 0) totalScore / validPoints else 0f
    }

// =================================================================================
    // FUNCTION: detectTurns
    // SUMMARY: Detects significant direction changes (turns/corners) in a path.
    //          Returns a list of (position, angle) pairs where position is 0.0-1.0
    //          along the path and angle is the turn magnitude in radians.
    //          A turn is detected when consecutive direction vectors differ significantly.
    // =================================================================================
// =================================================================================
    // FUNCTION: detectTurns (v2 - Sharp Corner Detection)
    // SUMMARY: Detects significant direction changes with emphasis on SHARP corners.
    //          Sharp corners = abrupt changes over 1-2 points (more intentional)
    //          Rounded corners = gradual changes over many points (less distinctive)
    //          Returns list of (position, sharpness) where sharpness indicates
    //          how abrupt the turn was (higher = sharper).
    // =================================================================================

    // =================================================================================
    // FUNCTION: detectTurns (v3 - Ultra-Sharp Emphasis)
    // =================================================================================
    private fun detectTurns(directions: List<PointF>): List<Pair<Float, Float>> {
        if (directions.size < 3) return emptyList()
        
        val turns = ArrayList<Pair<Float, Float>>()
        
        for (i in 0 until directions.size - 1) {
            val curr = directions[i]
            val next = directions[i + 1]
            
            if ((curr.x == 0f && curr.y == 0f) || (next.x == 0f && next.y == 0f)) continue
            
            // Dot product: 1.0 = straight, 0 = 90deg, -1 = U-turn
            val dot = curr.x * next.x + curr.y * next.y
            
            // ULTRA SHARP CORNER (e.g. "W", "Z", "M")
            // dot < 0.2 means angle > 78 degrees
            if (dot < 0.2f) {
                val position = i.toFloat() / directions.size.toFloat()
                // AMPLIFIED: Scale sharpness by 3.0x (was 1.5x)
                // This makes a sharp corner worth 3 "normal" curves
                val sharpness = (1.0f - dot) * 3.0f  
                turns.add(Pair(position, sharpness))
            }
            // MEDIUM CORNER (Standard curve)
            // dot < 0.6 means angle > 53 degrees
            else if (dot < 0.6f) {
                val position = i.toFloat() / directions.size.toFloat()
                val sharpness = (1.0f - dot) * 0.8f // Reduce weight of soft curves
                turns.add(Pair(position, sharpness))
            }
        }
        
        // Secondary pass for "spread out" turns (U-turns that take 3 points)
        for (i in 0 until directions.size - 3) {
            val curr = directions[i]
            val later = directions[i + 3]
            
            if ((curr.x == 0f && curr.y == 0f) || (later.x == 0f && later.y == 0f)) continue
            
            val dot = curr.x * later.x + curr.y * later.y
            
            if (dot < 0.1f) {  
                val position = (i + 1.5f) / directions.size.toFloat()
                
                val nearbyTurn = turns.any { abs(it.first - position) < 0.08f }
                if (!nearbyTurn) {
                    val sharpness = (1.0f - dot) * 2.0f // Boost U-turns too
                    turns.add(Pair(position, sharpness))
                }
            }
        }
        
        return turns.sortedBy { it.first }
    }

    // =================================================================================
    // END BLOCK: detectTurns
    // =================================================================================
    // =================================================================================
    // END BLOCK: detectTurns
    // =================================================================================

    // =================================================================================
    // FUNCTION: calculateTurnScore
    // SUMMARY: Compares turn patterns between input and template.
    //          Rewards matching turn counts and positions, penalizes mismatches.
    //          Lower score = better match.
    // =================================================================================
// =================================================================================
    // FUNCTION: calculateTurnScore (v2 - Sharp Corner Emphasis)
    // SUMMARY: Compares turn patterns with HEAVY emphasis on matching sharp corners.
    //          - Matching sharp corners = big reward (low score)
    //          - Missing sharp corners = big penalty (high score)
    //          - Turn count matters less than turn positions and sharpness
    // =================================================================================

    // =================================================================================
    // FUNCTION: calculateTurnScore (v3 - Sharp Corner Enforcement)
    // =================================================================================
    private fun calculateTurnScore(inputTurns: List<Pair<Float, Float>>, templateTurns: List<Pair<Float, Float>>): Float {
        if (inputTurns.isEmpty() && templateTurns.isEmpty()) return 0f
        
        var score = 0f
        
        // Filter for "Significant" turns (Sharpness > 1.5, which corresponds to our new 3.0x scale)
        val templateSharpTurns = templateTurns.filter { it.second > 1.5f }
        val inputSharpTurns = inputTurns.filter { it.second > 1.5f }
        
        // HEAVY PENALTY for mismatching sharp corners
        if (templateSharpTurns.isNotEmpty() && inputSharpTurns.isEmpty()) {
            // Template has a sharp corner (like "Android" 'N') but user missed it -> Fatal
            score += 1.5f 
        } else if (templateSharpTurns.isEmpty() && inputSharpTurns.isNotEmpty()) {
            // User made a sharp jerk where none belongs -> Fatal
            score += 1.0f
        }
        
        val usedTemplate = BooleanArray(templateTurns.size)
        var matchedTurns = 0
        var totalSharpnessMatch = 0f
        
        for (inputTurn in inputTurns) {
            var bestMatch = -1
            var bestScore = Float.MAX_VALUE
            
            for (j in templateTurns.indices) {
                if (usedTemplate[j]) continue
                
                val posDist = abs(inputTurn.first - templateTurns[j].first)
                val sharpnessDiff = abs(inputTurn.second - templateTurns[j].second)
                
                // Position tolerance: 20%
                if (posDist < 0.20f) {
                    val matchScore = posDist * 2f + sharpnessDiff * 0.5f
                    if (matchScore < bestScore) {
                        bestScore = matchScore
                        bestMatch = j
                    }
                }
            }
            
            if (bestMatch >= 0) {
                usedTemplate[bestMatch] = true
                matchedTurns++
                totalSharpnessMatch += bestScore
                
                // HUGE REWARD: If both are sharp and matched
                if (inputTurn.second > 1.5f && templateTurns[bestMatch].second > 1.5f) {
                    score -= 0.5f  // Massive bonus for hitting the corner
                }
            } else {
                // Penalty for extra turns in input
                score += 0.2f + inputTurn.second * 0.2f
            }
        }
        
        // Penalty for missing turns in template
        for (j in templateTurns.indices) {
            if (!usedTemplate[j]) {
                score += 0.2f + templateTurns[j].second * 0.2f
            }
        }
        
        if (matchedTurns > 0) {
            score += totalSharpnessMatch / matchedTurns * 0.3f
        }
        
        return max(0f, score)
    }

    // =================================================================================
    // END BLOCK: calculateTurnScore
    // =================================================================================
    // =================================================================================
    // END BLOCK: calculateTurnScore
    // =================================================================================



    /**
     * Find all keys within threshold distance of a point.
     * Returns a Map of Key -> Distance for O(1) lookups.
     */
    private fun findKeysWithDist(pt: PointF, keyMap: Map<String, PointF>, threshold: Float): Map<String, Float> {
        val keys = HashMap<String, Float>()
        for ((key, pos) in keyMap) {
            if (key.length != 1) continue
            val dist = hypot(pt.x - pos.x, pt.y - pos.y)
            if (dist < threshold) {
                // If key exists (e.g. from another case), keep smallest dist
                val existing = keys[key.lowercase()]
                if (existing == null || dist < existing) {
                    keys[key.lowercase()] = dist
                }
            }
        }
        return keys
    }
    
    private fun getWordRank(word: String): Int {
        var current = root
        for (char in word) {
            current = current.children[char] ?: return Int.MAX_VALUE
        }
        return if (current.isEndOfWord) current.rank else Int.MAX_VALUE
    }
    
    // =================================================================================
    // END BLOCK: SHARK2-INSPIRED SWIPE DECODER LOGIC
    // =================================================================================


    /**
     * Blocks a word permanently:
     * 1. Adds to memory.
     * 2. Removes from active lists.
     * 3. Removes from user stats. 
     * 4. Saves to file.
     */

    fun blockWord(context: Context, word: String) {
        val cleanWord = word.trim().lowercase(java.util.Locale.ROOT)
        if (cleanWord.isEmpty()) return

        Thread {
            try {
                synchronized(this) {
                    blockedWords.add(cleanWord)
                    customWords.remove(cleanWord)
                    wordList.remove(cleanWord)
                    
                    if (cleanWord.isNotEmpty()) {
                        wordsByFirstLetter[cleanWord.first()]?.remove(cleanWord)
                        if (cleanWord.length >= 2) {
                            wordsByFirstLastLetter["${cleanWord.first()}${cleanWord.last()}"]?.remove(cleanWord)
                        }
                    }
                    
                    synchronized(userFrequencyMap) {
                        userFrequencyMap.remove(cleanWord)
                    }
                    templateCache.remove(cleanWord)
                    
                    // FIX: Save files inside synchronized block to prevent ConcurrentModification and race conditions
                    saveSetToFile(context, BLOCKED_DICT_FILE, blockedWords)
                    saveSetToFile(context, USER_DICT_FILE, customWords)
                }
                
                saveUserStats(context)

                android.util.Log.d("DroidOS_Prediction", "BLOCKED: '$cleanWord'")
            } catch (e: Exception) {
                android.util.Log.e("DroidOS_Prediction", "Block failed", e)
            }
        }.start()
    }


    // =================================================================================
    // FUNCTION: calculateSwipeSpeed
    // SUMMARY: Calculates average swipe speed in pixels per millisecond.
    // =================================================================================
    fun calculateSwipeSpeed(timedPath: List<TimedPoint>): Float {
        if (timedPath.size < 2) return 0f
        
        var totalLength = 0f
        for (i in 1 until timedPath.size) {
            val prev = timedPath[i - 1]
            val curr = timedPath[i]
            totalLength += hypot(curr.x - prev.x, curr.y - prev.y)
        }
        
        val startTime = timedPath.first().timestamp
        val endTime = timedPath.last().timestamp
        val duration = (endTime - startTime).toFloat()
        
        if (duration <= 0f) return 0f
        
        return totalLength / duration
    }
    // =================================================================================
    // END BLOCK: calculateSwipeSpeed
    // =================================================================================

    // =================================================================================
    // FUNCTION: updateContextModel
    // SUMMARY: Updates the n-gram language model with a newly committed word.
    // =================================================================================
    fun updateContextModel(word: String) {
        val normalizedWord = word.lowercase(Locale.ROOT).trim()
        if (normalizedWord.isEmpty() || normalizedWord.length < 2) return
        
        unigramCounts[normalizedWord] = (unigramCounts[normalizedWord] ?: 0) + 1
        
        lastContextWord?.let { prev ->
            val prevNorm = prev.lowercase(Locale.ROOT)
            val bigramMap = bigramCounts.getOrPut(prevNorm) { HashMap() }
            bigramMap[normalizedWord] = (bigramMap[normalizedWord] ?: 0) + 1
        }
        
        lastContextWord = normalizedWord
    }
    // =================================================================================
    // END BLOCK: updateContextModel
    // =================================================================================

    // =================================================================================
    // FUNCTION: clearContext
    // SUMMARY: Resets the context model's current state at sentence boundaries.
    // =================================================================================
    fun clearContext() {
        lastContextWord = null
    }
    // =================================================================================
    // END BLOCK: clearContext
    // =================================================================================

    // =================================================================================
    // FUNCTION: getContextBoost (private)
    // SUMMARY: Returns a boost factor for a word based on context (previous word).
    // =================================================================================
    private fun getContextBoost(word: String): Float {
        val normalizedWord = word.lowercase(Locale.ROOT)
        if (lastContextWord == null) return 1.0f
        
        val prevWord = lastContextWord!!.lowercase(Locale.ROOT)
        val bigramMap = bigramCounts[prevWord] ?: return 1.0f
        
        val bigramCount = bigramMap[normalizedWord] ?: 0
        if (bigramCount == 0) return 1.0f
        
        val prevTotalCount = bigramMap.values.sum().toFloat().coerceAtLeast(1f)
        val bigramProb = bigramCount / prevTotalCount
        
        return 1.0f + (bigramProb * 0.5f).coerceAtMost(0.5f)
    }
    // =================================================================================
    // END BLOCK: getContextBoost
    // =================================================================================

    // =================================================================================


    // =================================================================================
    // FUNCTION:     // FUNCTION: getGrammarBoost
    // SUMMARY: Returns a multiplier based on grammar rules between previous and current word.
    //          e.g. "I" (Pronoun) -> "run" (Verb) = BOOST
    //          e.g. "The" (Determiner) -> "run" (Verb) = PENALTY
    // =================================================================================
    private fun getGrammarBoost(word: String): Float {
        if (lastContextWord == null) return 1.0f
        
        val prevWord = lastContextWord!!.lowercase(Locale.ROOT)
        val currWord = word.lowercase(Locale.ROOT)
        
        // 1. REPEAT WORD PENALTY (Avoid "the the", "is is")
        if (prevWord == currWord) {
            // Exceptions: "that that", "had had"
            if (prevWord != "that" && prevWord != "had") {
                return 0.2f // Strong Penalty
            }
        }
        
        val prevTag = commonPosTags[prevWord] ?: POSTag.UNKNOWN
        val currTag = commonPosTags[currWord] ?: POSTag.UNKNOWN
        
        // If we don't know the tags, assume neutral
        if (prevTag == POSTag.UNKNOWN && currTag == POSTag.UNKNOWN) return 1.0f

        return when (prevTag) {
            POSTag.PRONOUN -> {
                // NEGATIVE CONTEXT: "He the", "I a" -> IMPOSSIBLE
                if (currTag == POSTag.DETERMINER) 0.1f
                // "I run", "He is" -> High Boost
                else if (currTag == POSTag.VERB) 1.3f 
                // "I very" -> Moderate
                else if (currTag == POSTag.ADVERB) 1.1f
                else 1.0f
            }
            POSTag.DETERMINER -> {
                // NEGATIVE CONTEXT: "The the", "My a" -> IMPOSSIBLE
                if (currTag == POSTag.DETERMINER) 0.1f 
                // NEGATIVE CONTEXT: "The he" -> HIGHLY UNLIKELY
                else if (currTag == POSTag.PRONOUN) 0.2f
                // "The run" (Bad) vs "The car" (Good - assuming Unknowns are often Nouns/Adj)
                else if (currTag == POSTag.VERB) 0.6f // Penalty
                else if (currTag == POSTag.UNKNOWN || currTag == POSTag.ADJECTIVE || currTag == POSTag.NOUN) 1.15f 
                else 1.0f
            }
            POSTag.VERB -> {
                // "Go to", "Look at"
                if (currTag == POSTag.PREPOSITION || currTag == POSTag.DETERMINER) 1.2f 
                // "Is not"
                else if (currTag == POSTag.ADVERB) 1.2f
                else 1.0f
            }
            POSTag.PREPOSITION -> {
                // "To the", "For my"
                if (currTag == POSTag.DETERMINER || currTag == POSTag.PRONOUN) 1.25f 
                else 1.0f
            }
            POSTag.ADVERB -> {
                // "Very good" (Adj), "Not go" (Verb)
                if (currTag == POSTag.ADJECTIVE || currTag == POSTag.VERB) 1.2f 
                else 1.0f
            }
            POSTag.QUESTION -> {
                // "Who is", "What do"
                if (currTag == POSTag.VERB) 1.3f 
                else 1.0f
            }
            else -> 1.0f
        }
    }




    // =================================================================================
    // FUNCTION: decodeSwipeShapeContext (Debug + Grammar + Adjacency Fix)
    // SUMMARY: Gboard-style decoder with Grammar Context, Debug Logging, and Smart End-Keys.
    // =================================================================================
    fun decodeSwipeShapeContext(
        timedPath: List<TimedPoint>, 
        keyMap: Map<String, PointF>
    ): List<SwipeResult> {
        val swipePath = timedPath.map { it.toPointF() }
        
        if (swipePath.size < 3 || keyMap.isEmpty()) return emptyList()
        if (wordList.isEmpty()) {
            loadDefaults()
            return emptyList()
        }

        val keyMapHash = keyMap.hashCode()
        if (keyMapHash != lastKeyMapHash) {
            templateCache.clear()
            lastKeyMapHash = keyMapHash
        }

        val inputLength = getPathLength(swipePath)
        if (inputLength < 10f) return emptyList()

        val sampledInput = samplePath(swipePath, SAMPLE_POINTS)
        if (sampledInput.isEmpty()) return emptyList()
        
        val normalizedInput = normalizePath(sampledInput)
        val inputDirections = calculateDirectionVectors(sampledInput)
        val inputTurns = detectTurns(inputDirections)

        val startPoint = sampledInput.first()
        val endPoint = sampledInput.last()
        val startKey = findClosestKey(startPoint, keyMap)
        val endKey = findClosestKey(endPoint, keyMap)
        
        // DEBUG: Calculate "Letters Swiped" for logcat
        val pathKeys = extractPathKeys(sampledInput, keyMap, 8)
        val pathKeyString = pathKeys.joinToString("-")
        android.util.Log.d("DroidOS_SwipeDebug", "========================================")
        android.util.Log.d("DroidOS_SwipeDebug", "[INPUT] Path: $pathKeyString | Start: $startKey | End: $endKey")
        
        // Candidate collection
        val candidates = HashSet<String>()
        val nearbyStart = findNearbyKeys(startPoint, keyMap, 100f)
        val nearbyEnd = findNearbyKeys(endPoint, keyMap, 100f)
        
        for (s in nearbyStart) {
            for (e in nearbyEnd) {
                wordsByFirstLastLetter["${s}${e}"]?.let { candidates.addAll(it) }
            }
        }
        
        if (startKey != null && startKey.isNotEmpty()) {
            wordsByFirstLetter[startKey.first()]?.let { words ->
                candidates.addAll(words.take(50))
            }
        }
        
        lastContextWord?.let { prev ->
            val prevNorm = prev.lowercase(Locale.ROOT)
            bigramCounts[prevNorm]?.let { followingWords ->
                candidates.addAll(followingWords.keys.take(20))
            }
        }

        synchronized(userFrequencyMap) {
            candidates.addAll(userFrequencyMap.entries
                .sortedByDescending { it.value }
                .take(30)
                .map { it.key })
        }

        // SCORING
        val scored = candidates
            .filter { !isWordBlocked(it) && it.length >= MIN_WORD_LENGTH }
            .take(400)
            .mapNotNull { word ->
                val template = getOrCreateTemplate(word, keyMap) ?: return@mapNotNull null
                
                val tLen = getPathLength(template.rawPoints)
                val ratio = tLen / inputLength
                
                // More lenient ratio
                if (ratio > 6.0f || ratio < 0.3f) return@mapNotNull null

                if (template.sampledPoints == null || template.normalizedPoints == null || template.directionVectors == null || template.sampledWeights == null) {
                    val (pts, wts) = sampleTemplate(template.rawPoints, template.rawWeights, SAMPLE_POINTS)
                    template.sampledPoints = pts
                    template.sampledWeights = wts
                    template.normalizedPoints = normalizePath(template.sampledPoints!!)
                    template.directionVectors = calculateDirectionVectors(template.sampledPoints!!)
                }
                
                val tSampled = template.sampledPoints ?: return@mapNotNull null
                val tWeights = template.sampledWeights ?: return@mapNotNull null
                val tNormalized = template.normalizedPoints ?: return@mapNotNull null
                val tDirections = template.directionVectors ?: return@mapNotNull null
                if (tSampled.isEmpty() || tNormalized.isEmpty() || tDirections.isEmpty()) return@mapNotNull null
                
                // Calculate scores
                val shapeScore = calculateShapeScore(normalizedInput, tNormalized)
                // Pass weights
                val locScore = calculateLocationScore(sampledInput, tSampled, tWeights)
                val dirScore = calculateDirectionScore(inputDirections, tDirections)
                val templateTurns = detectTurns(tDirections)
                val turnScore = calculateTurnScore(inputTurns, templateTurns)
                val pathKeyScore = calculatePathKeyScore(pathKeys, word) // Added Path Key Score

                // Integration
                val geometryScore = (shapeScore * SHAPE_CONTEXT_SHAPE_WEIGHT) +
                                    (locScore * SHAPE_CONTEXT_LOCATION_WEIGHT) +
                                    (dirScore * SHAPE_CONTEXT_DIRECTION_WEIGHT) +
                                    (turnScore * SHAPE_CONTEXT_TURN_WEIGHT) +
                                    (pathKeyScore * 0.5f) // Add fuzzy path key penalty
                
                // Smart Penalty
                var penalty = 0f
                if (startKey != null && !word.startsWith(startKey, ignoreCase = true)) {
                    penalty += SHAPE_CONTEXT_START_PENALTY
                }
                if (endKey != null && !word.endsWith(endKey, ignoreCase = true)) {
                     val lastChar = word.last()
                     val endChar = endKey.first()
                     // FIX: If keys are adjacent (e.g. B and N), penalize less
                     if (areKeysAdjacent(lastChar, endChar)) {
                         penalty += 0.2f 
                     } else {
                         penalty += SHAPE_CONTEXT_END_PENALTY
                     }
                }
                
                // Context & Grammar
                val nGramBoost = getContextBoost(word)
                val grammarBoost = getGrammarBoost(word)
                val totalContextBoost = (nGramBoost * grammarBoost).coerceAtMost(2.5f)
                
                // Frequency
                val rank = template.rank
                val freqBonus = 1.0f / (1.0f + 0.15f * ln((rank + 1).toFloat()))
                
                var userBoost = 1.0f
                synchronized(userFrequencyMap) {
                    val userCount = userFrequencyMap[word] ?: 0
                    if (userCount > 0) {
                        userBoost *= (1.0f + 0.1f * min(userCount, 10))
                    }
                }
                userBoost *= totalContextBoost
                
                                // FINAL CALCULATION
                                // FREQUENCY WEIGHT INCREASED (0.4 -> 0.7) to help "run" beat "rub"
                                var finalScore = (geometryScore + penalty) * (1.0f - 0.7f * freqBonus) / userBoost
                                
                                // APPLY PENALTY
                                val penaltyEnd = temporaryPenalties[word] ?: 0L
                                if (System.currentTimeMillis() < penaltyEnd) {
                                    finalScore *= 10.0f // Massive penalty
                                }
                                
                                // DEBUG LOGGING
                if (finalScore < 5.0f || totalContextBoost > 1.1f) {
                     android.util.Log.d("DroidOS_SwipeDebug", 
                        "CAND: %-10s | Final: %.2f | Geom: %.2f | Ctx: %.2f (NG:%.2f * GR:%.2f)".format(
                            word, finalScore, geometryScore + penalty, totalContextBoost, nGramBoost, grammarBoost
                        )
                    )
                }

                val confidence = (1.0f / (1.0f + finalScore)).coerceIn(0f, 1f)
                SwipeResult(word, PredictionSource.SHAPE_CONTEXT, confidence, finalScore)
            }
        
        return scored.sortedBy { it.rawScore }.distinctBy { it.word }.take(5)
    }
    // =================================================================================
    // FUNCTION: decodeSwipeDual
    // SUMMARY: Main entry point for dual-algorithm prediction.
    //          Runs BOTH Precise and Shape/Context algorithms, then picks winner
    //          based on swipe speed. Returns SwipeResult list with source info.
    //          
    // SPEED-BASED SELECTION:
    //   - speed < 0.8 px/ms: PRECISE wins (slow, careful swipes)
    //   - speed >= 0.8 px/ms: SHAPE_CONTEXT wins (fast, sloppy swipes)
    //          
    // RETURNS: List<SwipeResult> with first item being the "winner"
    // =================================================================================


    fun decodeSwipeDual(
        timedPath: List<TimedPoint>, 
        keyMap: Map<String, PointF>
    ): List<SwipeResult> {
        if (timedPath.size < 3 || keyMap.isEmpty()) return emptyList()
        
        // NEW: Cache this path. If the user selects a word from this swipe,
        // we will use this path to learn their "fat finger" offsets.
        

        // NEW: Cache this path. If the user selects a word from this swipe,
        // we will use this path to learn their "fat finger" offsets.
        
        lastSwipePath = ArrayList(timedPath)
        lastKeyMap = keyMap // Cache reference
        android.util.Log.d("DroidOS_Debug", "CACHE: Saved path with ${timedPath.size} points")

        // Ensure dictionary is loaded
        if (wordList.isEmpty()) {
            android.util.Log.w("DroidOS_Dual", "Dictionary not loaded, loading now...")
            loadDefaults()
            if (wordList.isEmpty()) {
                android.util.Log.e("DroidOS_Dual", "Failed to load dictionary!")
                return emptyList()
            }
        }
        
        val swipePath = timedPath.map { it.toPointF() }
        val keyDwellTimes = calculateKeyDwellTimes(timedPath, keyMap)
        
        // Calculate speed to determine winner
        val speed = calculateSwipeSpeed(timedPath)
        // Use instance variable 'speedThreshold' instead of constant
        val usePrecise = speed < speedThreshold
        
        android.util.Log.d("DroidOS_Dual", "========== DUAL DECODE ==========")
        android.util.Log.d("DroidOS_Dual", "Speed: ${"%.3f".format(speed)} px/ms | Using: ${if (usePrecise) "PRECISE" else "SHAPE_CONTEXT"}")
        
        // Run BOTH algorithms
        val preciseResults = mutableListOf<SwipeResult>()
        val shapeResults = mutableListOf<SwipeResult>()
        
        // Precise algorithm
        try {
            val preciseWords = decodeSwipeWithDwell(swipePath, keyMap, keyDwellTimes)
            android.util.Log.d("DroidOS_Dual", "PRECISE raw: $preciseWords")
            preciseResults.addAll(preciseWords.mapIndexed { idx, word ->
                SwipeResult(
                    word = word,
                    source = PredictionSource.PRECISE,
                    confidence = (1.0f - idx * 0.15f).coerceIn(0.3f, 1.0f),
                    rawScore = idx.toFloat()
                )
            })
            android.util.Log.d("DroidOS_Dual", "PRECISE: ${preciseResults.take(3).map { it.word }}")
        } catch (e: Exception) {
            android.util.Log.e("DroidOS_Dual", "Precise error: ${e.message}")
            e.printStackTrace()  // Print full stack trace to logcat
        }
        
        // Shape/Context algorithm
        try {
            val shapeRaw = decodeSwipeShapeContext(timedPath, keyMap)
            android.util.Log.d("DroidOS_Dual", "SHAPE raw: ${shapeRaw.map { it.word }}")
            shapeResults.addAll(shapeRaw)
            android.util.Log.d("DroidOS_Dual", "SHAPE: ${shapeResults.take(3).map { it.word }}")
        } catch (e: Exception) {
            android.util.Log.e("DroidOS_Dual", "Shape error: ${e.message}")
            e.printStackTrace()  // Print full stack trace to logcat
        }

        
        // Merge results - winner's top result first
        val merged = mutableListOf<SwipeResult>()
        
        if (usePrecise) {
            // PRECISE wins
            preciseResults.firstOrNull()?.let { merged.add(it) }
            shapeResults.firstOrNull()?.let { merged.add(it) }
            preciseResults.drop(1).firstOrNull()?.let { merged.add(it) }
        } else {
            // SHAPE_CONTEXT wins
            shapeResults.firstOrNull()?.let { merged.add(it) }
            preciseResults.firstOrNull()?.let { merged.add(it) }
            shapeResults.drop(1).firstOrNull()?.let { merged.add(it) }
        }
        
        // Deduplicate by word (keep first occurrence to preserve source)
        val seen = HashSet<String>()
        val deduplicated = merged.filter { result ->
            val normalized = result.word.lowercase(Locale.ROOT)
            if (seen.contains(normalized)) false
            else { seen.add(normalized); true }
        }.take(3)
        
        android.util.Log.d("DroidOS_Dual", "FINAL: ${deduplicated.map { "${it.word}(${it.source.name[0]})" }}")
        android.util.Log.d("DroidOS_Dual", "==================================")

        // DEBUG: Log the weights of the WINNER to verify Consonant Anchoring
        // This confirms if vowels are getting 0.6 and consonants 1.0
        if (deduplicated.isNotEmpty()) {
            val winner = deduplicated[0]
            val t = templateCache[winner.word]
            if (t != null) {
                 android.util.Log.d("DroidOS_Weights", "WINNER '${winner.word}': ${t.rawWeights.map { "%.1f".format(it) }}")
            }
        }
        
        // FALLBACK: If both algorithms failed, try basic prefix matching
        if (deduplicated.isEmpty()) {
            android.util.Log.w("DroidOS_Dual", "Both algorithms failed! Using fallback...")
            val startPoint = swipePath.first()
            val startKey = findClosestKey(startPoint, keyMap)
            if (startKey != null) {
                val fallbackWords = getSuggestions(startKey, 3)
                if (fallbackWords.isNotEmpty()) {
                    android.util.Log.d("DroidOS_Dual", "Fallback results: $fallbackWords")
                    return fallbackWords.map { word ->
                        SwipeResult(word, PredictionSource.PRECISE, 0.5f, 100f)
                    }
                }
            }
        }
        
        return deduplicated
    }
    // =================================================================================
    // END BLOCK: decodeSwipeDual
    // =================================================================================

    // =================================================================================
    // FUNCTION: decodeSwipeDualPreview
    // SUMMARY: Lightweight dual-algorithm preview for mid-swipe updates.
    //          Returns top result from BOTH algorithms simultaneously so UI can
    //          display them side-by-side during swiping.
    //          
    // DISPLAY LAYOUT:
    //   - Left slot (cand1): Precise top result (GREEN)
    //   - Middle slot (cand2): Shape/Context top result (BLUE)
    //   - Right slot (cand3): Empty during preview
    //          
    // RETURNS: Pair<SwipeResult?, SwipeResult?> = (preciseTop, shapeTop)
    // =================================================================================
    fun decodeSwipeDualPreview(
        swipePath: List<PointF>, 
        keyMap: Map<String, PointF>
    ): Pair<SwipeResult?, SwipeResult?> {
        if (swipePath.size < 5 || keyMap.isEmpty()) return Pair(null, null)
        
        var preciseResult: SwipeResult? = null
        var shapeResult: SwipeResult? = null
        
        // Get quick PRECISE prediction (using existing preview function)
        try {
            val preciseWords = decodeSwipePreview(swipePath, keyMap)
            android.util.Log.d("DroidOS_Preview", "Precise preview: $preciseWords")
            if (preciseWords.isNotEmpty()) {
                preciseResult = SwipeResult(
                    word = preciseWords.first(),
                    source = PredictionSource.PRECISE,
                    confidence = 0.8f
                )
            }
        } catch (e: Exception) { 
            // Silent fail for preview
        }
        
        // Get quick SHAPE prediction (simplified for speed)
        try {
            shapeResult = decodeSwipeShapePreview(swipePath, keyMap)
            android.util.Log.d("DroidOS_Preview", "Shape preview: ${shapeResult?.word}")
        } catch (e: Exception) { 
            // Silent fail for preview
        }
        
        return Pair(preciseResult, shapeResult)
    }
    // =================================================================================
    // END BLOCK: decodeSwipeDualPreview
    // =================================================================================

    // =================================================================================
    // FUNCTION: decodeSwipeShapePreview
    // SUMMARY: Lightweight Shape/Context preview for mid-swipe updates.
    //          Uses simplified scoring with shape-first weights for speed.
    // =================================================================================
    private fun decodeSwipeShapePreview(
        swipePath: List<PointF>, 
        keyMap: Map<String, PointF>
    ): SwipeResult? {
        if (swipePath.size < 5 || keyMap.isEmpty()) return null
        if (wordList.isEmpty()) return null

        val inputLength = getPathLength(swipePath)
        if (inputLength < 20f) return null

        val sampledInput = samplePath(swipePath, SAMPLE_POINTS)
        val normalizedInput = normalizePath(sampledInput)

        val startPoint = sampledInput.first()
        val endPoint = sampledInput.last()
        val startKey = findClosestKey(startPoint, keyMap)

        // FAST CANDIDATE COLLECTION - wider radius for shape tolerance
        val candidates = HashSet<String>()

        val nearbyStart = findNearbyKeys(startPoint, keyMap, 80f)  // Wider than precise
        val nearbyEnd = findNearbyKeys(endPoint, keyMap, 80f)

        for (s in nearbyStart) {
            for (e in nearbyEnd) {
                wordsByFirstLastLetter["${s}${e}"]?.let { candidates.addAll(it) }
            }
        }

        if (startKey != null) {
            wordsByFirstLetter[startKey.first()]?.let { words ->
                candidates.addAll(words.take(30))
            }
        }

        // Add context-boosted candidates
        lastContextWord?.let { prev ->
            val prevNorm = prev.lowercase(Locale.ROOT)
            bigramCounts[prevNorm]?.let { followingWords ->
                candidates.addAll(followingWords.keys.take(10))
            }
        }

        // FAST SCORING with shape-first weights
        val scored = candidates
            .filter { !isWordBlocked(it) && it.length >= MIN_WORD_LENGTH }
            .take(40)
            .mapNotNull { word ->
                val template = getOrCreateTemplate(word, keyMap) ?: return@mapNotNull null

                val tLen = getPathLength(template.rawPoints)
                val ratio = tLen / inputLength
                if (ratio > 4.0f || ratio < 0.25f) return@mapNotNull null

                
                if (template.sampledPoints == null || template.normalizedPoints == null || template.directionVectors == null || template.sampledWeights == null) {

                
                                    val (pts, wts) = sampleTemplate(template.rawPoints, template.rawWeights, SAMPLE_POINTS)

                
                                    template.sampledPoints = pts

                
                                    template.sampledWeights = wts

                
                                    template.normalizedPoints = normalizePath(template.sampledPoints!!)

                
                                    template.directionVectors = calculateDirectionVectors(template.sampledPoints!!)

                
                                }

                
                

                
                                // SHAPE-FIRST scoring (simplified)

                
                                val shapeScore = calculateShapeScore(normalizedInput, template.normalizedPoints!!)

                
                                val locScore = calculateLocationScore(sampledInput, template.sampledPoints!!, template.sampledWeights)

                // Shape weight HIGH, location LOW (Gboard style)
                val integrationScore = (shapeScore * 1.5f) + (locScore * 0.3f)

                val rank = template.rank
                val freqBonus = 1.0f / (1.0f + 0.1f * ln((rank + 1).toFloat()))
                val contextBoost = getContextBoost(word)

                val finalScore = integrationScore * (1.0f - 0.3f * freqBonus) / contextBoost
                Pair(word, finalScore)
            }

        val topWord = scored.minByOrNull { it.second }?.first ?: return null
        
        return SwipeResult(
            word = topWord,
            source = PredictionSource.SHAPE_CONTEXT,
            confidence = 0.7f
        )
    }
    // =================================================================================
    // END BLOCK: decodeSwipeShapePreview
    // =================================================================================

    // =================================================================================
    // FUNCTION: learnKeyOffsets (Spatial Heatmap)
    // SUMMARY: Compares the actual swipe path to the ideal keys of the selected word.
    //          Calculates the offset (error) and updates the rolling average for those keys.
    //          Only learns from Start, End, and Sharp Turns to avoid noise.
    // =================================================================================

    private fun learnKeyOffsets(context: Context, word: String, path: List<TimedPoint>) {
        val keys = lastKeyMap ?: return
        val rawPath = path.map { it.toPointF() }
        
        // 1. Identify Key Points in Path (Start, End, Sharp Turns)
        // reusing extractPathKeys logic but getting POINTS, not letters
        val startPoint = rawPath.first()
        val endPoint = rawPath.last()
        
        // Simple Learning: Start -> First Letter, End -> Last Letter
        // We only learn if the user was "close enough" to be ambiguous (e.g. < 80px)
        
        val firstChar = word.first().toString().lowercase()
        val lastChar = word.last().toString().lowercase()
        
        val idealStart = keys[firstChar] ?: keys[firstChar.uppercase()]
        val idealEnd = keys[lastChar] ?: keys[lastChar.uppercase()]
        
        synchronized(keyOffsets) {
            var modified = false
            

            // Learn Start Offset
            if (idealStart != null) {
                val dx = startPoint.x - idealStart.x
                val dy = startPoint.y - idealStart.y
                val dist = hypot(dx, dy)
                
                android.util.Log.d("DroidOS_Heatmap", "Start Key '$firstChar': Offset $dist px (Limit: 150f)")

                // INCREASED LIMIT: 80f -> 150f for easier testing
                if (dist < 150f) {
                    val current = keyOffsets[firstChar] ?: PointF(0f, 0f)
                    // Learning Rate 0.1 (Slow adaptation)
                    current.x = current.x * 0.9f + dx * 0.1f
                    current.y = current.y * 0.9f + dy * 0.1f
                    keyOffsets[firstChar] = current
                    modified = true
                }
            }

            
            // Learn End Offset
            if (idealEnd != null) {
                val dx = endPoint.x - idealEnd.x
                val dy = endPoint.y - idealEnd.y
                if (hypot(dx, dy) < 80f) {
                    val current = keyOffsets[lastChar] ?: PointF(0f, 0f)
                    current.x = current.x * 0.9f + dx * 0.1f
                    current.y = current.y * 0.9f + dy * 0.1f
                    keyOffsets[lastChar] = current
                    modified = true
                }
            }
            
            if (modified) {
                saveKeyOffsets(context)
                templateCache.clear() // Clear cache so new offsets apply
                android.util.Log.d("DroidOS_Heatmap", "Updated offsets for $firstChar, $lastChar")
            }
        }
    }

    
    // Helper to load/save offsets
    private fun loadKeyOffsets(context: Context) {
        try {
            val file = java.io.File(context.filesDir, KEY_OFFSETS_FILE)
            if (file.exists()) {
                val json = org.json.JSONObject(file.readText())
                val keys = json.keys()
                while (keys.hasNext()) {
                    val key = keys.next()
                    val pos = json.getJSONObject(key)
                    keyOffsets[key] = PointF(pos.getDouble("x").toFloat(), pos.getDouble("y").toFloat())
                }
                android.util.Log.d("DroidOS_Heatmap", "Loaded offsets for ${keyOffsets.size} keys")
            }
        } catch (e: Exception) {
            android.util.Log.e("DroidOS_Heatmap", "Failed to load offsets", e)
        }
    }

    private fun saveKeyOffsets(context: Context) {
        try {
            val json = org.json.JSONObject()
            synchronized(keyOffsets) {
                for ((key, offset) in keyOffsets) {
                    val pos = org.json.JSONObject()
                    pos.put("x", offset.x)
                    pos.put("y", offset.y)
                    json.put(key, pos)
                }
            }
            java.io.File(context.filesDir, KEY_OFFSETS_FILE).writeText(json.toString())
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}
```

## File: Cover-Screen-Trackpad/app/src/main/res/layout/activity_main.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#121212"
    android:fillViewport="true">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="24dp"
        android:gravity="center_horizontal">

        <ImageView
            android:layout_width="80dp"
            android:layout_height="80dp"
            android:src="@mipmap/ic_trackpad_adaptive"
            android:layout_marginBottom="16dp"/>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="DroidOS Trackpad"
            android:textSize="28sp"
            android:textStyle="bold"
            android:textColor="#FFFFFF"
            android:layout_marginBottom="8dp" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Required Permissions"
            android:textSize="14sp"
            android:textColor="#AAAAAA"
            android:layout_marginBottom="30dp" />

        <!-- STEP 1: RESTRICTED SETTINGS -->
        <LinearLayout
            android:id="@+id/btn_fix_restricted"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:background="@drawable/bg_item_press"
            android:padding="16dp"
            android:layout_marginBottom="12dp"
            android:gravity="center_vertical"
            android:clickable="true"
            android:focusable="true">
            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:orientation="vertical">
                <TextView
                    android:id="@+id/text_restricted"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="1. Unlock Restrictions"
                    android:textColor="#FF9800"
                    android:textSize="16sp"
                    android:textStyle="bold"/>
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Tap  3-dots (top right)  Allow Restricted"
                    android:textColor="#888888"
                    android:textSize="12sp"/>
            </LinearLayout>
            <ImageView
                android:id="@+id/icon_restricted"
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@android:drawable/ic_menu_info_details"
                android:tint="#FF9800"/>
        </LinearLayout>

        <!-- STEP 2: ACCESSIBILITY -->
        <LinearLayout
            android:id="@+id/btn_open_accessibility"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:background="@drawable/bg_item_press"
            android:padding="16dp"
            android:layout_marginBottom="12dp"
            android:gravity="center_vertical"
            android:clickable="true"
            android:focusable="true">
            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:orientation="vertical">
                <TextView
                    android:id="@+id/text_accessibility"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="2. Accessibility Service"
                    android:textColor="#FFFFFF"
                    android:textSize="16sp"
                    android:textStyle="bold"/>
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Required for Cursor Control"
                    android:textColor="#888888"
                    android:textSize="12sp"/>
            </LinearLayout>
            <ImageView
                android:id="@+id/icon_accessibility"
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@android:drawable/checkbox_off_background"/>
        </LinearLayout>

        <!-- STEP 3: SHIZUKU -->
        <LinearLayout
            android:id="@+id/btn_start_check"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:background="@drawable/bg_item_press"
            android:padding="16dp"
            android:layout_marginBottom="32dp"
            android:gravity="center_vertical"
            android:clickable="true"
            android:focusable="true">
            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:orientation="vertical">
                <TextView
                    android:id="@+id/text_shizuku"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="3. Shizuku Access"
                    android:textColor="#FFFFFF"
                    android:textSize="16sp"
                    android:textStyle="bold"/>
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Required for Input Injection"
                    android:textColor="#888888"
                    android:textSize="12sp"/>
            </LinearLayout>
            <ImageView
                android:id="@+id/icon_shizuku"
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@android:drawable/checkbox_off_background"/>
        </LinearLayout>

        <Button
            android:id="@+id/btn_switch_display"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Grant Permissions First"
            android:backgroundTint="#00A0E9"
            android:textColor="#FFFFFF"
            android:padding="14dp"
            android:alpha="0.5"
            android:enabled="false"/>

    </LinearLayout>
</ScrollView>
```

## File: Cover-Screen-Launcher/app/src/main/java/com/example/quadrantlauncher/MainActivity.kt
```kotlin
package com.example.quadrantlauncher

import android.accessibilityservice.AccessibilityServiceInfo
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.provider.Settings
import android.util.Log
import android.view.accessibility.AccessibilityManager
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import rikka.shizuku.Shizuku

class MainActivity : AppCompatActivity() {

    companion object {
        const val SELECTED_APP_PACKAGE = "com.example.quadrantlauncher.SELECTED_APP_PACKAGE"
    }

    // === APP INFO DATA CLASS - START ===
    // Represents an installed app with package name, activity class, and state info
    // getIdentifier() returns a unique string for app identification including className when needed
    data class AppInfo(
        val label: String,
        val packageName: String,
        val className: String? = null,
        var isFavorite: Boolean = false,
        var isMinimized: Boolean = false
    ) {
        // Returns unique identifier for the app
        fun getIdentifier(): String {
            return if (!className.isNullOrEmpty() && packageName == "com.google.android.googlequicksearchbox") {
                if (className.lowercase().contains("assistant") || className.lowercase().contains("gemini")) {
                    "$packageName:gemini"
                } else {
                    packageName
                }
            } else {
                packageName
            }
        }
        
        // === GET BASE PACKAGE - START ===
        // Returns the base package name without any suffix
        // Use this for shell commands that need the actual Android package name
        fun getBasePackage(): String {
            return if (packageName.contains(":")) {
                packageName.substringBefore(":")
            } else {
                packageName
            }
        }
        // === GET BASE PACKAGE - END ===

        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other !is AppInfo) return false
            return packageName == other.packageName && className == other.className && label == other.label
        }

        override fun hashCode(): Int {
            var result = packageName.hashCode()
            result = 31 * result + (className?.hashCode() ?: 0)
            result = 31 * result + label.hashCode()
            return result
        }
    }
    // === APP INFO DATA CLASS - END ===

    /* * FUNCTION: onCreate
     * SUMMARY: Detects the display ID where the app icon was clicked and
     * passes it to the service to ensure the bubble follows the user.
     */
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // [SAFETY] PANIC RESET: Tap App Icon 3 times in 5 seconds to Reset
        val prefs = getSharedPreferences("PanicState", Context.MODE_PRIVATE)
        val now = System.currentTimeMillis()
        val lastLaunch = prefs.getLong("last_launch", 0)
        var count = prefs.getInt("launch_count", 0)

        if (now - lastLaunch < 5000) {
            count++
        } else {
            count = 1
        }

        // Use commit() for synchronous save
        prefs.edit().putLong("last_launch", now).putInt("launch_count", count).commit()

        if (count >= 3) {
            // VIBRATE ALERT
            val v = getSystemService(Context.VIBRATOR_SERVICE) as android.os.Vibrator
            if (Build.VERSION.SDK_INT >= 26) {
                v.vibrate(android.os.VibrationEffect.createOneShot(500, 255))
            } else {
                @Suppress("DEPRECATION") v.vibrate(500)
            }

            Toast.makeText(this, "!!! DROIDOS RESET !!!", Toast.LENGTH_LONG).show()

            // 1. Reset State
            prefs.edit().clear().commit()

            // 2. Kill Service via Intent
            val stopIntent = Intent(this, FloatingLauncherService::class.java)
            stopService(stopIntent)

            // 3. Force Kill Process
            android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
                android.os.Process.killProcess(android.os.Process.myPid())
                System.exit(0)
            }, 500)

            finish()
            return
        }

        // [NEW] Wallpaper Mode for Virtual Displays
        // Used as a "Desktop Background" to hold focus when apps are minimized.
        if (intent.getBooleanExtra("WALLPAPER_MODE", false)) {
            val view = android.view.View(this)
            view.setBackgroundColor(android.graphics.Color.BLACK)
            
            // SAFETY 1: Close immediately if tapped (Fail-safe)
            view.setOnClickListener { finish() }
            
            // SAFETY 2: Close immediately if we land on a Physical Display (0 or 1)
            // This handles cases where Android moves the activity when glasses are unplugged.
            val checkDisplay = {
                val currentDisplay = display // Capture 'this.display' into a local variable
                if (currentDisplay != null && currentDisplay.displayId < 2) {
                    android.util.Log.i("DroidOS", "Wallpaper landed on Display ${currentDisplay.displayId} - Self Destructing")
                    finish()
                }
            }

            // Check on load
            checkDisplay()
            
            // Check whenever window focus changes (e.g. display move)
            view.viewTreeObserver.addOnWindowFocusChangeListener { hasFocus ->
                if (hasFocus) {
                    checkDisplay()
                }
            }
            
            setContentView(view)
            return
        }

        // Redirect to PermissionActivity if essential permissions are missing
        if (!hasAllPermissions()) {
            val intent = Intent(this, PermissionActivity::class.java)
            intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
            startActivity(intent)
            finish()
            return
        }

        // Determine which display this activity is running on
        val displayId = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            this.display?.displayId ?: 0
        } else {
            @Suppress("DEPRECATION")
            windowManager.defaultDisplay.displayId
        }

        Log.d("DroidOS_Main", "Launched on Display $displayId")

        // Start service and pass the current display ID to recall the bubble
        val serviceIntent = Intent(this, FloatingLauncherService::class.java)
        serviceIntent.putExtra("DISPLAY_ID", displayId)
        startService(serviceIntent)

        // Finish immediately so the launcher remains a service-only overlay
        finish()
    }

    private fun hasAllPermissions(): Boolean {
        // 1. Overlay
        if (!Settings.canDrawOverlays(this)) return false

        // 2. Shizuku
        val shizukuGranted = try {
            Shizuku.checkSelfPermission() == PackageManager.PERMISSION_GRANTED
        } catch (e: Exception) {
            false
        }
        if (!shizukuGranted) return false

        // 3. Accessibility
        if (!isAccessibilityServiceEnabled(this, FloatingLauncherService::class.java)) return false

        // 4. Notifications removed (Not strictly required for service to run)

        return true
    }

    private fun isAccessibilityServiceEnabled(context: Context, service: Class<*>): Boolean {
        val am = context.getSystemService(Context.ACCESSIBILITY_SERVICE) as AccessibilityManager
        val enabledServices = am.getEnabledAccessibilityServiceList(AccessibilityServiceInfo.FEEDBACK_ALL_MASK)
        for (enabledService in enabledServices) {
            val serviceInfo = enabledService.resolveInfo.serviceInfo
            if (serviceInfo.packageName == context.packageName && serviceInfo.name == service.name) {
                return true
            }
        }
        return false
    }
}
```

## File: Cover-Screen-Launcher/app/src/main/java/com/example/quadrantlauncher/PermissionActivity.kt
```kotlin
package com.example.quadrantlauncher

import android.accessibilityservice.AccessibilityServiceInfo
import android.app.Activity
import android.app.AlertDialog
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.graphics.Color
import android.net.Uri
import android.os.Bundle
import android.provider.Settings
import android.view.accessibility.AccessibilityManager
import android.widget.Button
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.TextView
import android.widget.Toast
import rikka.shizuku.Shizuku

class PermissionActivity : Activity(), Shizuku.OnRequestPermissionResultListener {

    private lateinit var btnGrantOverlay: LinearLayout
    private lateinit var btnGrantRestricted: LinearLayout  // NEW: App Info button
    private lateinit var btnGrantShizuku: LinearLayout
    private lateinit var btnGrantAccessibility: LinearLayout
    
    private lateinit var iconOverlay: ImageView
    private lateinit var iconRestricted: ImageView  // NEW: Restricted settings icon
    private lateinit var iconShizuku: ImageView
    private lateinit var iconAccessibility: ImageView
    
    private lateinit var btnContinue: Button

    private val uiHandler = android.os.Handler(android.os.Looper.getMainLooper())
    private val statusChecker = object : Runnable {
        override fun run() {
            refreshUI()
            uiHandler.postDelayed(this, 500)
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_permissions)

        // Bind Views
        btnGrantOverlay = findViewById(R.id.btn_perm_overlay)
        btnGrantRestricted = findViewById(R.id.btn_perm_restricted)  // NEW
        btnGrantShizuku = findViewById(R.id.btn_perm_shizuku)
        btnGrantAccessibility = findViewById(R.id.btn_perm_accessibility)
        
        iconOverlay = findViewById(R.id.icon_status_overlay)
        iconRestricted = findViewById(R.id.icon_status_restricted)  // NEW
        iconShizuku = findViewById(R.id.icon_status_shizuku)
        iconAccessibility = findViewById(R.id.icon_status_accessibility)
        
        btnContinue = findViewById(R.id.btn_continue)

        // --- 1. OVERLAY PERMISSION ---
        btnGrantOverlay.setOnClickListener {
            val intent = Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse("package:$packageName"))
            startActivityForResult(intent, 101)
        }

        // =======================================================================
        // BUTTON: App Info / Restricted Settings
        // SUMMARY: Opens the App Info page where the user can tap the 3-dot
        //          hamburger menu (top right) and select "Allow Restricted Settings".
        //          This is required on Android 13+ for sideloaded APKs to enable
        //          accessibility services.
        // =======================================================================
        btnGrantRestricted.setOnClickListener {
            try {
                val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
                intent.data = Uri.parse("package:$packageName")
                startActivity(intent)
                Toast.makeText(
                    this,
                    "Tap  menu (top right)  'Allow Restricted Settings'",
                    Toast.LENGTH_LONG
                ).show()
            } catch (e: Exception) {
                Toast.makeText(this, "Could not open App Info", Toast.LENGTH_SHORT).show()
            }
        }
        // =======================================================================
        // END BUTTON: App Info / Restricted Settings
        // =======================================================================

        // --- 2. SHIZUKU PERMISSION ---
        btnGrantShizuku.setOnClickListener {
            try {
                if (Shizuku.checkSelfPermission() != PackageManager.PERMISSION_GRANTED) {
                    Shizuku.requestPermission(0)
                } else {
                    Toast.makeText(this, "Shizuku already granted", Toast.LENGTH_SHORT).show()
                    refreshUI()
                }
            } catch (e: Exception) {
                Toast.makeText(this, "Shizuku not running. Please start Shizuku first.", Toast.LENGTH_LONG).show()
            }
        }

        // --- 3. ACCESSIBILITY PERMISSION (With Disclosure) ---
        btnGrantAccessibility.setOnClickListener {
            showAccessibilityDisclosure()
        }

        btnContinue.setOnClickListener {
            if (hasAllPermissions()) {
                startActivity(Intent(this, MenuActivity::class.java))
                finish()
            }
        }

        Shizuku.addRequestPermissionResultListener(this)
    }

    private fun showAccessibilityDisclosure() {
        AlertDialog.Builder(this, android.R.style.Theme_DeviceDefault_Dialog_Alert)
            .setTitle("Accessibility Service Required")
            .setMessage("This app uses the Accessibility Service API to display floating windows and perform global actions (like Home/Back) on top of other apps.\n\n" +
                        "No data is collected, stored, or shared. This permission is strictly used for the launcher functionality.")
            .setPositiveButton("Agree & Grant") { _, _ ->
                val intent = Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS)
                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
                startActivity(intent)
                Toast.makeText(this, "Find 'Quadrant Launcher' and enable it", Toast.LENGTH_LONG).show()
            }
            .setNegativeButton("Not Now", null)
            .show()
    }

    override fun onResume() {
        super.onResume()
        refreshUI()
        uiHandler.post(statusChecker) // Start polling
    }

    override fun onPause() {
        super.onPause()
        uiHandler.removeCallbacks(statusChecker) // Stop polling
    }

    override fun onDestroy() {
        super.onDestroy()
        uiHandler.removeCallbacks(statusChecker)
        Shizuku.removeRequestPermissionResultListener(this)
    }

    override fun onRequestPermissionResult(requestCode: Int, grantResult: Int) {
        refreshUI()
    }

    private fun refreshUI() {
        val hasOverlay = Settings.canDrawOverlays(this)
        val hasShizuku = try { Shizuku.checkSelfPermission() == PackageManager.PERMISSION_GRANTED } catch(e: Exception) { false }
        val hasAccessibility = isAccessibilityServiceEnabled(this, FloatingLauncherService::class.java)
        
        // 1. Restricted Settings (Implicit check: if accessibility is on, restricted is done)
        if (hasAccessibility) {
            updateItem(btnGrantRestricted, iconRestricted, true)
            iconRestricted.setColorFilter(Color.GREEN)
        } else {
            // Can't check explicitly, so we leave it clickable but don't mark green
            updateItem(btnGrantRestricted, iconRestricted, false)
        }

        // 2. Overlay
        updateItem(btnGrantOverlay, iconOverlay, hasOverlay)
        
        // 3. Accessibility
        updateItem(btnGrantAccessibility, iconAccessibility, hasAccessibility)
        
        // 4. Shizuku
        updateItem(btnGrantShizuku, iconShizuku, hasShizuku)

        // ENABLE BUTTON LOGIC
        if (hasOverlay && hasShizuku && hasAccessibility) {
            btnContinue.isEnabled = true
            btnContinue.alpha = 1.0f
            btnContinue.text = "LAUNCH DROIDOS"
            btnContinue.backgroundTintList = android.content.res.ColorStateList.valueOf(Color.parseColor("#3DDC84"))
        } else {
            btnContinue.isEnabled = false
            btnContinue.alpha = 0.5f
            
            // Helpful text based on what is missing
            btnContinue.text = when {
                !hasOverlay -> "Step 2: Enable Overlay"
                !hasAccessibility -> "Step 3: Enable Accessibility"
                !hasShizuku -> "Step 4: Grant Shizuku"
                else -> "Grant Permissions to Continue"
            }
        }
    }

    private fun updateItem(container: LinearLayout, icon: ImageView, granted: Boolean) {
        if (granted) {
            icon.setImageResource(android.R.drawable.checkbox_on_background)
            icon.setColorFilter(Color.GREEN)
            container.isClickable = false
            container.alpha = 0.6f
        } else {
            icon.setImageResource(android.R.drawable.checkbox_off_background)
            icon.setColorFilter(Color.RED)
            container.isClickable = true
            container.alpha = 1.0f
        }
    }

    private fun hasAllPermissions(): Boolean {
        val hasOverlay = Settings.canDrawOverlays(this)
        val hasShizuku = try { Shizuku.checkSelfPermission() == PackageManager.PERMISSION_GRANTED } catch(e: Exception) { false }
        val hasAccessibility = isAccessibilityServiceEnabled(this, FloatingLauncherService::class.java)
        return hasOverlay && hasShizuku && hasAccessibility
    }

    private fun isAccessibilityServiceEnabled(context: Context, service: Class<*>): Boolean {
        try {
            val expectedComponentName = android.content.ComponentName(context, service)
            val enabledServicesSetting = Settings.Secure.getString(
                context.contentResolver,
                Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES
            ) ?: return false
            
            val stringSplitter = android.text.TextUtils.SimpleStringSplitter(':')
            stringSplitter.setString(enabledServicesSetting)
            
            while (stringSplitter.hasNext()) {
                val componentNameString = stringSplitter.next()
                val enabledComponent = android.content.ComponentName.unflattenFromString(componentNameString)
                if (enabledComponent != null && enabledComponent == expectedComponentName) return true
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
        return false
    }
}
```

## File: Cover-Screen-Launcher/app/src/main/res/layout/layout_rofi_drawer.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#80000000"
    android:clickable="true"
    android:focusable="true"
    android:filterTouchesWhenObscured="false">

    <LinearLayout
        android:id="@+id/drawer_container"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:orientation="vertical"
        android:padding="12dp"
        android:background="@drawable/bg_drawer"
        android:elevation="10dp"
        android:clickable="true"
        android:focusable="true"
        android:filterTouchesWhenObscured="false">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical">

            <ImageView
                android:id="@+id/icon_search_mode"
                android:layout_width="32dp"
                android:layout_height="32dp"
                android:padding="6dp"
                android:src="@android:drawable/ic_menu_search"
                android:tint="#AAAAAA"
                android:background="@drawable/bg_item_press"
                android:tooltipText="App List"/>

            <EditText
                android:id="@+id/rofi_search_bar"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="@null"
                android:hint="Search apps..."
                android:textColor="#FFFFFF"
                android:textColorHint="#666666"
                android:paddingStart="8dp"
                android:paddingEnd="8dp"
                android:singleLine="true"
                android:textSize="16sp"
                android:imeOptions="actionDone"/>

            <ImageView
                android:id="@+id/icon_execute"
                android:layout_width="32dp"
                android:layout_height="32dp"
                android:padding="6dp"
                android:src="@android:drawable/ic_media_play"
                android:tint="#00FF00"
                android:background="@drawable/bg_item_press"
                android:tooltipText="Launch"/>

            <ImageView
                android:id="@+id/icon_mode_window"
                android:layout_width="32dp"
                android:layout_height="32dp"
                android:padding="6dp"
                android:src="@drawable/ic_window_split" 
                android:tint="#AAAAAA"
                android:background="@drawable/bg_item_press"
                android:tooltipText="Layouts"/>

            <ImageView
                android:id="@+id/icon_mode_resolution"
                android:layout_width="32dp"
                android:layout_height="32dp"
                android:padding="6dp"
                android:src="@drawable/ic_mode_resolution"
                android:tint="#AAAAAA"
                android:background="@drawable/bg_item_press"
                android:tooltipText="Resolution"/>

            <ImageView
                android:id="@+id/icon_mode_refresh"
                android:layout_width="32dp"
                android:layout_height="32dp"
                android:padding="6dp"
                android:src="@android:drawable/ic_popup_sync"
                android:tint="#AAAAAA"
                android:background="@drawable/bg_item_press"
                android:tooltipText="Refresh Rate"/>

            <ImageView
                android:id="@+id/icon_mode_dpi"
                android:layout_width="32dp"
                android:layout_height="32dp"
                android:padding="6dp"
                android:src="@drawable/ic_mode_dpi"
                android:tint="#AAAAAA"
                android:background="@drawable/bg_item_press"
                android:tooltipText="DPI"/>

            <!-- BLACKLIST MODE ICON - START -->
            <!-- Icon for accessing blacklist management tab -->
            <ImageView
                android:id="@+id/icon_mode_blacklist"
                android:layout_width="32dp"
                android:layout_height="32dp"
                android:padding="6dp"
                android:src="@android:drawable/ic_menu_close_clear_cancel" 
                android:tint="#AAAAAA"
                android:background="@drawable/bg_item_press"
                android:tooltipText="Blacklist"/>
            <!-- BLACKLIST MODE ICON - END -->

            <ImageView
                android:id="@+id/icon_mode_profiles"
                android:layout_width="32dp"
                android:layout_height="32dp"
                android:padding="6dp"
                android:src="@drawable/ic_mode_profiles"
                android:tint="#AAAAAA"
                android:background="@drawable/bg_item_press"
                android:tooltipText="Profiles"/>

            <ImageView
                android:id="@+id/icon_mode_keybinds"
                android:layout_width="32dp"
                android:layout_height="32dp"
                android:padding="6dp"
                android:src="@drawable/ic_mode_keybinds"
                android:tint="#AAAAAA"
                android:background="@drawable/bg_item_press"
                android:tooltipText="Keybinds"/>

            <ImageView
                android:id="@+id/icon_mode_settings"
                android:layout_width="32dp"
                android:layout_height="32dp"
                android:padding="6dp"
                android:src="@android:drawable/ic_menu_preferences"
                android:tint="#AAAAAA"
                android:background="@drawable/bg_item_press"
                android:tooltipText="Settings"/>
        </LinearLayout>

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/selected_apps_recycler"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:minHeight="50dp"
            android:paddingTop="4dp"
            android:paddingBottom="4dp"
            android:visibility="gone"/>

        <View
            android:layout_width="match_parent"
            android:layout_height="1dp"
            android:layout_marginTop="4dp"
            android:layout_marginBottom="8dp"
            android:background="#444444" />

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/rofi_recycler_view"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1"
            android:scrollbars="vertical" />

    </LinearLayout>
</FrameLayout>
```

## File: .gitignore
```
# Ignore Python Virtual Environment
DroidOS/bin/
DroidOS/lib/
DroidOS/lib64/
DroidOS/include/
DroidOS/share/
DroidOS/pyvenv.cfg
__pycache__/
*.pyc
gemini.md
restore_source.md
fix_git_commit.md

# --- AI Workflow Tools ---
architect.py
builder.py
restore.py

# --- Temporary Plan Files ---
plan.md
GEMINI.md
restore.py.md
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/TrackpadMenuManager.kt
```kotlin
package com.example.coverscreentester

import android.content.Context
import android.graphics.PixelFormat
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.WindowManager
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import android.graphics.Color
import android.view.ViewGroup
import android.view.MotionEvent
import java.util.ArrayList

class TrackpadMenuManager(
    private val context: Context,
    private val windowManager: WindowManager,
    private val service: OverlayService
) {
    private var drawerView: View? = null
    private var recyclerView: RecyclerView? = null
    private var drawerParams: WindowManager.LayoutParams? = null
    private var isVisible = false
    
    // Manual Adjust State
    private var isResizeMode = false // Default to Move Mode

    // Tab Constants - Order must match layout_trackpad_drawer.xml tab order
    private val TAB_MAIN = 0
    private val TAB_PRESETS = 1
    private val TAB_MOVE = 2
    private val TAB_KB_MOVE = 3
    private val TAB_MIRROR = 4      // NEW: Mirror keyboard config
    private val TAB_CONFIG = 5
    private val TAB_TUNE = 6
    private val TAB_HARDKEYS = 7
    private val TAB_BUBBLE = 8
    private val TAB_PROFILES = 9
    private val TAB_HELP = 10
    
    private var currentTab = TAB_MAIN
    
    // [NEW] Debug Trigger Vars
    private var helpClickCount = 0
    private var lastHelpClickTime = 0L

    fun show() {
        if (isVisible) return
        if (drawerView == null) setupDrawer()
        try {
            windowManager.addView(drawerView, drawerParams)
            isVisible = true
            loadTab(currentTab)
            
            // CRITICAL FIX: Force Cursor and Bubble to top of stack
            // Since Menu was just added, it is currently on top. 
            // We must re-add the others to cover it.
            service.enforceZOrder()
            
        } catch (e: SecurityException) {
            android.widget.Toast.makeText(context, "Missing Overlay Permission! Open App to Fix.", android.widget.Toast.LENGTH_LONG).show()
            e.printStackTrace()
        } catch (e: Exception) { 
            e.printStackTrace() 
        }
    }

    fun hide() {
        if (!isVisible) return
        try {
            windowManager.removeView(drawerView)
            isVisible = false
        } catch (e: Exception) { }
    }


    // [FIXED] Refresh the current tab to update UI text (e.g. "Restore Target: Gboard")
    fun refresh() {
        if (drawerView != null) {
            // Reload the currently open tab to refresh item text
            loadTab(currentTab)
        }
    }

    fun toggle() {
        if (isVisible) hide() else show()
    }
    
    // NEW: Helper to receive forwarded touches from overlay
    fun dispatchTouchToView(event: MotionEvent): Boolean {
        if (!isVisible || drawerView == null) return false
        
        val view = drawerView!!
        val loc = IntArray(2)
        view.getLocationOnScreen(loc)
        val x = loc[0].toFloat()
        val y = loc[1].toFloat()
        
        // Check bounds
        if (event.rawX >= x && event.rawX <= x + view.width && 
            event.rawY >= y && event.rawY <= y + view.height) {
            
            event.offsetLocation(-x, -y)
            val handled = view.dispatchTouchEvent(event)
            event.offsetLocation(x, y) // Restore for caller
            return handled
        }
        return false
    }

    fun bringToFront() {
        if (!isVisible || drawerView == null) return
        try {
            // Detach and Re-attach to move to top of Z-Order stack
            windowManager.removeView(drawerView)
            windowManager.addView(drawerView, drawerParams)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun setupDrawer() {
        // Use ContextWrapper to ensure correct theme (Matches Launcher)
        val themedContext = android.view.ContextThemeWrapper(context, R.style.Theme_CoverScreenTester)
        val inflater = LayoutInflater.from(themedContext)
        drawerView = inflater.inflate(R.layout.layout_trackpad_drawer, null)

        // FUNCTION: Force Tab Icons
        // Manually set the Mirror Tab icon to the new custom asset
        drawerView?.findViewById<ImageView>(R.id.tab_mirror)?.setImageResource(R.drawable.mirrorkb)

        // Close button logic
        drawerView?.findViewById<View>(R.id.btn_close_menu)?.setOnClickListener { hide() }
        
        recyclerView = drawerView?.findViewById(R.id.menu_recycler)
        recyclerView?.layoutManager = LinearLayoutManager(context)

        // Tab click listeners
        val tabs = listOf(
            R.id.tab_main to TAB_MAIN,
            R.id.tab_presets to TAB_PRESETS,
            R.id.tab_move to TAB_MOVE,
            R.id.tab_kb_move to TAB_KB_MOVE,
            R.id.tab_mirror to TAB_MIRROR,      // NEW
            R.id.tab_config to TAB_CONFIG,
            R.id.tab_tune to TAB_TUNE,
            R.id.tab_hardkeys to TAB_HARDKEYS,
            R.id.tab_bubble to TAB_BUBBLE,
            R.id.tab_profiles to TAB_PROFILES,
            R.id.tab_help to TAB_HELP
        )

        for ((id, index) in tabs) {
            drawerView?.findViewById<ImageView>(id)?.setOnClickListener { 
                // [FIX] INSTRUCTIONS TAB - DEBUG TRIGGER (5 Clicks)
                if (id == R.id.tab_help) {
                    val now = System.currentTimeMillis()
                    if (now - lastHelpClickTime < 500) {
                        helpClickCount++
                    } else {
                        helpClickCount = 1
                    }
                    lastHelpClickTime = now

                    if (helpClickCount >= 5) {
                        // Toggle debug mode in the main Service
                        service.toggleDebugMode()
                        helpClickCount = 0
                    }
                }
                
                loadTab(index) 
            }
        }

        // =========================
        // WINDOW CONFIG (MATCHING DROIDOS LAUNCHER)
        // =========================
        drawerParams = WindowManager.LayoutParams(
            WindowManager.LayoutParams.WRAP_CONTENT, 
            WindowManager.LayoutParams.WRAP_CONTENT,
            WindowManager.LayoutParams.TYPE_ACCESSIBILITY_OVERLAY, 
            WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or 
            WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL, 
            PixelFormat.TRANSLUCENT
        )
        // Explicitly set Gravity to TOP|START for absolute positioning
        drawerParams?.gravity = Gravity.TOP or Gravity.START
        
        // Initial Center Calculation
        val metrics = context.resources.displayMetrics
        val screenWidth = metrics.widthPixels
        val screenHeight = metrics.heightPixels
        
        // Approx Menu Size (320dp width + margins, ~400dp height)
        val density = metrics.density
        val menuW = (360 * density).toInt() 
        val menuH = (400 * density).toInt()
        
        drawerParams?.x = (screenWidth - menuW) / 2
        drawerParams?.y = (screenHeight - menuH) / 2
        
        // =========================
        // INTERACTION LOGIC
        // =========================
        // 1. Background Click -> Removed (Handled by FLAG_NOT_TOUCH_MODAL)
        
        // 2. Menu Card Click -> Block (Consume)
        drawerView?.findViewById<View>(R.id.menu_container)?.setOnClickListener { 
            // Do nothing
        }
        
        // 3. DRAG HANDLE LOGIC
        val dragHandle = drawerView?.findViewById<View>(R.id.menu_drag_handle)
        var initialX = 0
        var initialY = 0
        var initialTouchX = 0f
        var initialTouchY = 0f

        dragHandle?.setOnTouchListener { v, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    initialX = drawerParams!!.x
                    initialY = drawerParams!!.y
                    initialTouchX = event.rawX
                    initialTouchY = event.rawY
                    true
                }
                MotionEvent.ACTION_MOVE -> {
                    drawerParams!!.x = initialX + (event.rawX - initialTouchX).toInt()
                    drawerParams!!.y = initialY + (event.rawY - initialTouchY).toInt()
                    
                    try {
                        windowManager.updateViewLayout(drawerView, drawerParams)
                    } catch (e: Exception) {}
                    true
                }
                else -> false
            }
        }
    }

    private fun loadTab(index: Int) {
        currentTab = index
        updateTabIcons(index)
        
        val items = when(index) {
            TAB_MAIN -> getMainItems()
            TAB_PRESETS -> getPresetItems()
            TAB_MOVE -> getMoveItems(false)
            TAB_KB_MOVE -> getMoveItems(true)
            TAB_MIRROR -> getMirrorItems()      // NEW
            TAB_CONFIG -> getConfigItems()
            TAB_TUNE -> getTuneItems()
            TAB_HARDKEYS -> getHardkeyItems()   // Hardkey bindings configuration
            TAB_BUBBLE -> getBubbleItems()
            TAB_PROFILES -> getProfileItems()
            TAB_HELP -> getHelpItems()
            else -> emptyList()
        }
        
        recyclerView?.adapter = TrackpadMenuAdapter(items)
    }

    private fun updateTabIcons(activeIdx: Int) {
        val tabIds = listOf(R.id.tab_main, R.id.tab_presets, R.id.tab_move, R.id.tab_kb_move, R.id.tab_mirror, R.id.tab_config, R.id.tab_tune, R.id.tab_hardkeys, R.id.tab_bubble, R.id.tab_profiles, R.id.tab_help)
        for ((i, id) in tabIds.withIndex()) {
            val view = drawerView?.findViewById<ImageView>(id)
            if (i == activeIdx) view?.setColorFilter(Color.parseColor("#3DDC84")) 
            else view?.setColorFilter(Color.GRAY)
        }
    }

    // =========================
    // GET MAIN ITEMS - Generates main menu items list
    // =========================
    private fun getMainItems(): List<TrackpadMenuAdapter.MenuItem> {
        val list = ArrayList<TrackpadMenuAdapter.MenuItem>()
        val p = service.prefs
        
        list.add(TrackpadMenuAdapter.MenuItem("MAIN CONTROLS", 0, TrackpadMenuAdapter.Type.HEADER))
        
        // --- COMMENTED OUT PER REQUEST ---
        /*
        list.add(TrackpadMenuAdapter.MenuItem("Switch Screen (0 <-> 1)", android.R.drawable.ic_menu_rotate, TrackpadMenuAdapter.Type.ACTION) { 
            service.switchDisplay() 
            hide()
        })
        */
        // ---------------------------------

        list.add(TrackpadMenuAdapter.MenuItem("Reset Bubble Position", android.R.drawable.ic_menu_myplaces, TrackpadMenuAdapter.Type.ACTION) { 
            service.resetBubblePosition()
            hide()
        })
        
        // --- COMMENTED OUT PER REQUEST ---
        /*
        list.add(TrackpadMenuAdapter.MenuItem("Move Trackpad Here", R.drawable.ic_tab_move, TrackpadMenuAdapter.Type.ACTION) { service.forceMoveToCurrentDisplay(); hide() })
        */
        
        // Renamed: "Target: ..." -> "Toggle Remote Display"
        list.add(TrackpadMenuAdapter.MenuItem("Toggle Remote Display", R.drawable.ic_cursor, TrackpadMenuAdapter.Type.ACTION) { service.cycleInputTarget(); loadTab(TAB_MAIN) })

        // =================================================================================
        // VIRTUAL MIRROR MODE TOGGLE
        // SUMMARY: Enhanced toggle for AR glasses/remote displays.
        //          When enabled:
        //          - Auto-switches cursor to virtual display
        //          - Shows keyboard and trackpad
        //          - Loads mirror-mode specific profile
        //          When disabled:
        //          - Returns to local display
        //          - Restores previous visibility state
        //          - Saves/loads separate profile
        // =================================================================================
        // FUNCTION: Virtual Mirror Toggle
        // Updated to use R.drawable.mirrorkb
        list.add(TrackpadMenuAdapter.MenuItem(
            "Virtual Mirror Mode",
            R.drawable.mirrorkb,
            TrackpadMenuAdapter.Type.TOGGLE,
            if(p.prefVirtualMirrorMode) 1 else 0
        ) { _ ->
            service.toggleVirtualMirrorMode()
            hide()  // Close menu since display context may change
        })
        // =================================================================================
        // END BLOCK: VIRTUAL MIRROR MODE TOGGLE
        // =================================================================================

        // --- ANCHOR TOGGLE: Locks trackpad and keyboard position/size ---
        list.add(TrackpadMenuAdapter.MenuItem("Anchor (Lock Position)", 
            if(p.prefAnchored) R.drawable.ic_lock_closed else R.drawable.ic_lock_open, 
            TrackpadMenuAdapter.Type.TOGGLE, 
            if(p.prefAnchored) 1 else 0) { v ->
            service.updatePref("anchored", v)
            loadTab(TAB_MAIN)  // Refresh to update icon
        })
        // --- END ANCHOR TOGGLE ---
        
        // Toggle Trackpad (Using correct icon
        // Toggle Trackpad
        list.add(TrackpadMenuAdapter.MenuItem("Toggle Trackpad", R.drawable.ic_cursor, TrackpadMenuAdapter.Type.ACTION) {
            service.toggleTrackpad()
            hide()
        })


        list.add(TrackpadMenuAdapter.MenuItem("Toggle Keyboard", R.drawable.ic_tab_keyboard, TrackpadMenuAdapter.Type.ACTION) { 
            if (service.isCustomKeyboardVisible) service.performSmartHide()
            else service.toggleCustomKeyboard()
        })
        list.add(TrackpadMenuAdapter.MenuItem("Reset Cursor", android.R.drawable.ic_menu_rotate, TrackpadMenuAdapter.Type.ACTION) { service.resetCursorCenter() })
        
        // Renamed: "Hide App" -> "Hide All"
        list.add(TrackpadMenuAdapter.MenuItem("Hide All", android.R.drawable.ic_menu_close_clear_cancel, TrackpadMenuAdapter.Type.ACTION) { service.hideApp() })
        
        // Renamed: "Force Kill Service" -> "Close/Restart App"
        list.add(TrackpadMenuAdapter.MenuItem("Close/Restart App", android.R.drawable.ic_delete, TrackpadMenuAdapter.Type.ACTION) { service.forceExit() })
        return list
    }
    // =========================
    // END GET MAIN ITEMS
    // =========================


    
// =========================
    // GET PRESET ITEMS - Layout presets for split screen modes
    // Freeform (type 0) loads saved profile, NOT a split preset
    // =========================
    private fun getPresetItems(): List<TrackpadMenuAdapter.MenuItem> {
        val list = ArrayList<TrackpadMenuAdapter.MenuItem>()
        list.add(TrackpadMenuAdapter.MenuItem("SPLIT SCREEN PRESETS", 0, TrackpadMenuAdapter.Type.HEADER))
        
        // Freeform FIRST - this loads the saved profile (not a split preset)
        list.add(TrackpadMenuAdapter.MenuItem("Freeform (Use Profile)", android.R.drawable.ic_menu_edit, TrackpadMenuAdapter.Type.ACTION) { 
            service.applyLayoutPreset(0)
            hide()
        })
        
        list.add(TrackpadMenuAdapter.MenuItem("KB Top / TP Bottom", R.drawable.ic_tab_keyboard, TrackpadMenuAdapter.Type.ACTION) { 
            service.applyLayoutPreset(1)
            hide()
        })
        list.add(TrackpadMenuAdapter.MenuItem("TP Top / KB Bottom", R.drawable.ic_tab_move, TrackpadMenuAdapter.Type.ACTION) { 
            service.applyLayoutPreset(2)
            hide()
        })
        return list
    }
    // =========================
    // END GET PRESET ITEMS
    // =========================
    private fun getMoveItems(isKeyboard: Boolean): List<TrackpadMenuAdapter.MenuItem> {
        val list = ArrayList<TrackpadMenuAdapter.MenuItem>()
        val target = if (isKeyboard) "Keyboard" else "Trackpad"
        
        list.add(TrackpadMenuAdapter.MenuItem(if (isKeyboard) "KEYBOARD POSITION" else "TRACKPAD POSITION", 0, TrackpadMenuAdapter.Type.HEADER))
        
        // 1. Mode Switcher (Toggle Item)
        val modeText = if (isResizeMode) "Resize (Size)" else "Position (Move)"
        val modeIcon = if (isResizeMode) android.R.drawable.ic_menu_crop else android.R.drawable.ic_menu_mylocation
        
        list.add(TrackpadMenuAdapter.MenuItem("Mode: $modeText", modeIcon, TrackpadMenuAdapter.Type.ACTION) {
            isResizeMode = !isResizeMode
            loadTab(currentTab) // Refresh UI to update text
        })
        
        // 2. The D-Pad
        val actionText = if (isResizeMode) "Resize" else "Move"
        list.add(TrackpadMenuAdapter.MenuItem("$target $actionText", R.drawable.ic_tab_move, TrackpadMenuAdapter.Type.DPAD) { cmd ->
            val step = 20
            val command = cmd as String
            
            // isResizeMode determines whether we move X/Y or change W/H
            when(command) {
                "UP" -> service.manualAdjust(isKeyboard, isResizeMode, 0, -step)
                "DOWN" -> service.manualAdjust(isKeyboard, isResizeMode, 0, step)
                "LEFT" -> service.manualAdjust(isKeyboard, isResizeMode, -step, 0)
                "RIGHT" -> service.manualAdjust(isKeyboard, isResizeMode, step, 0)
                "CENTER" -> {
                    if (isKeyboard) service.resetKeyboardPosition() else service.resetTrackpadPosition()
                }
            }
        })
        
        list.add(TrackpadMenuAdapter.MenuItem("Rotate 90", android.R.drawable.ic_menu_rotate, TrackpadMenuAdapter.Type.ACTION) {
            if (isKeyboard) service.rotateKeyboard() else service.performRotation()
        })
            
        if (isKeyboard) {
            val p = service.prefs
            list.add(TrackpadMenuAdapter.MenuItem("Keyboard Opacity", R.drawable.ic_tab_tune, TrackpadMenuAdapter.Type.SLIDER, p.prefKeyboardAlpha) { v ->
                service.updatePref("keyboard_alpha", v)
            })
        }
            
        return list
    }

    // =========================
    // GET MIRROR ITEMS - Mirror keyboard configuration
    // =========================
    private var isMirrorResizeMode = false
    

    private fun getMirrorItems(): List<TrackpadMenuAdapter.MenuItem> {
        val list = ArrayList<TrackpadMenuAdapter.MenuItem>()
        val p = service.prefs
        
        list.add(TrackpadMenuAdapter.MenuItem("MIRROR KEYBOARD", 0, TrackpadMenuAdapter.Type.HEADER))
        
        // [REMOVED] Virtual Mirror Mode Toggle (Redundant)
        
        list.add(TrackpadMenuAdapter.MenuItem("POSITION & SIZE", 0, TrackpadMenuAdapter.Type.SUBHEADER))
        
        // Mode Switcher (Position vs Resize)
        val modeText = if (isMirrorResizeMode) "Resize (Size)" else "Position (Move)"
        val modeIcon = if (isMirrorResizeMode) android.R.drawable.ic_menu_crop else android.R.drawable.ic_menu_mylocation
        
        list.add(TrackpadMenuAdapter.MenuItem("Mode: $modeText", modeIcon, TrackpadMenuAdapter.Type.ACTION) {
            isMirrorResizeMode = !isMirrorResizeMode
            loadTab(currentTab) // Refresh UI
        })
        
        // D-Pad for position/size
        val actionText = if (isMirrorResizeMode) "Resize" else "Move"
        list.add(TrackpadMenuAdapter.MenuItem("Mirror $actionText", R.drawable.ic_tab_move, TrackpadMenuAdapter.Type.DPAD) { cmd ->
            val step = 20
            val command = cmd as String
            


// =================================================================================
            // MIRROR KEYBOARD DPAD CONTROLS  
            // MOVE MODE: UP = move up, DOWN = move down (intuitive)
            // RESIZE MODE: UP = grow taller, DOWN = shrink shorter (like dragging bottom edge)
            // =================================================================================
            when(command) {
                "UP" -> {
                    // Both modes: -step (move up / shrink)
                    android.util.Log.d("MirrorDpad", "UP pressed, isResize=$isMirrorResizeMode, sending deltaY=-$step")
                    service.adjustMirrorKeyboard(isMirrorResizeMode, 0, -step)
                }
                "DOWN" -> {
                    // Both modes: +step (move down / grow)
                    android.util.Log.d("MirrorDpad", "DOWN pressed, isResize=$isMirrorResizeMode, sending deltaY=+$step")
                    service.adjustMirrorKeyboard(isMirrorResizeMode, 0, step)
                }
                "LEFT" -> {
                    android.util.Log.d("MirrorDpad", "LEFT pressed, isResize=$isMirrorResizeMode")
                    service.adjustMirrorKeyboard(isMirrorResizeMode, -step, 0)
                }
                "RIGHT" -> {
                    android.util.Log.d("MirrorDpad", "RIGHT pressed, isResize=$isMirrorResizeMode")
                    service.adjustMirrorKeyboard(isMirrorResizeMode, step, 0)
                }
                "CENTER" -> service.resetMirrorKeyboardPosition()
            }
            // =================================================================================
            // END BLOCK: MIRROR KEYBOARD DPAD CONTROLS
            // =================================================================================


        })
        
        list.add(TrackpadMenuAdapter.MenuItem("APPEARANCE", 0, TrackpadMenuAdapter.Type.SUBHEADER))
        
        // Mirror Keyboard Opacity Slider
        list.add(TrackpadMenuAdapter.MenuItem("Mirror Opacity", R.drawable.ic_tab_tune, TrackpadMenuAdapter.Type.SLIDER, p.prefMirrorAlpha, 255) { v ->
            service.updatePref("mirror_alpha", v)
        })
        
        list.add(TrackpadMenuAdapter.MenuItem("TIMING", 0, TrackpadMenuAdapter.Type.SUBHEADER))
        
        // Orange Trail Delay Slider (100ms - 3000ms, show as 0.1s - 3.0s)
        val currentDelayMs = p.prefMirrorOrientDelayMs
        list.add(TrackpadMenuAdapter.MenuItem("Orient Delay: ${currentDelayMs}ms", R.drawable.ic_tab_tune, TrackpadMenuAdapter.Type.SLIDER, (currentDelayMs / 100).toInt(), 30) { v ->
            val newDelayMs = (v as Int) * 100L
            service.updatePref("mirror_orient_delay", newDelayMs)
            loadTab(currentTab) // Refresh to show new value
        })
        
        return list
    }

    // =========================
    // END GET MIRROR ITEMS
    // =========================

    // =========================
    // GET CONFIG ITEMS - Trackpad configuration settings
    // FIXED: Tap to Scroll Boolean Logic
    // ========================= 
    private fun getConfigItems(): List<TrackpadMenuAdapter.MenuItem> {
        val list = ArrayList<TrackpadMenuAdapter.MenuItem>()
        val p = service.prefs
        
        list.add(TrackpadMenuAdapter.MenuItem("TRACKPAD SETTINGS", 0, TrackpadMenuAdapter.Type.HEADER))
        
        list.add(TrackpadMenuAdapter.MenuItem("SENSITIVITY", 0, TrackpadMenuAdapter.Type.SUBHEADER))
        list.add(TrackpadMenuAdapter.MenuItem("Cursor Speed", R.drawable.ic_tab_settings, TrackpadMenuAdapter.Type.SLIDER, (p.cursorSpeed * 10).toInt()) { v -> service.updatePref("cursor_speed", (v as Int) / 10f) })
        list.add(TrackpadMenuAdapter.MenuItem("Scroll Speed", R.drawable.ic_tab_settings, TrackpadMenuAdapter.Type.SLIDER, (p.scrollSpeed * 10).toInt(), 50) { v -> service.updatePref("scroll_speed", (v as Int) / 10f) })
        
        list.add(TrackpadMenuAdapter.MenuItem("APPEARANCE", 0, TrackpadMenuAdapter.Type.SUBHEADER))
        list.add(TrackpadMenuAdapter.MenuItem("Border Opacity", R.drawable.ic_tab_tune, TrackpadMenuAdapter.Type.SLIDER, p.prefAlpha, 255) { v -> service.updatePref("alpha", v) })
        list.add(TrackpadMenuAdapter.MenuItem("Background Opacity", R.drawable.ic_tab_tune, TrackpadMenuAdapter.Type.SLIDER, p.prefBgAlpha, 255) { v -> service.updatePref("bg_alpha", v) })
        list.add(TrackpadMenuAdapter.MenuItem("Handle Size", R.drawable.ic_tab_tune, TrackpadMenuAdapter.Type.SLIDER, p.prefHandleSize / 2) { v -> service.updatePref("handle_size", v) })        
        list.add(TrackpadMenuAdapter.MenuItem("Scroll Bar Width", R.drawable.ic_tab_tune, TrackpadMenuAdapter.Type.SLIDER, p.prefScrollTouchSize, 200) { v -> service.updatePref("scroll_size", v) })
        list.add(TrackpadMenuAdapter.MenuItem("Cursor Size", R.drawable.ic_tab_tune, TrackpadMenuAdapter.Type.SLIDER, p.prefCursorSize) { v -> service.updatePref("cursor_size", v) })
        
        list.add(TrackpadMenuAdapter.MenuItem("BEHAVIOR", 0, TrackpadMenuAdapter.Type.SUBHEADER))
        
        list.add(TrackpadMenuAdapter.MenuItem("Reverse Scroll", R.drawable.ic_tab_settings, TrackpadMenuAdapter.Type.TOGGLE, if(p.prefReverseScroll) 1 else 0) { v -> service.updatePref("reverse_scroll", v) })
        
        // MODIFIED: Correct Boolean Check for Toast
        list.add(TrackpadMenuAdapter.MenuItem("Tap to Scroll", R.drawable.ic_tab_settings, TrackpadMenuAdapter.Type.TOGGLE, if(p.prefTapScroll) 1 else 0) { v -> 
            service.updatePref("tap_scroll", v)
            // Fix: Cast strictly to Boolean or check against false directly
            if (v == false) {
                android.widget.Toast.makeText(context, "Beta mouse scrolling is activated - warning - scroll slowly for optimal results", android.widget.Toast.LENGTH_LONG).show()
            }
        })
        
        list.add(TrackpadMenuAdapter.MenuItem("Haptic Feedback", R.drawable.ic_tab_settings, TrackpadMenuAdapter.Type.TOGGLE, if(p.prefVibrate) 1 else 0) { v -> service.updatePref("vibrate", v) })
        return list
    }
    // =========================
    // END GET CONFIG ITEMS
    // =========================

    // =========================
    // GET TUNE ITEMS - Keyboard configuration settings
    // =========================
    private fun getTuneItems(): List<TrackpadMenuAdapter.MenuItem> {
        val list = ArrayList<TrackpadMenuAdapter.MenuItem>()
        val p = service.prefs
        
        list.add(TrackpadMenuAdapter.MenuItem("KEYBOARD SETTINGS", 0, TrackpadMenuAdapter.Type.HEADER))
        

        // [NEW] Set Restore Keyboard Preference (With Visual Feedback)
        val prefs = context.getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
        val savedIme = prefs.getString("user_preferred_ime", null)
        
        // Determine display name
        val imeName = when {
            savedIme == null -> "None (Tap to Select)"
            savedIme.contains("google") -> "Gboard"
            savedIme.contains("sec") || savedIme.contains("honeyboard") -> "Samsung Keyboard"
            savedIme.contains("swiftkey") -> "SwiftKey"
            else -> "Custom Keyboard"
        }

        list.add(TrackpadMenuAdapter.MenuItem("Restore Target: $imeName", android.R.drawable.ic_menu_save, TrackpadMenuAdapter.Type.ACTION) {
            try {
                // Open System Picker so OverlayService can capture the user's choice
                val imm = context.getSystemService(Context.INPUT_METHOD_SERVICE) as android.view.inputmethod.InputMethodManager
                imm.showInputMethodPicker()
                android.widget.Toast.makeText(context, "Select the keyboard DroidOS should restore to.", android.widget.Toast.LENGTH_LONG).show()
            } catch (e: Exception) {
                e.printStackTrace()
            }
        })
        // NEW: Launch Proxy Activity for Picker
        list.add(TrackpadMenuAdapter.MenuItem("Keyboard Picker (Select 'DroidOS Dock')", android.R.drawable.ic_menu_agenda, TrackpadMenuAdapter.Type.ACTION) { 
            service.forceSystemKeyboardVisible()

            hide() // Close menu
            
            try {
                val intent = android.content.Intent(context, KeyboardPickerActivity::class.java)
                intent.addFlags(android.content.Intent.FLAG_ACTIVITY_NEW_TASK)
                context.startActivity(intent)
            } catch(e: Exception) {
                android.widget.Toast.makeText(context, "Error launching picker", android.widget.Toast.LENGTH_SHORT).show()
            }
        })
        
        list.add(TrackpadMenuAdapter.MenuItem("Keyboard Opacity", R.drawable.ic_tab_tune, TrackpadMenuAdapter.Type.SLIDER, p.prefKeyboardAlpha, 255) { v -> service.updatePref("keyboard_alpha", v) })
                list.add(TrackpadMenuAdapter.MenuItem("Auto Display Off", R.drawable.ic_tab_tune, TrackpadMenuAdapter.Type.TOGGLE, if(p.prefAutomationEnabled) 1 else 0) {
                    v -> service.updatePref("automation_enabled", v as Boolean)
                })

        // MOVED & RENAMED: Cover Screen KB Blocker
        list.add(TrackpadMenuAdapter.MenuItem("Cover Screen KB blocker (restart app after reverting)", android.R.drawable.ic_lock_lock, TrackpadMenuAdapter.Type.TOGGLE, if(p.prefBlockSoftKeyboard) 1 else 0) {
            v -> service.updatePref("block_soft_kb", v as Boolean)
        })

        // =================================================================================
        // SPACEBAR MOUSE EXTENDED MODE TOGGLE
        // SUMMARY: When enabled, spacebar mouse mode stays active indefinitely. Mode only
        //          deactivates when tapping outside the keyboard overlay area. This allows
        //          continuous cursor control without the normal 1-second timeout.
        // =================================================================================
        list.add(TrackpadMenuAdapter.MenuItem("Spacebar Mouse Extended Mode", android.R.drawable.ic_menu_compass, TrackpadMenuAdapter.Type.TOGGLE, if(p.prefSpacebarMouseExtended) 1 else 0) {
            v -> service.updatePref("spacebar_mouse_extended", v as Boolean)
        })

        // =================================================================================
        // END BLOCK: SPACEBAR MOUSE EXTENDED MODE TOGGLE
        // =================================================================================

        // Override System Shortcuts toggle
        list.add(TrackpadMenuAdapter.MenuItem("Override System Shortcuts", android.R.drawable.ic_menu_close_clear_cancel, TrackpadMenuAdapter.Type.TOGGLE, if(p.prefOverrideSystemShortcuts) 1 else 0) {
            v -> service.updatePref("override_system_shortcuts", v as Boolean)
        })

        // =================================================================================
        // PREDICTION AGGRESSION SLIDER (Safe Clamped Version)
        // Range: 0.3 (Sloppy) to 2.0 (Precise) -> Slider 0 to 170
        // We CLAMP the input to ensure bad saved values (like 8.0) don't break the UI.
        // =================================================================================
        val rawAggression = p.prefPredictionAggression
        val safeAggression = rawAggression.coerceIn(0.3f, 2.0f) // Force valid range
        val sliderValue = ((safeAggression - 0.3f) * 100).toInt()
        
        list.add(TrackpadMenuAdapter.MenuItem("Prediction: Sloppy (L) vs Neat (R)", R.drawable.ic_tab_tune, TrackpadMenuAdapter.Type.SLIDER, sliderValue, 170) { v ->
            // Explicitly cast v to Int to fix "Unresolved reference" error
            val intV = v as Int
            val floatVal = 0.3f + (intV / 100f)
            service.updatePref("prediction_aggression", floatVal)
        })

        return list
    }
    // =========================
    // END GET TUNE ITEMS
    // =========================

    // =========================
    // HARDKEY ACTIONS LIST
    // =========================
    private val hardkeyActions = listOf(
        "none" to "None (System Default)",
        "left_click" to "Left Click (Hold to Drag)",
        "right_click" to "Right Click (Hold to Drag)",
        "scroll_up" to "Scroll Up",
        "scroll_down" to "Scroll Down",
        "display_toggle_alt" to "Display (Alt Mode)",
        "display_toggle_std" to "Display (Std Mode)",
        "display_wake" to "Display Wake",
        "alt_position" to "Alt KB Position",
        "toggle_keyboard" to "Toggle Keyboard",
        "toggle_trackpad" to "Toggle Trackpad",
        "open_menu" to "Open Menu",
        "reset_cursor" to "Reset Cursor",
        "toggle_bubble" to "Launcher Bubble", // <--- NEW ITEM
        "action_back" to "Back",
        "action_home" to "Home",
        "action_forward" to "Forward (Browser)",
        "action_vol_up" to "Volume Up",
        "action_vol_down" to "Volume Down"
    )
    
    private fun getActionDisplayName(actionId: String): String {
        return hardkeyActions.find { it.first == actionId }?.second ?: actionId
    }
    // =========================
    // END HARDKEY ACTIONS LIST
    // =========================

    // =========================
    // SHOW ACTION PICKER - In-Menu Replacement for Dialog
    // Replaces the current menu list with selection options to avoid Service/Dialog crashes
    // =========================
    private fun showActionPicker(prefKey: String, currentValue: String) {
        val list = ArrayList<TrackpadMenuAdapter.MenuItem>()
        
        // 1. Header
        list.add(TrackpadMenuAdapter.MenuItem("Select Action", 0, TrackpadMenuAdapter.Type.HEADER))
        
        // 2. Cancel / Back Option
        list.add(TrackpadMenuAdapter.MenuItem("<< Go Back", android.R.drawable.ic_menu_revert, TrackpadMenuAdapter.Type.ACTION) {
            // Reload the previous tab to "go back"
            loadTab(TAB_HARDKEYS)
        })

        // 3. Action Options
        for ((id, name) in hardkeyActions) {
            // Show a "Check" icon if this is the currently selected value
            // Otherwise show 0 (no icon) or a generic dot
            val iconRes = if (id == currentValue) android.R.drawable.checkbox_on_background else 0
            
            list.add(TrackpadMenuAdapter.MenuItem(name, iconRes, TrackpadMenuAdapter.Type.ACTION) {
                // On Click: Update Pref and Go Back
                service.updatePref(prefKey, id)
                loadTab(TAB_HARDKEYS)
            })
        }
        
        // 4. Update the View
        recyclerView?.adapter = TrackpadMenuAdapter(list)
    }
    // =========================
    // END SHOW ACTION PICKER
    // =========================

    // =========================
    // GET HARDKEY ITEMS - Hardkey bindings configuration menu
    // Allows users to customize Vol Up/Down and Power button actions
    // =========================
    private fun getHardkeyItems(): List<TrackpadMenuAdapter.MenuItem> {
        val list = ArrayList<TrackpadMenuAdapter.MenuItem>()
        val p = service.prefs
        
        // NEW MAIN HEADER
        list.add(TrackpadMenuAdapter.MenuItem("KEYBINDS", 0, TrackpadMenuAdapter.Type.HEADER))
        
        // Subheader
        list.add(TrackpadMenuAdapter.MenuItem("VOLUME UP", 0, TrackpadMenuAdapter.Type.SUBHEADER))
        
        list.add(TrackpadMenuAdapter.MenuItem(
            "Tap: ${getActionDisplayName(p.hardkeyVolUpTap)}",
            android.R.drawable.ic_media_play,
            TrackpadMenuAdapter.Type.ACTION
        ) { showActionPicker("hardkey_vol_up_tap", p.hardkeyVolUpTap) })
        
        list.add(TrackpadMenuAdapter.MenuItem(
            "Double-Tap: ${getActionDisplayName(p.hardkeyVolUpDouble)}",
            android.R.drawable.ic_media_ff,
            TrackpadMenuAdapter.Type.ACTION
        ) { showActionPicker("hardkey_vol_up_double", p.hardkeyVolUpDouble) })
        
        list.add(TrackpadMenuAdapter.MenuItem(
            "Hold: ${getActionDisplayName(p.hardkeyVolUpHold)}",
            android.R.drawable.ic_menu_crop,
            TrackpadMenuAdapter.Type.ACTION
        ) { showActionPicker("hardkey_vol_up_hold", p.hardkeyVolUpHold) })
        
        // Subheader
        list.add(TrackpadMenuAdapter.MenuItem("VOLUME DOWN", 0, TrackpadMenuAdapter.Type.SUBHEADER))
        
        list.add(TrackpadMenuAdapter.MenuItem(
            "Tap: ${getActionDisplayName(p.hardkeyVolDownTap)}",
            android.R.drawable.ic_media_play,
            TrackpadMenuAdapter.Type.ACTION
        ) { showActionPicker("hardkey_vol_down_tap", p.hardkeyVolDownTap) })
        
        list.add(TrackpadMenuAdapter.MenuItem(
            "Double-Tap: ${getActionDisplayName(p.hardkeyVolDownDouble)}",
            android.R.drawable.ic_media_ff,
            TrackpadMenuAdapter.Type.ACTION
        ) { showActionPicker("hardkey_vol_down_double", p.hardkeyVolDownDouble) })
        
        list.add(TrackpadMenuAdapter.MenuItem(
            "Hold: ${getActionDisplayName(p.hardkeyVolDownHold)}",
            android.R.drawable.ic_menu_crop,
            TrackpadMenuAdapter.Type.ACTION
        ) { showActionPicker("hardkey_vol_down_hold", p.hardkeyVolDownHold) })
        
        // Subheader
        list.add(TrackpadMenuAdapter.MenuItem("TIMING", 0, TrackpadMenuAdapter.Type.SUBHEADER))
        
        // Max 500ms
        list.add(TrackpadMenuAdapter.MenuItem(
            "Double-Tap Speed (ms)",
            android.R.drawable.ic_menu_recent_history,
            TrackpadMenuAdapter.Type.SLIDER,
            p.doubleTapMs,
            500 
        ) { v ->
            service.updatePref("double_tap_ms", v)
        })
        
        // Max 800ms
        list.add(TrackpadMenuAdapter.MenuItem(
            "Hold Duration (ms)",
            android.R.drawable.ic_menu_recent_history,
            TrackpadMenuAdapter.Type.SLIDER,
            p.holdDurationMs,
            800 
        ) { v ->
            service.updatePref("hold_duration_ms", v)
        })
        
        return list
    }
    // =========================
    // END GET HARDKEY ITEMS
    // =========================


    // =========================
    // GET BUBBLE ITEMS - Bubble launcher customization
    // Size slider, Icon cycle, Opacity slider
    // =========================
    private fun getBubbleItems(): List<TrackpadMenuAdapter.MenuItem> {
        val list = ArrayList<TrackpadMenuAdapter.MenuItem>()
        val p = service.prefs
        
        list.add(TrackpadMenuAdapter.MenuItem("BUBBLE CUSTOMIZATION", 0, TrackpadMenuAdapter.Type.HEADER))
        
        // Size slider: 50-200 (50=half, 100=standard, 200=double)
        list.add(TrackpadMenuAdapter.MenuItem("Bubble Size", R.drawable.ic_tab_tune, TrackpadMenuAdapter.Type.SLIDER, p.prefBubbleSize, 200) { v ->
            service.updatePref("bubble_size", v)
        })
        
        // Icon cycle action
        val iconNames = arrayOf("Trackpad", "Cursor", "Main", "Keyboard", "Compass", "Location")
        val currentIconName = iconNames.getOrElse(p.prefBubbleIconIndex) { "Default" }
        list.add(TrackpadMenuAdapter.MenuItem("Icon: $currentIconName", android.R.drawable.ic_menu_gallery, TrackpadMenuAdapter.Type.ACTION) { 
            service.updatePref("bubble_icon", true)
            loadTab(TAB_BUBBLE) // Refresh to show new icon name
        })
        
        // Opacity slider: 50-255
        list.add(TrackpadMenuAdapter.MenuItem("Bubble Opacity", R.drawable.ic_tab_tune, TrackpadMenuAdapter.Type.SLIDER, p.prefBubbleAlpha, 255) { v ->
            service.updatePref("bubble_alpha", v)
        })
        
        // Reset button
        list.add(TrackpadMenuAdapter.MenuItem("Reset Bubble Position", android.R.drawable.ic_menu_revert, TrackpadMenuAdapter.Type.ACTION) { 
            service.resetBubblePosition()
        })
        
        // --- PERSISTENCE TOGGLE ---
        list.add(TrackpadMenuAdapter.MenuItem("SERVICE BEHAVIOR", 0, TrackpadMenuAdapter.Type.HEADER))
        
        val persistHelp = if (p.prefPersistentService) "Bubble stays when app closes" else "Bubble closes with app"
        list.add(TrackpadMenuAdapter.MenuItem("Keep Alive (Background)", 
            android.R.drawable.ic_menu_manage, 
            TrackpadMenuAdapter.Type.TOGGLE, 
            if(p.prefPersistentService) 1 else 0) { v ->
            service.updatePref("persistent_service", v)
            loadTab(TAB_BUBBLE) // Refresh description
        })
        list.add(TrackpadMenuAdapter.MenuItem(persistHelp, 0, TrackpadMenuAdapter.Type.INFO))
        
        return list
    }
    // =========================
    // END GET BUBBLE ITEMS
    // =========================

    private fun getProfileItems(): List<TrackpadMenuAdapter.MenuItem> {
        val list = ArrayList<TrackpadMenuAdapter.MenuItem>()
        val currentRes = "${service.currentDisplayId}: ${service.getProfileKey().replace("P_", "").replace("_", " x ")}"
        
        list.add(TrackpadMenuAdapter.MenuItem("LAYOUT PROFILES", 0, TrackpadMenuAdapter.Type.HEADER))
        
        list.add(TrackpadMenuAdapter.MenuItem("Current: $currentRes", R.drawable.ic_tab_profiles, TrackpadMenuAdapter.Type.INFO))
        
        // CHANGED TITLE
        list.add(TrackpadMenuAdapter.MenuItem("Save Layout and Presets", android.R.drawable.ic_menu_save, TrackpadMenuAdapter.Type.ACTION) { 
            service.saveLayout()
            drawerView?.postDelayed({ loadTab(TAB_PROFILES) }, 200)
        })

        // NEW: Reload Profile
        list.add(TrackpadMenuAdapter.MenuItem("Reload Profile", android.R.drawable.ic_popup_sync, TrackpadMenuAdapter.Type.ACTION) { 
            service.loadLayout() // Reloads based on current resolution/display
            drawerView?.postDelayed({ loadTab(TAB_PROFILES) }, 200)
        })
        
        list.add(TrackpadMenuAdapter.MenuItem("Delete Profile", android.R.drawable.ic_menu_delete, TrackpadMenuAdapter.Type.ACTION) { 
            service.deleteCurrentProfile()
            drawerView?.postDelayed({ loadTab(TAB_PROFILES) }, 200)
        })
        
        // --- SAVED LAYOUTS LIST ---
        list.add(TrackpadMenuAdapter.MenuItem("SAVED LAYOUTS", 0, TrackpadMenuAdapter.Type.HEADER))
        
        val saved = service.getSavedProfileList()
        if (saved.isEmpty()) {
            list.add(TrackpadMenuAdapter.MenuItem("No saved layouts found.", 0, TrackpadMenuAdapter.Type.INFO))
        } else {
            for (res in saved) {
                list.add(TrackpadMenuAdapter.MenuItem(" $res", 0, TrackpadMenuAdapter.Type.INFO))
            }
        }
        
        return list
    }

    private fun getHelpItems(): List<TrackpadMenuAdapter.MenuItem> {
        val list = ArrayList<TrackpadMenuAdapter.MenuItem>()
        
        list.add(TrackpadMenuAdapter.MenuItem("INSTRUCTIONS", 0, TrackpadMenuAdapter.Type.HEADER))
        
        val text = 
            "TRACKPAD CONTROLS\n" +
            " Tap: Left Click\n" +
            " 2-Finger Tap: Right Click\n" +
            " Hold + Slide: Drag & Drop\n" +
            " Edge (Top/Bottom): V-Scroll\n" +
            " Edge (Left/Right): H-Scroll\n\n" +
            "KEYBOARD OVERLAY\n" +
            " Drag Top Bar: Move Window\n" +
            " Drag Bottom-Right: Resize\n" +
            " Hold Corner: Toggle Key/Mouse\n\n" +
            "HARDWARE KEYS\n" +
            " Use the 'Hardkeys' tab to map\n" +
            "  Volume Up/Down to clicks,\n" +
            "  scrolling, or screen controls."
            
        list.add(TrackpadMenuAdapter.MenuItem(text, 0, TrackpadMenuAdapter.Type.INFO))
        
        list.add(TrackpadMenuAdapter.MenuItem("LAUNCHER & APP", 0, TrackpadMenuAdapter.Type.HEADER))
        val text2 = 
            " Floating Bubble: Tap to open this menu. Drag to move.\n" +
            " Setup App: Open 'DroidOS Trackpad' from your Android App Drawer to adjust permissions or restart the service."
        list.add(TrackpadMenuAdapter.MenuItem(text2, 0, TrackpadMenuAdapter.Type.INFO))
        
        return list
    }
}
```

## File: Cover-Screen-Trackpad/app/src/main/res/layout/layout_dock_popup.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/dock_popup_container"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:background="#2A2A2A"
    android:padding="8dp"
    android:elevation="8dp">

    <!-- Option 1: Auto-sync overlay keyboard visibility -->
    <LinearLayout
        android:id="@+id/option_auto_show"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:padding="12dp"
        android:background="?android:attr/selectableItemBackground">

        <ImageView
            android:id="@+id/icon_auto_show"
            android:layout_width="20dp"
            android:layout_height="20dp"
            android:src="@drawable/ic_dock_keyboard"
            android:tint="#888888"
            android:layout_marginEnd="12dp"/>

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Auto-show Overlay KB"
            android:textColor="#FFFFFF"
            android:textSize="13sp"/>

        <View
            android:id="@+id/toggle_auto_show"
            android:layout_width="36dp"
            android:layout_height="20dp"
            android:background="#555555"/>
    </LinearLayout>

    <View
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:background="#444444"/>

    <!-- Option 2: Dock mode (snap overlay KB to bottom) -->
    <LinearLayout
        android:id="@+id/option_dock_mode"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:padding="12dp"
        android:background="?android:attr/selectableItemBackground">

        <ImageView
            android:id="@+id/icon_dock_mode"
            android:layout_width="20dp"
            android:layout_height="20dp"
            android:src="@drawable/ic_dock_paste"
            android:tint="#888888"
            android:layout_marginEnd="12dp"/>

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Dock KB to Bottom"
            android:textColor="#FFFFFF"
            android:textSize="13sp"/>

        <View
            android:id="@+id/toggle_dock_mode"
            android:layout_width="36dp"
            android:layout_height="20dp"
            android:background="#555555"/>
    </LinearLayout>

    <View
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:background="#444444"/>

    <!-- Option 3: Auto Resize Apps (only when dock mode enabled) -->
    <LinearLayout
        android:id="@+id/option_auto_resize"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:padding="12dp"
        android:background="?android:attr/selectableItemBackground">

        <ImageView
            android:id="@+id/icon_auto_resize"
            android:layout_width="20dp"
            android:layout_height="20dp"
            android:src="@drawable/ic_dock_switch"
            android:tint="#888888"
            android:layout_marginEnd="12dp"/>

        <TextView
            android:id="@+id/text_auto_resize"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Auto Resize Apps"
            android:textColor="#FFFFFF"
            android:textSize="13sp"/>

        <View
            android:id="@+id/toggle_auto_resize"
            android:layout_width="36dp"
            android:layout_height="20dp"
            android:background="#555555"/>
    </LinearLayout>

    <View
        android:id="@+id/divider_resize"
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:background="#444444"
        android:visibility="gone"/>

    <!-- Option 4: Resize Slider (Sub-menu) -->
    <LinearLayout
        android:id="@+id/container_resize_slider"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingTop="8dp"
        android:paddingBottom="8dp"
        android:paddingStart="12dp"
        android:paddingEnd="12dp"
        android:visibility="gone">

        <TextView
            android:id="@+id/text_resize_label"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Height Adjustment: 100%"
            android:textColor="#AAAAAA"
            android:textSize="12sp"
            android:layout_marginBottom="4dp"
            android:layout_gravity="center_horizontal"/>

        <SeekBar
            android:id="@+id/seekbar_resize_height"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="50"
            android:progress="0"
            android:progressTint="#3DDC84"
            android:thumbTint="#3DDC84"/>

        <CheckBox
            android:id="@+id/checkbox_sync_margin"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Sync with DroidOS Bottom Margin"
            android:textColor="#AAAAAA"
            android:textSize="12sp"
            android:buttonTint="#3DDC84"
            android:paddingStart="8dp"
            android:layout_marginTop="4dp"/>
    </LinearLayout>

</LinearLayout>
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/KeyboardOverlay.kt
```kotlin
package com.example.coverscreentester

import android.content.Context
import android.graphics.Color
import android.graphics.PixelFormat
import android.graphics.drawable.GradientDrawable
import android.media.AudioManager
import android.media.AudioRecordingConfiguration
import android.os.Build
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.view.Gravity
import android.view.InputDevice // <--- ADD THIS LINE
import android.view.KeyEvent
import android.view.MotionEvent
import android.view.View
import android.view.WindowManager
import android.widget.FrameLayout
import android.widget.TextView
import kotlin.math.max


class KeyboardOverlay(
    private val context: Context,
    private val windowManager: WindowManager,
    private val shellService: IShellService?,
    private val targetDisplayId: Int,
    private val onScreenToggleAction: () -> Unit,
    private val onScreenModeChangeAction: () -> Unit,


    private val onCloseAction: () -> Unit // New Parameter
) : KeyboardView.KeyboardListener {

    private var keyboardContainer: FrameLayout? = null


    private var keyboardView: KeyboardView? = null
    // =================================================================================
    // SPACEBAR MOUSE EXTENDED MODE - DRAG HANDLE INDICATOR
    // SUMMARY: Reference to the drag handle indicator so we can change its color
    //          (red when extended mode is active, grey when inactive).
    // =================================================================================
    private var dragHandleIndicator: View? = null
    // =================================================================================
    // END BLOCK: DRAG HANDLE INDICATOR REFERENCE
    // =================================================================================
    private var cachedCustomModKey = 0
    private var keyboardParams: WindowManager.LayoutParams? = null

    // =================================================================================
    // LAUNCHER BLOCKED SHORTCUTS
    // SUMMARY: Set of shortcuts registered in the Launcher. Passed to KeyboardView.
    // =================================================================================
    private var launcherBlockedShortcuts: Set<String> = emptySet()
    // =================================================================================
    // END BLOCK: LAUNCHER BLOCKED SHORTCUTS
    // =================================================================================
    private var isVisible = false
    private val predictionEngine = PredictionEngine.instance
    // State Variables
    private var isMoving = false

    private var isResizing = false
    // [NEW] Track scale internally to avoid slow SharedPreferences reads during drag
    private var internalScale = 1.0f
    private var dragStartScale = 1.0f
    private var dragStartHeight = 0

    // Mouse Tracking
    private var lastMouseX = 0f
    private var lastMouseY = 0f
    private var isMouseDragging = false

    private var isAnchored = false
    private var initialTouchX = 0f
    private var initialTouchY = 0f
    private var initialWindowX = 0
    private var initialWindowY = 0
    private var initialWidth = 0
    private var initialHeight = 0

    private val TAG = "KeyboardOverlay"

    // [FIX] Track the physical device ID to ignore injected events (Anti-Loop)
    private var activeFingerDeviceId = -1
    // =================================================================================
    // VIRTUAL MIRROR ORIENTATION MODE VARIABLES
    // SUMMARY: State for orientation mode when virtual mirror is active.
    //          During orientation mode, an orange trail is shown and key input is blocked
    //          until the finger stops moving for the configured delay.
    // =================================================================================
    private var isOrientationModeActive = false
    private var orientationTrailView: SwipeTrailView? = null
    // =================================================================================
    // END BLOCK: VIRTUAL MIRROR ORIENTATION MODE VARIABLES
    // =================================================================================

    // --- PREDICTION STATE ---

    private var currentComposingWord = StringBuilder()
    // =================================================================================
    // ORIGINAL CASE TRACKING
    // SUMMARY: Stores the word with original casing (e.g., "DroidOS", "don't")
    //          while currentComposingWord stores lowercase for dictionary lookup.
    // =================================================================================
    private var originalCaseWord = StringBuilder()
    // =================================================================================
    // END BLOCK: ORIGINAL CASE TRACKING
    // =================================================================================
    private val handler = Handler(Looper.getMainLooper())

    // NEW: Track sentence context and swipe history
    private var lastCommittedSwipeWord: String? = null
    private var isSentenceStart = true

    // Helper to inject text via OverlayService
    private fun injectText(text: String) {
        (context as? OverlayService)?.injectText(text)
    }

    // FIX Default height to WRAP_CONTENT (-2) to avoid cutting off rows
    private var keyboardWidth = 500
    private var keyboardHeight = WindowManager.LayoutParams.WRAP_CONTENT 
    
    private var screenWidth = 720
    private var screenHeight = 748
    private var currentRotation = 0
    private var currentAlpha = 200
    private var currentDisplayId = 0


    // Callbacks to talk back to OverlayService
    var onCursorMove: ((Float, Float, Boolean) -> Unit)? = null // dx, dy, isDragging
    var onCursorClick: ((Boolean) -> Unit)? = null
    var onTouchDown: (() -> Unit)? = null
    var onTouchUp: (() -> Unit)? = null
    var onTouchTap: (() -> Unit)? = null

    // =================================================================================
    // VIRTUAL MIRROR CALLBACK
    // SUMMARY: Callback to forward touch events to OverlayService for mirror sync.
    //          Returns true if touch should be consumed (orientation mode active).
    // =================================================================================
    var onMirrorTouch: ((Float, Float, Int) -> Boolean)? = null // x, y, action -> consumed
    // =================================================================================
    // END BLOCK: VIRTUAL MIRROR CALLBACK
    // =================================================================================

    // =================================================================================
    // ARROW KEYS SWIPE CALLBACK
    // SUMMARY: Forwards arrow key swipe from KeyboardView to OverlayService
    // =================================================================================
    var onArrowSwipe: ((Float, Float) -> Unit)? = null
    var onMouseScroll: ((Float, Float) -> Unit)? = null
    // =================================================================================
    // END BLOCK: ARROW KEYS SWIPE CALLBACK
    // =================================================================================

    // Layer change callback for syncing mirror keyboard
    var onLayerChanged: ((KeyboardView.KeyboardState) -> Unit)? = null

    // =================================================================================
    // CALLBACK: onSuggestionsChanged
    // SUMMARY: Called whenever the suggestion bar is updated. Used to sync mirror keyboard.
    // =================================================================================
    var onSuggestionsChanged: ((List<KeyboardView.Candidate>) -> Unit)? = null
    var onSizeChanged: (() -> Unit)? = null
    // =================================================================================
    // END BLOCK: onSuggestionsChanged
    // =================================================================================




    fun setScreenDimensions(width: Int, height: Int, displayId: Int) {
        // 1. Update Class-Level Screen Dimensions
        this.screenWidth = width
        this.screenHeight = height
        this.currentDisplayId = displayId

        // 2. Apply Dynamic Resize Logic (Same as Reset)
        // This ensures that when entering split-screen or rotating, the keyboard
        // recalculates its perfect size (90% width, 300dp height) instead of stretching.
        val newWidth = (width * 0.90f).toInt().coerceIn(300, 1200)
        
        // Calculate Height: 300dp * Scale * Density
        val density = context.resources.displayMetrics.density
        val scale = if (internalScale > 0f) internalScale else 0.69f
        val baseHeightDp = 300f
        val newHeight = (baseHeightDp * scale * density).toInt()

        // 3. Update Window Params
        keyboardWidth = newWidth
        keyboardHeight = newHeight
        
        keyboardParams?.let {
            it.width = newWidth
            it.height = newHeight
            
            // Optional: Re-center keyboard on screen change
            it.x = (width - newWidth) / 2
            it.y = height / 2

            try {
                windowManager.updateViewLayout(keyboardContainer, it)
                syncMirrorRatio(newWidth, newHeight)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }





    fun updateScale(scale: Float) {
        internalScale = scale // [FIX] Track scale state
        if (keyboardView == null) return
        keyboardView?.setScale(scale)
        
        // FIX: Removed forced reset of keyboardHeight to WRAP_CONTENT.
        // We now respect the existing keyboardHeight (whether it's fixed pixels from a manual resize
        // or WRAP_CONTENT from default).
        
        if (isVisible && keyboardParams != null) {
            // If the window is set to WRAP_CONTENT, we might need to poke the WM to re-measure
            // effectively, but we shouldn't change the param value itself if it's already -2.
            // If it is fixed pixels, we leave it alone.
            
            // We only need to update layout if we want to ensure constraints are met,
            // but simply invalidating the view is usually enough for internal changes.
            // To be safe, we update the view layout with the *current* params.
            try { 
                windowManager.updateViewLayout(keyboardContainer, keyboardParams)
                // Do NOT call saveKeyboardSize() here. Scaling shouldn't change the 
                // "Window Size Preference" (Container), only the content scale.
            } catch (e: Exception) {}
        }
    }
    
    fun updateAlpha(alpha: Int) {
        currentAlpha = alpha
        if (isVisible && keyboardContainer != null) {
            val bg = keyboardContainer?.background as? GradientDrawable
            if (bg != null) {
                val fillColor = (alpha shl 24) or (0x1A1A1A)
                bg.setColor(fillColor)
                bg.setStroke(2, Color.parseColor("#44FFFFFF"))
            }
            val normalizedAlpha = alpha / 255f
            keyboardView?.alpha = normalizedAlpha
            keyboardContainer?.invalidate()
        }
    }
    
    fun setWindowBounds(x: Int, y: Int, width: Int, height: Int) {
        keyboardWidth = width
        keyboardHeight = height
        if (isVisible && keyboardParams != null) {
            keyboardParams?.x = x
            keyboardParams?.y = y
            keyboardParams?.width = width
            keyboardParams?.height = height
            try { 
                windowManager.updateViewLayout(keyboardContainer, keyboardParams)
                saveKeyboardPosition()
                saveKeyboardSize()
            } catch (e: Exception) {}
        } else {
            // Even if hidden, save the new bounds so they apply on next show
            val prefs = context.getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
            prefs.edit()
                .putInt("keyboard_x_d$currentDisplayId", x)
                .putInt("keyboard_y_d$currentDisplayId", y)
                .putInt("keyboard_width_d$currentDisplayId", width)
                .putInt("keyboard_height_d$currentDisplayId", height)
                .apply()
        }
    }
   
    fun setAnchored(anchored: Boolean) {
        isAnchored = anchored
    }

    fun setVibrationEnabled(enabled: Boolean) {
        keyboardView?.setVibrationEnabled(enabled)
    }
    // Helper for OverlayService Profile Load
    fun updatePosition(x: Int, y: Int) {
        if (keyboardContainer == null || keyboardParams == null) {
            // Save to prefs if hidden
            context.getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE).edit()
                .putInt("keyboard_x_d$currentDisplayId", x)
                .putInt("keyboard_y_d$currentDisplayId", y)
                .apply()
            return
        }
        keyboardParams?.x = x
        keyboardParams?.y = y
        try {
            windowManager.updateViewLayout(keyboardContainer, keyboardParams)
            saveKeyboardPosition()
        } catch (e: Exception) { e.printStackTrace() }
    }

    // Helper for OverlayService Profile Load
    fun updateSize(w: Int, h: Int) {
        keyboardWidth = w
        keyboardHeight = h
        
        if (keyboardContainer == null || keyboardParams == null) {
            saveKeyboardSize()
            return
        }
        keyboardParams?.width = w
        keyboardParams?.height = h
        try {
            windowManager.updateViewLayout(keyboardContainer, keyboardParams)
            saveKeyboardSize()
        } catch (e: Exception) { e.printStackTrace() }
    }
    
    // Robust Getters: Return live values if visible, otherwise return saved Prefs
    fun getViewX(): Int {
        if (keyboardParams != null) return keyboardParams!!.x
        return context.getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
            .getInt("keyboard_x_d$currentDisplayId", 0)
    }
    

    fun getViewY(): Int {
        if (keyboardParams != null) return keyboardParams!!.y
        return context.getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
            .getInt("keyboard_y_d$currentDisplayId", 0)
    }
    
    fun getViewWidth(): Int = keyboardWidth
    fun getViewHeight(): Int = keyboardHeight
    fun getScale(): Float = internalScale // [FIX] Added accessor
    fun getKeyboardView(): KeyboardView? = keyboardView
    fun getContainerView(): View? = keyboardContainer // NEW


    
    // [START ROTATION FIX]
    fun setRotation(angle: Int) {
        currentRotation = angle
        if (!isVisible || keyboardContainer == null || keyboardParams == null || keyboardView == null) return

        val isPortrait = (angle == 90 || angle == 270)

        // 1. Determine Logical Dimensions (Unrotated size)
        // We rely on keyboardWidth/Height being the canonical "Landscape" size.
        val baseW = keyboardWidth
        val baseH = keyboardHeight 

        // 2. Configure WINDOW Params (The touchable area on screen)
        // If rotated, we swap the dimensions passed to WindowManager
        if (isPortrait) {
            keyboardParams?.width = if (baseH == -2) WindowManager.LayoutParams.WRAP_CONTENT else baseH
            keyboardParams?.height = if (baseW == -2) WindowManager.LayoutParams.WRAP_CONTENT else baseW
        } else {
            keyboardParams?.width = if (baseW == -2) WindowManager.LayoutParams.WRAP_CONTENT else baseW
            keyboardParams?.height = if (baseH == -2) WindowManager.LayoutParams.WRAP_CONTENT else baseH
        }

        // 3. Configure VIEW Params (The Internal Content)
        // The View must ALWAYS be the logical size (e.g. Wide) to layout keys in rows correctly.
        val lp = keyboardView!!.layoutParams as FrameLayout.LayoutParams
        lp.width = if (baseW == -2) FrameLayout.LayoutParams.WRAP_CONTENT else baseW
        lp.height = if (baseH == -2) FrameLayout.LayoutParams.WRAP_CONTENT else baseH
        keyboardView!!.layoutParams = lp

        // 4. Apply Rotation to View (Not Container)
        keyboardView!!.rotation = angle.toFloat()
        keyboardContainer!!.rotation = 0f // Ensure container is NOT rotated

        // 5. Update Layout
        try {
            windowManager.updateViewLayout(keyboardContainer, keyboardParams)
        } catch (e: Exception) {}

        // 6. Post-Layout Alignment
        // We must translate the view to re-center it because rotation happens around the pivot (center).
        // Since we swapped the Window dimensions, the centers might not align by default without this.
        keyboardView!!.post { alignRotatedView() }
    }

    private fun alignRotatedView() {
        if (keyboardView == null) return
        
        val angle = currentRotation
        val w = keyboardView!!.measuredWidth
        val h = keyboardView!!.measuredHeight
        
        // When rotated 90/270, the "Visual" width matches the View's Height, and vice versa.
        // We translate the view so its visual center matches the window's center.
        
        when (angle) {
            90, 270 -> {
                val tx = (h - w) / 2f
                val ty = (w - h) / 2f
                keyboardView!!.translationX = tx
                keyboardView!!.translationY = ty
            }
            else -> {
                keyboardView!!.translationX = 0f
                keyboardView!!.translationY = 0f
            }
        }
    }

    fun cycleRotation() {
        if (keyboardContainer == null) return
        val nextRotation = (currentRotation + 90) % 360
        setRotation(nextRotation)
    }




    // [Removed duplicate accessors to fix build error] 




    fun resetPosition() {
        if (keyboardParams == null) return
        
        // 1. Set Scale to 0.69f (Standard Reset Scale)
        val defaultScale = 0.69f
        internalScale = defaultScale
        keyboardView?.setScale(defaultScale)
        
        // Save preference
        context.getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
             .edit().putInt("keyboard_key_scale", 69).apply()

        // 2. Reset Rotation state
        currentRotation = 0
        keyboardContainer?.rotation = 0f
        keyboardView?.rotation = 0f
        keyboardView?.translationX = 0f
        keyboardView?.translationY = 0f

        // 3. Calculate Dimensions
        // Width: 90% of screen, capped at 1200px to prevent ultra-wide windows
        val defaultWidth = (screenWidth * 0.90f).toInt().coerceIn(300, 1200)
        
        // Height: Fixed Physical Height Calculation
        // Problem: Calculating height as % of width fails on wide screens (Beam Pro), creating huge empty space.
        // Solution: Use fixed DP height.
        // 300dp = Physical height of 7 rows (derived from your Flip 7 1080p setup).
        // This ensures the window is exactly tall enough for the keys on ANY device.
        val density = context.resources.displayMetrics.density
        val baseHeightDp = 300f
        val defaultHeight = (baseHeightDp * defaultScale * density).toInt()
        
        // Position: Center
        val defaultX = (screenWidth - defaultWidth) / 2
        val defaultY = (screenHeight / 2)

        // 4. Update Params
        keyboardWidth = defaultWidth
        keyboardHeight = defaultHeight
        
        // Reset Drag Anchors
        dragStartHeight = defaultHeight
        dragStartScale = defaultScale
        
        keyboardParams?.x = defaultX
        keyboardParams?.y = defaultY
        keyboardParams?.width = defaultWidth
        keyboardParams?.height = defaultHeight

        // 5. Force View to Fill Window
        if (keyboardView != null) {
            val lp = keyboardView!!.layoutParams as FrameLayout.LayoutParams
            lp.width = FrameLayout.LayoutParams.MATCH_PARENT
            lp.height = FrameLayout.LayoutParams.MATCH_PARENT 
            keyboardView!!.layoutParams = lp
        }

        try {
            windowManager.updateViewLayout(keyboardContainer, keyboardParams)
        } catch (e: Exception) {}
        
        saveKeyboardPosition()
        saveKeyboardSize()
        
        // 6. Sync Mirror
        syncMirrorRatio(defaultWidth, defaultHeight)
    }





    // [END ROTATION FIX] 


    fun show() { 
        if (isVisible) return
        try { 
            val prefs = context.getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
            currentAlpha = prefs.getInt("keyboard_alpha", 200)


            createKeyboardWindow()

            // [NEW] Initialize internal scale from prefs once on show
            // Default to 69 (0.69f) if missing, to match resetPosition
            val savedScale = prefs.getInt("keyboard_key_scale", 69) / 100f
            internalScale = savedScale
            dragStartScale = savedScale // Init for safety



            // [MODIFIED] Removed forced 0.55 aspect ratio listener to allow independent resizing.
            // Sync is now handled via explicit broadcast in resize functions.


            isVisible = true
            if (currentRotation != 0) setRotation(currentRotation)
        } catch (e: Exception) { android.util.Log.e("KeyboardOverlay", "Failed to show keyboard", e) } 
    }


    
    fun hide() { 
        if (!isVisible) return
        try { 
            windowManager.removeView(keyboardContainer)
            keyboardContainer = null
            keyboardView = null
            isVisible = false 
        } catch (e: Exception) { Log.e(TAG, "Failed to hide keyboard", e) } 
    }
    
    fun toggle() { if (isVisible) hide() else show() }
    fun isShowing(): Boolean = isVisible

    fun setFocusable(focusable: Boolean) {
        try {
            if (keyboardContainer == null || keyboardParams == null) return

            if (focusable) {
                // Remove NOT_FOCUSABLE (Make it focusable)
                keyboardParams?.flags = keyboardParams?.flags?.and(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE.inv())
            } else {
                // Add NOT_FOCUSABLE (Make it click-through for focus purposes)
                keyboardParams?.flags = keyboardParams?.flags?.or(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)
            }
            windowManager.updateViewLayout(keyboardContainer, keyboardParams)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    // =================================================================================
    // FUNCTION: setVoiceActive
    // SUMMARY: Passes the voice state down to the keyboard view.
    // =================================================================================
    fun setVoiceActive(active: Boolean) {
        keyboardView?.setVoiceActive(active)
    }
    // =================================================================================
    // END BLOCK: setVoiceActive
    // =================================================================================

    fun setInputCaptureMode(active: Boolean) {
        keyboardView?.setInputCaptureMode(active)
    }

fun setCustomModKey(keyCode: Int) {
        cachedCustomModKey = keyCode // Cache it
        keyboardView?.setCustomModKey(keyCode) // Apply to current view
    }

    fun setOverrideSystemShortcuts(enabled: Boolean) {
        keyboardView?.setOverrideSystemShortcuts(enabled)
    }

    // =================================================================================
    // FUNCTION: setLauncherBlockedShortcuts
    // SUMMARY: Updates the set of shortcuts that should be blocked.
    //          Stores locally AND attempts to forward to KeyboardView if it exists.
    //          If KeyboardView doesn't exist yet, the shortcuts will be applied
    //          when show() creates it.
    // @param shortcuts - Set of "modifier|keyCode" strings from Launcher
    // =================================================================================
    fun setLauncherBlockedShortcuts(shortcuts: Set<String>) {
        launcherBlockedShortcuts = shortcuts
        Log.d(TAG, "Updated launcher blocked shortcuts: ${shortcuts.size} entries")

        // Try to apply to existing KeyboardView (may be null if not shown yet)
        if (keyboardView != null) {
            keyboardView?.setLauncherBlockedShortcuts(shortcuts)
            Log.d(TAG, "Applied blocked shortcuts to existing KeyboardView")
        } else {
            Log.d(TAG, "KeyboardView is null - shortcuts will be applied when show() is called")
        }
    }
    // =================================================================================
    // END FUNCTION: setLauncherBlockedShortcuts
    // =================================================================================

    // =================================================================================
    // VIRTUAL MIRROR ORIENTATION MODE METHODS
    // SUMMARY: Methods for managing orientation mode during virtual mirror operation.
    //          These handle the orange trail that helps users locate their finger
    //          position on the physical keyboard without looking at the screen.
    // =================================================================================

    // =================================================================================
    // FUNCTION: setOrientationMode
    // SUMMARY: Enables or disables orientation mode. When enabled, an orange trail
    //          is shown and key input is blocked until the mode ends.
    // @param active - true to enable orientation mode, false to disable
    // =================================================================================
    fun setOrientationMode(active: Boolean) {
        isOrientationModeActive = active
        keyboardView?.setOrientationModeActive(active)

        if (!active) {
            // Clear the orange trail when exiting orientation mode
            orientationTrailView?.clear()
        }
    }
    // =================================================================================
    // END BLOCK: setOrientationMode
    // =================================================================================

    // =================================================================================
    // FUNCTION: startOrientationTrail
    // SUMMARY: Starts a new orange orientation trail at the specified position.
    // @param x - Starting X coordinate
    // @param y - Starting Y coordinate
    // =================================================================================
    fun startOrientationTrail(x: Float, y: Float) {
        orientationTrailView?.clear()
        orientationTrailView?.addPoint(x, y)
    }
    // =================================================================================
    // END BLOCK: startOrientationTrail
    // =================================================================================

    // =================================================================================
    // FUNCTION: addOrientationTrailPoint
    // SUMMARY: Adds a point to the orange orientation trail.
    // @param x - X coordinate of new point
    // @param y - Y coordinate of new point
    // =================================================================================
    fun addOrientationTrailPoint(x: Float, y: Float) {
        orientationTrailView?.addPoint(x, y)
    }
    // =================================================================================
    // END BLOCK: addOrientationTrailPoint
    // =================================================================================

    // =================================================================================
    // FUNCTION: clearOrientationTrail
    // SUMMARY: Clears the orange orientation trail.
    // =================================================================================
    fun clearOrientationTrail() {
        orientationTrailView?.clear()
    }
    // =================================================================================
    // END BLOCK: clearOrientationTrail
    // =================================================================================

    // =================================================================================
    // FUNCTION: setOrientationTrailColor
    // SUMMARY: Sets the color of the orientation trail on the physical display.
    // =================================================================================
    fun setOrientationTrailColor(color: Int) {
        orientationTrailView?.setTrailColor(color)
    }
    // =================================================================================
    // END BLOCK: setOrientationTrailColor
    // =================================================================================

    // =================================================================================
    // FUNCTION: startSwipeFromCurrentPosition
    // SUMMARY: Called when switching from orange to blue trail mid-gesture.
    //          Initializes swipe tracking so the path starts from the given position.
    // =================================================================================
    fun startSwipeFromCurrentPosition(x: Float, y: Float) {
        keyboardView?.startSwipeFromPosition(x, y)
    }
    // =================================================================================
    // END BLOCK: startSwipeFromCurrentPosition
    // =================================================================================

    // =================================================================================
    // FUNCTION: handleDeferredTap
    // SUMMARY: Forwards deferred tap to KeyboardView for single key press in mirror mode.
    // =================================================================================

    fun handleDeferredTap(x: Float, y: Float) {
        // CRITICAL: If a tap is detected, immediately stop any pending repeat logic.
        // This prevents the "stuck" state where the system thinks you are still holding the key.
        stopMirrorRepeat()
        keyboardView?.handleDeferredTap(x, y)
    }
// =================================================================================
    // FUNCTION: getKeyAtPosition
    // SUMMARY: Returns the key tag at the given position, or null if no key found.
    //          Used by mirror mode to check if finger is on a repeatable key.
    // =================================================================================
    fun getKeyAtPosition(x: Float, y: Float): String? {
        return keyboardView?.getKeyAtPosition(x, y)
    }
    // =================================================================================
    // END BLOCK: getKeyAtPosition
    // =================================================================================

    // =================================================================================

    // =================================================================================
    // FUNCTION: triggerKeyPress (Updated with Tap-Reset Fix)
    // SUMMARY: Triggers a key press by key tag for Mirror Mode.
    //          Includes 400ms initial delay + Watchdog timeout.
    //          Now robustly resets if the sequence is broken.
    // =================================================================================
    private var activeRepeatKey: String? = null
    private var lastMirrorKeyTime = 0L
    private val mirrorRepeatHandler = Handler(Looper.getMainLooper())
    private val REPEAT_START_DELAY = 400L
    private val REPEAT_INTERVAL = 50L 
    
    // Watchdog: If no input received for 150ms, assume key was released
    // Increased to 150ms to be more tolerant of input jitters
    private val MIRROR_INPUT_TIMEOUT = 150L 

    private val mirrorRepeatRunnable = object : Runnable {
        override fun run() {
            val key = activeRepeatKey ?: return
            val now = System.currentTimeMillis()
            
            // Watchdog Check
            if (now - lastMirrorKeyTime > MIRROR_INPUT_TIMEOUT) {
                stopMirrorRepeat()
                return
            }

            // Fire event
            keyboardView?.triggerKeyPress(key)
            mirrorRepeatHandler.postDelayed(this, REPEAT_INTERVAL)
        }
    }

    // Changed from private to private-but-accessible-internally (or keep private if handleDeferredTap is in same class)
    private fun stopMirrorRepeat() {
        activeRepeatKey = null
        mirrorRepeatHandler.removeCallbacks(mirrorRepeatRunnable)
    }


    fun blockPrediction(index: Int) {
        keyboardView?.blockPredictionAtIndex(index)
    }


    fun triggerKeyPress(keyTag: String) {
        val isRepeatable = keyTag in setOf("BKSP", "DEL", "", "", "", "", "", "", "", "", "VOL+", "VOL-", "VOL_UP", "VOL_DOWN")

        if (!isRepeatable) {
            stopMirrorRepeat()
            keyboardView?.triggerKeyPress(keyTag)
            return
        }

        val now = System.currentTimeMillis()

        if (keyTag == activeRepeatKey) {
            // Update watchdog time
            lastMirrorKeyTime = now
            
            // ROBUSTNESS FIX: If for some reason the handler isn't running (race condition),
            // restart it to ensure we don't get stuck in a silent state.
            if (!mirrorRepeatHandler.hasCallbacks(mirrorRepeatRunnable)) {
                mirrorRepeatHandler.postDelayed(mirrorRepeatRunnable, REPEAT_START_DELAY)
            }
        } else {
            // New Key Sequence
            stopMirrorRepeat()
            
            activeRepeatKey = keyTag
            lastMirrorKeyTime = now
            
            // Start Delay (Wait 400ms before first fire)
            mirrorRepeatHandler.postDelayed(mirrorRepeatRunnable, REPEAT_START_DELAY)
        }
    }
   // FUNCTION: getKeyboardState
    // SUMMARY: Gets current keyboard state (layer) from KeyboardView.
    // =================================================================================
    fun getKeyboardState(): KeyboardView.KeyboardState? {
        return keyboardView?.getKeyboardState()
    }

    // =================================================================================
    // FUNCTION: setKeyboardState
    // SUMMARY: Sets keyboard state (layer) in KeyboardView.
    // =================================================================================
    fun setKeyboardState(state: KeyboardView.KeyboardState) {
        keyboardView?.setKeyboardState(state)
    }

    // =================================================================================
    // FUNCTION: getCtrlAltState
    // SUMMARY: Gets current Ctrl/Alt modifier states from KeyboardView.
    // =================================================================================
    fun getCtrlAltState(): Pair<Boolean, Boolean>? {
        return keyboardView?.getCtrlAltState()
    }

    // =================================================================================
    // FUNCTION: setCtrlAltState
    // SUMMARY: Sets Ctrl/Alt modifier states in KeyboardView.
    // =================================================================================
    fun setCtrlAltState(ctrl: Boolean, alt: Boolean) {
        keyboardView?.setCtrlAltState(ctrl, alt)
    }
    // =================================================================================
    // END BLOCK: State accessor functions for mirror sync
    // =================================================================================

    // =================================================================================
    // FUNCTION: updateSuggestionsWithSync
    // SUMMARY: Sets suggestions on the keyboard view AND notifies callback for mirror sync.
    // =================================================================================
    private fun updateSuggestionsWithSync(candidates: List<KeyboardView.Candidate>) {
        keyboardView?.setSuggestions(candidates)
        onSuggestionsChanged?.invoke(candidates)
    }
    // =================================================================================
    // END BLOCK: updateSuggestionsWithSync
    // =================================================================================

    // =================================================================================
    // FUNCTION: isInOrientationMode
    // SUMMARY: Returns whether orientation mode is currently active.
    // @return true if orientation mode is active
    // =================================================================================
    fun isInOrientationMode(): Boolean {
        return isOrientationModeActive
    }
    // =================================================================================
    // END BLOCK: isInOrientationMode
    // =================================================================================

    // =================================================================================
    // END BLOCK: VIRTUAL MIRROR ORIENTATION MODE METHODS
    // =================================================================================

    fun moveWindow(dx: Int, dy: Int) {
        if (!isVisible || keyboardParams == null) return
        keyboardParams!!.x += dx; keyboardParams!!.y += dy
        try { 
            windowManager.updateViewLayout(keyboardContainer, keyboardParams)
            saveKeyboardPosition()
            onSizeChanged?.invoke()
        } catch (e: Exception) {}
    }
    

    // [MODIFIED] Legacy support: Redirects to the new smart resize logic
    fun resizeWindow(dw: Int, dh: Int) {
        if (!isVisible || keyboardParams == null) return
        
        // Calculate target dimensions based on current params
        val currentW = if (keyboardParams!!.width > 0) keyboardParams!!.width else keyboardContainer?.width ?: 300
        val currentH = if (keyboardParams!!.height > 0) keyboardParams!!.height else keyboardContainer?.height ?: 200

        // Pass to the new centralized function that handles Scaling + Sync
        applyWindowResize(currentW + dw, currentH + dh)
        
        // [FIX] Save state so it persists
        saveKeyboardSize()
        saveKeyboardScale()
    }


    // =================================================================================
    // NEW: Centralized Resize Logic with Auto-Scale and Mirror Sync
    // =================================================================================

    // [MODIFIED] Deterministic Resizing Logic (Fixes Lag & Mismatch)
    private fun applyWindowResize(width: Int, height: Int) {
        if (keyboardParams == null) return

        val newWidth = max(300, width)
        val newHeight = max(150, height)
        
        // 1. Calculate New Scale Deterministically
        // Formula: NewScale = StartScale * (NewHeight / StartHeight)
        // This ensures the keys grow exactly proportional to the window drag.
        if (dragStartHeight > 0 && newHeight != dragStartHeight) {
             val heightRatio = newHeight.toFloat() / dragStartHeight.toFloat()
             val targetScale = dragStartScale * heightRatio
             
             // Update Internal State
             internalScale = targetScale
             keyboardView?.setScale(internalScale)
        }

        // 2. Update Window Params
        keyboardParams!!.width = newWidth
        keyboardParams!!.height = newHeight
        keyboardWidth = newWidth
        keyboardHeight = newHeight

        try {
            windowManager.updateViewLayout(keyboardContainer, keyboardParams)
            onSizeChanged?.invoke()
        } catch (e: Exception) {}

        // 3. Sync Mirror Aspect Ratio
        syncMirrorRatio(newWidth, newHeight)
    }


    fun handleResizeDpad(keyCode: Int): Boolean {
        if (!isVisible || keyboardParams == null) return false
        
        val STEP = 20
        var w = keyboardParams!!.width
        var h = keyboardParams!!.height
        var changed = false

        when (keyCode) {
            // Horizontal Only
            KeyEvent.KEYCODE_DPAD_LEFT -> { w -= STEP; changed = true }
            KeyEvent.KEYCODE_DPAD_RIGHT -> { w += STEP; changed = true }
            
            // Vertical Only
            KeyEvent.KEYCODE_DPAD_UP -> { h -= STEP; changed = true }   // Shrink Height
            KeyEvent.KEYCODE_DPAD_DOWN -> { h += STEP; changed = true } // Grow Height
        }

        if (changed) {
            applyWindowResize(w, h)
            saveKeyboardSize()  // [FIX] Save size immediately
            saveKeyboardScale() // [FIX] Save scale immediately
            return true
        }
        return false
    }

    private fun syncMirrorRatio(width: Int, height: Int) {
        try {
            val ratio = width.toFloat() / height.toFloat()
            val intent = android.content.Intent("com.katsuyamaki.DroidOSLauncher.SYNC_KEYBOARD_RATIO")
            intent.putExtra("ratio", ratio)
            intent.putExtra("width", width)
            intent.putExtra("height", height)
            intent.setPackage("com.katsuyamaki.DroidOSLauncher")
            context.sendBroadcast(intent)
        } catch (e: Exception) {
            android.util.Log.e("KeyboardOverlay", "Failed to sync mirror ratio", e)
        }
    }





    private fun createKeyboardWindow() {
        // [FIX] Use custom FrameLayout to intercept ALL touches.
        keyboardContainer = object : FrameLayout(context) {
            
            // SHIELD 1: Handle Mouse Hovers & Scroll (Enable Bluetooth Mouse)
            override fun dispatchGenericMotionEvent(event: MotionEvent): Boolean {
                if (event.isFromSource(InputDevice.SOURCE_MOUSE) ||
                    event.isFromSource(InputDevice.SOURCE_MOUSE_RELATIVE)) {

                    if (event.actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                        if (lastMouseX == 0f && lastMouseY == 0f) {
                            lastMouseX = event.x
                            lastMouseY = event.y
                            return true
                        }
                        val dx = event.x - lastMouseX
                        val dy = event.y - lastMouseY
                        lastMouseX = event.x
                        lastMouseY = event.y

                        // Pass as Hover (isDragging=false)
                        onCursorMove?.invoke(dx, dy, false)
                        return true
                    }

                    if (event.actionMasked == MotionEvent.ACTION_SCROLL) {
                        val v = event.getAxisValue(MotionEvent.AXIS_VSCROLL)
                        val h = event.getAxisValue(MotionEvent.AXIS_HSCROLL)
                        onMouseScroll?.invoke(h, v)
                        return true
                    }

                    return true
                }
                return super.dispatchGenericMotionEvent(event)
            }

            // SHIELD 2: Block Injected/Obscured Touches
            override fun dispatchTouchEvent(event: MotionEvent): Boolean {
                
                // [CRITICAL FIX] OBSCURED FILTER
                // If the touch is passing through another window (like our Cursor Overlay),
                // Android flags it as OBSCURED. We reject these to prevent the cursor loop.
                if ((event.flags and MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0 ||
                    (event.flags and MotionEvent.FLAG_WINDOW_IS_PARTIALLY_OBSCURED) != 0) {
                    return true
                }

                // 1. Block Non-Fingers (Except Mouse)
                val toolType = event.getToolType(0)
                val isMouse = toolType == MotionEvent.TOOL_TYPE_MOUSE || event.isFromSource(InputDevice.SOURCE_MOUSE)

                if (toolType != MotionEvent.TOOL_TYPE_FINGER && !isMouse) return true

                // 2. Block Virtual/Null Devices
                if (event.device == null || event.deviceId <= 0) return true

                // 3. Handle Mouse Inputs (Clicks/Drags)
                if (isMouse) {
                    when (event.actionMasked) {
                        MotionEvent.ACTION_DOWN -> {
                            lastMouseX = event.x
                            lastMouseY = event.y
                            isMouseDragging = false
                            onTouchDown?.invoke() // Start drag state in Service
                        }
                        MotionEvent.ACTION_MOVE -> {
                            val dx = event.x - lastMouseX
                            val dy = event.y - lastMouseY

                            if (kotlin.math.abs(dx) > 0 || kotlin.math.abs(dy) > 0) isMouseDragging = true

                            lastMouseX = event.x
                            lastMouseY = event.y
                            // Pass as Drag (isDragging=true)
                            onCursorMove?.invoke(dx, dy, true)
                        }
                        MotionEvent.ACTION_UP -> {
                            onTouchUp?.invoke()
                            if (!isMouseDragging) {
                                // Static click = Tap
                                onCursorClick?.invoke(false)
                            }
                            isMouseDragging = false
                        }
                    }
                    return true
                }

                val devId = event.deviceId
                val action = event.actionMasked

                when (action) {
                    MotionEvent.ACTION_DOWN -> {
                        // Lock onto the first physical finger. 
                        if (activeFingerDeviceId != -1 && activeFingerDeviceId != devId) {
                            return true
                        }
                        activeFingerDeviceId = devId
                    }
                    MotionEvent.ACTION_MOVE -> {
                        // GHOST BLOCK: If no physical finger is locked, IGNORE ALL MOVES.
                        if (activeFingerDeviceId == -1) return true
                        
                        // Strict Lock: Only allow the specific locked physical device.
                        if (devId != activeFingerDeviceId) return true
                    }
                    MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                        if (devId == activeFingerDeviceId) {
                            activeFingerDeviceId = -1
                        }
                    }
                }
                
                return super.dispatchTouchEvent(event)
            }
        }

        // [IMPORTANT] Enable security filter on the view itself as a backup
        keyboardContainer?.filterTouchesWhenObscured = true

        val containerBg = GradientDrawable()
        val fillColor = (currentAlpha shl 24) or (0x1A1A1A)
        containerBg.setColor(fillColor)
        containerBg.cornerRadius = 16f
        containerBg.setStroke(2, Color.parseColor("#44FFFFFF"))
        keyboardContainer?.background = containerBg
        
        keyboardContainer?.isFocusable = true
        keyboardContainer?.isFocusableInTouchMode = true
        keyboardContainer?.setOnKeyListener { _, keyCode, event ->
            if (event.action == KeyEvent.ACTION_DOWN) {
                if (handleResizeDpad(keyCode)) {
                    return@setOnKeyListener true
                }
            }
            false
        }

        // 1. The Keyboard Keys
        keyboardView = KeyboardView(context)

        // [FIX] Apply cached Custom Mod Key immediately on creation
        if (cachedCustomModKey != 0) {
            keyboardView?.setCustomModKey(cachedCustomModKey)
        }

        // SHIELD 3: Backup Generic Motion Listener
        keyboardView?.setOnGenericMotionListener { _, event ->
            if (event.isFromSource(InputDevice.SOURCE_MOUSE) || 
                event.isFromSource(InputDevice.SOURCE_MOUSE_RELATIVE)) {
                return@setOnGenericMotionListener true
            }
            false
        }

// =================================================================================
        // SPACEBAR MOUSE CURSOR MOVE CALLBACK BINDING
        // SUMMARY: Forwards cursor movement from KeyboardView's spacebar trackpad feature
        //          to OverlayService. The isDragging parameter indicates whether user is
        //          performing a hold-to-drag operation (true) or just moving cursor (false).
        //          When isDragging=true, OverlayService injects ACTION_MOVE with TOUCHSCREEN
        //          source; when false, it injects HOVER_MOVE with MOUSE source.
        // =================================================================================
        keyboardView?.cursorMoveAction = { dx, dy, isDragging ->
            // Pass through isDragging state to enable hold-to-drag functionality
            onCursorMove?.invoke(dx, dy, isDragging)
        }
        // =================================================================================
        // END BLOCK: SPACEBAR MOUSE CURSOR MOVE CALLBACK BINDING
        // =================================================================================

        // =================================================================================
        // ARROW KEYS SWIPE CALLBACK BINDING
        // SUMMARY: Forwards arrow swipe from KeyboardView to OverlayService
        // =================================================================================
        keyboardView?.onArrowSwipe = { dx, dy ->
            onArrowSwipe?.invoke(dx, dy)
        }
        // =================================================================================
        // END BLOCK: ARROW KEYS SWIPE CALLBACK BINDING
        // =================================================================================

        keyboardView?.cursorClickAction = { isRight ->
            onCursorClick?.invoke(isRight)
            // Fix: Reset swipe state on click to prevent accidental full-word delete
            lastCommittedSwipeWord = null
            resetComposition()
        }

        keyboardView?.touchDownAction = { 
            onTouchDown?.invoke()
            // Fix: Reset swipe state on drag start
            lastCommittedSwipeWord = null
            resetComposition()
        }
        
        keyboardView?.touchUpAction = { onTouchUp?.invoke() }
        
        keyboardView?.touchTapAction = { 
            onTouchTap?.invoke()
            // Fix: Reset swipe state on tap
            lastCommittedSwipeWord = null
            resetComposition() 
        }


        keyboardView?.mirrorTouchCallback = { x, y, action ->
            val cb = onMirrorTouch
            if (cb != null) cb.invoke(x, y, action) else false
        }

        keyboardView?.setKeyboardListener(this)
        val prefs = context.getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
        keyboardView?.setVibrationEnabled(prefs.getBoolean("vibrate", true))

        // =================================================================================
        // APPLY LAUNCHER BLOCKED SHORTCUTS TO NEW KEYBOARDVIEW
        // SUMMARY: The launcherBlockedShortcuts may have been set before the KeyboardView
        //          was created. Now that it exists, sync the blocked shortcuts to it.
        // =================================================================================
        if (launcherBlockedShortcuts.isNotEmpty()) {
            keyboardView?.setLauncherBlockedShortcuts(launcherBlockedShortcuts)
            Log.d(TAG, "Applied ${launcherBlockedShortcuts.size} blocked shortcuts to new KeyboardView")
        }
        // =================================================================================
        // END BLOCK: APPLY LAUNCHER BLOCKED SHORTCUTS TO NEW KEYBOARDVIEW
        // =================================================================================

        // [FIX] Load saved scale and update Internal State immediately
        // Use 69 as default to match resetPosition logic (prevent 1.0 mismatch)
        val scale = prefs.getInt("keyboard_key_scale", 69) / 100f
        internalScale = scale 
        keyboardView?.setScale(scale)
        
        keyboardView?.alpha = currentAlpha / 255f

        val kbParams = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)
        kbParams.setMargins(6, 28, 6, 6)
        keyboardContainer?.addView(keyboardView, kbParams)

        // 2. The Swipe Trail Overlay
        val trailView = SwipeTrailView(context)
        val trailParams = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)
        trailParams.setMargins(6, 28, 6, 6)
        keyboardContainer?.addView(trailView, trailParams)
        keyboardView?.attachTrailView(trailView)

        // ORIENTATION TRAIL VIEW
        orientationTrailView = SwipeTrailView(context)
        orientationTrailView?.setTrailColor(0xFFFF9900.toInt())
        val orientTrailParams = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.MATCH_PARENT,
            FrameLayout.LayoutParams.MATCH_PARENT
        )
        orientTrailParams.setMargins(6, 28, 6, 6)
        keyboardContainer?.addView(orientationTrailView, orientTrailParams)


        addDragHandle(); addResizeHandle(); addCloseButton(); addTargetLabel()

        // [FIX] Calculate Dynamic Defaults for "First Load"
        // This prevents the keyboard from loading with wrong aspect ratios (like WRAP_CONTENT)
        // if no preferences exist yet.
        
        // 1. Calculate Default Width (90% Screen)
        val defaultWidth = (screenWidth * 0.90f).toInt().coerceIn(300, 1200)
        
        // 2. Calculate Default Height (300dp * Scale)
        // If no scale is saved, we default to 0.69f (The "Reset" Scale)
        val density = context.resources.displayMetrics.density
        val savedScale = prefs.getInt("keyboard_key_scale", 69) / 100f
        val baseHeightDp = 300f
        val defaultHeight = (baseHeightDp * savedScale * density).toInt()
        
        val defaultX = (screenWidth - defaultWidth) / 2
        val defaultY = (screenHeight / 2)

        // 3. Load from Prefs (using our calculated defaults as fallback)
        val savedW = prefs.getInt("keyboard_width_d$currentDisplayId", defaultWidth)
        val savedH = prefs.getInt("keyboard_height_d$currentDisplayId", defaultHeight)
        val savedX = prefs.getInt("keyboard_x_d$currentDisplayId", defaultX)
        val savedY = prefs.getInt("keyboard_y_d$currentDisplayId", defaultY)

        // 4. Set Fields
        keyboardWidth = savedW
        keyboardHeight = savedH

        keyboardParams = WindowManager.LayoutParams(
            keyboardWidth,
            keyboardHeight,

            WindowManager.LayoutParams.TYPE_ACCESSIBILITY_OVERLAY,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or
            WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or
            WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,
            PixelFormat.TRANSLUCENT
        )
        keyboardParams?.gravity = Gravity.TOP or Gravity.LEFT
        keyboardParams?.x = savedX
        keyboardParams?.y = savedY

windowManager.addView(keyboardContainer, keyboardParams)
        updateAlpha(currentAlpha)
        
        // [FIX] Initialize Resize Anchors so D-pad/Scaling works immediately
        // This prevents the "Background resizes but Keys don't" bug on fresh load.
        dragStartHeight = keyboardHeight
        dragStartScale = internalScale

        // =================================================================================
        // SPACEBAR MOUSE EXTENDED MODE - APPLY PREFERENCE ON VIEW CREATION
        // =================================================================================
        val extendedModePref = context.getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
            .getBoolean("spacebar_mouse_extended", false)
        keyboardView?.setSpacebarExtendedMode(extendedModePref)
        android.util.Log.d("KeyboardOverlay", "Applied spacebar extended mode: $extendedModePref")
        
        // Connect callback for drag handle color updates
        keyboardView?.onExtendedModeChanged = { isActive ->
            updateDragHandleColor(isActive)
        }
        // =================================================================================
        // END BLOCK: SPACEBAR MOUSE EXTENDED MODE INITIALIZATION
        // =================================================================================
    }





    // =================================================================================
    // FUNCTION: addDragHandle
    // SUMMARY: Creates the drag handle at the top of the keyboard. The indicator bar
    //          changes color based on spacebar mouse extended mode state:
    //          - Grey (#555555): Normal state
    //          - Red (#FF5555): Extended mode active (tap to exit)
    //          Tapping (not dragging) the handle while in extended mode exits the mode.
    // =================================================================================
    private fun addDragHandle() {
        val handle = FrameLayout(context)
        val handleParams = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, 28)
        handleParams.gravity = Gravity.TOP
        
        // Create indicator bar
        val indicator = View(context)
        val indicatorBg = GradientDrawable()
        indicatorBg.setColor(Color.parseColor("#555555"))
        indicatorBg.cornerRadius = 3f
        indicator.background = indicatorBg
        
        // Store reference for color updates
        dragHandleIndicator = indicator
        
        val indicatorParams = FrameLayout.LayoutParams(50, 5)
        indicatorParams.gravity = Gravity.CENTER
        indicatorParams.topMargin = 8
        handle.addView(indicator, indicatorParams)
        
        // Variables to detect tap vs drag
        var touchStartX = 0f
        var touchStartY = 0f
        var isDragGesture = false
        val tapThreshold = 10f // pixels - movement less than this is a tap
        
        handle.setOnTouchListener { _, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    touchStartX = event.rawX
                    touchStartY = event.rawY
                    isDragGesture = false
                }
                MotionEvent.ACTION_MOVE -> {
                    val dx = kotlin.math.abs(event.rawX - touchStartX)
                    val dy = kotlin.math.abs(event.rawY - touchStartY)
                    if (dx > tapThreshold || dy > tapThreshold) {
                        isDragGesture = true
                    }
                }
                MotionEvent.ACTION_UP -> {
                    // If it was a tap (not a drag) and extended mode is active, exit mode
                    if (!isDragGesture) {
                        val kbView = keyboardView
                        if (kbView != null && kbView.isInSpacebarMouseMode()) {
                            android.util.Log.d("KeyboardOverlay", "Drag handle tapped - exiting extended mode")
                            kbView.exitSpacebarMouseMode()
                            updateDragHandleColor(false)
                            // Haptic feedback
                            handle.performHapticFeedback(android.view.HapticFeedbackConstants.REJECT)
                            return@setOnTouchListener true
                        }
                    }
                }
            }
            // Pass to normal drag handling
            handleDrag(event)
            true
        }
        
        keyboardContainer?.addView(handle, handleParams)
    }
    // =================================================================================
    // END BLOCK: addDragHandle
    // =================================================================================
    // =================================================================================
    // FUNCTION: updateDragHandleColor
    // SUMMARY: Updates the drag handle indicator color based on spacebar mouse extended
    //          mode state. Red when active (indicating tap to exit), grey when inactive.
    //          Called from KeyboardView when extended mode state changes.
    // =================================================================================
    fun updateDragHandleColor(extendedModeActive: Boolean) {
        val indicator = dragHandleIndicator ?: return
        val bg = indicator.background as? GradientDrawable ?: return
        
        if (extendedModeActive) {
            bg.setColor(Color.parseColor("#FF5555")) // Red - tap to exit
        } else {
            bg.setColor(Color.parseColor("#555555")) // Grey - normal
        }
        indicator.invalidate()
        
        android.util.Log.d("KeyboardOverlay", "Drag handle color updated: extended=$extendedModeActive")
    }
    // =================================================================================
    // END BLOCK: updateDragHandleColor
    // =================================================================================

    private fun addResizeHandle() {
        val handle = FrameLayout(context); val handleParams = FrameLayout.LayoutParams(36, 36); handleParams.gravity = Gravity.BOTTOM or Gravity.RIGHT
        val indicator = View(context); val indicatorBg = GradientDrawable(); indicatorBg.setColor(Color.parseColor("#3DDC84")); indicatorBg.cornerRadius = 4f; indicator.background = indicatorBg; indicator.alpha = 0.7f
        val indicatorParams = FrameLayout.LayoutParams(14, 14); indicatorParams.gravity = Gravity.BOTTOM or Gravity.RIGHT; indicatorParams.setMargins(0, 0, 6, 6)
        handle.addView(indicator, indicatorParams); handle.setOnTouchListener { _, event -> handleResize(event); true }
        keyboardContainer?.addView(handle, handleParams)
    }

    private fun addCloseButton() {
        val button = FrameLayout(context); val buttonParams = FrameLayout.LayoutParams(28, 28); buttonParams.gravity = Gravity.TOP or Gravity.RIGHT; buttonParams.setMargins(0, 2, 4, 0)
        val closeText = TextView(context); closeText.text = "X"; closeText.setTextColor(Color.parseColor("#FF5555")); closeText.textSize = 12f; closeText.gravity = Gravity.CENTER
        // CHANGED: Call onCloseAction to notify Service (handles IME toggle & automation)
        button.addView(closeText, FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)); button.setOnClickListener { onCloseAction() }
        keyboardContainer?.addView(button, buttonParams)
    }

    private fun addTargetLabel() {
        val label = TextView(context); label.text = "Display $targetDisplayId"; label.setTextColor(Color.parseColor("#888888")); label.textSize = 9f
        val labelParams = FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT); labelParams.gravity = Gravity.TOP or Gravity.LEFT; labelParams.setMargins(8, 6, 0, 0)
        keyboardContainer?.addView(label, labelParams)
    }

    private fun handleDrag(event: MotionEvent): Boolean {
        if (isAnchored) return true
        when (event.action) {
            MotionEvent.ACTION_DOWN -> { 
                isMoving = true
                initialTouchX = event.rawX
                initialTouchY = event.rawY
                initialWindowX = keyboardParams?.x ?: 0
                initialWindowY = keyboardParams?.y ?: 0 
            }
            MotionEvent.ACTION_MOVE -> { 
                if (isMoving) { 
                    keyboardParams?.x = initialWindowX + (event.rawX - initialTouchX).toInt()
                    keyboardParams?.y = initialWindowY + (event.rawY - initialTouchY).toInt()
                    try { windowManager.updateViewLayout(keyboardContainer, keyboardParams) } catch (e: Exception) {} 
                } 
            }
            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> { 
                isMoving = false
                saveKeyboardPosition() 
            }
        }
        return true
    }

    // [START RESIZE FIX]
    private fun handleResize(event: MotionEvent): Boolean {
        if (isAnchored) return true
        when (event.action) {

            MotionEvent.ACTION_DOWN -> {
                isResizing = true
                initialTouchX = event.rawX
                initialTouchY = event.rawY
                
                initialWidth = keyboardParams?.width ?: keyboardWidth
                initialHeight = keyboardParams?.height ?: keyboardHeight
                
                // Resolve WRAP_CONTENT to actual pixels
                if (initialWidth < 0) initialWidth = keyboardContainer?.width ?: 300
                if (initialHeight < 0) initialHeight = keyboardContainer?.height ?: 200
                
                // [FIX] Capture stable start values for deterministic scaling
                dragStartHeight = initialHeight
                dragStartScale = internalScale
            }


            MotionEvent.ACTION_MOVE -> {
                if (isResizing) {
                    val dX = (event.rawX - initialTouchX).toInt()
                    val dY = (event.rawY - initialTouchY).toInt()
                    
                    val newW = initialWidth + dX
                    val newH = initialHeight + dY
                    
                    // Use the shared function to handle visual update + scale + sync
                    // Note: We might want to throttle 'saveKeyboardSize' inside applyWindowResize during drag
                    // but for now this ensures visual consistency.
                    applyWindowResize(newW, newH)
                }
            }

            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                isResizing = false
                saveKeyboardSize()
                saveKeyboardScale() // [FIX] Persist scale so aspect ratio survives hide/unhide
            }
        }
        return true
    }
    // [END RESIZE FIX]

    private fun saveKeyboardSize() { context.getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE).edit().putInt("keyboard_width_d$currentDisplayId", keyboardWidth).putInt("keyboard_height_d$currentDisplayId", keyboardHeight).apply() }
    private fun saveKeyboardScale() { 
        context.getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
            .edit().putInt("keyboard_key_scale", (internalScale * 100).toInt()).apply() 
    }
    private fun saveKeyboardPosition() { context.getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE).edit().putInt("keyboard_x_d$currentDisplayId", keyboardParams?.x ?: 0).putInt("keyboard_y_d$currentDisplayId", keyboardParams?.y ?: 0).apply() }
    private fun loadKeyboardSizeForDisplay(displayId: Int) { val prefs = context.getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE); keyboardWidth = prefs.getInt("keyboard_width_d$displayId", keyboardWidth); keyboardHeight = prefs.getInt("keyboard_height_d$displayId", keyboardHeight) }


    // =================================================================================
    // FUNCTION: onKeyPress
    // SUMMARY: Handles key press events from the keyboard. Manages composing word state,
    //          sentence start detection, and auto-learning. Special handling for
    //          punctuation after swiped words to remove the trailing space.
    // =================================================================================
    // =================================================================================
    // FUNCTION: onKeyPress
    // SUMMARY: Handles key press events from the keyboard. Manages composing word state,
    //          sentence start detection, and auto-learning.
    //          
    // UPDATED: 
    //   - Apostrophe (') is now part of words for "don't", "won't", etc.
    //   - Tracks originalCaseWord for "DroidOS", "iPhone" etc.
    //   - Shift keys don't clear composition
    //   - Properly clears prediction bar on space/enter
    // =================================================================================
    override fun onKeyPress(keyCode: Int, char: Char?, metaState: Int) {
        // android.util.Log.d("DroidOS_Key", "Press: keyCode=$keyCode char='$char' meta=$metaState")

        // --- SHIFT KEY: Ignore completely, don't affect composition ---
        if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || 
            keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT ||
            keyCode == KeyEvent.KEYCODE_CAPS_LOCK) {
            // Don't inject shift as a key, just return
            // The keyboard handles shift state internally
            return
        }

        // --- PUNCTUATION AFTER SWIPE: Remove trailing space ---
        val isEndingPunctuation = char != null && (char == '.' || char == ',' || char == '!' ||
                                          char == '?' || char == ';' || char == ':' || char == '"')

        if (isEndingPunctuation && lastCommittedSwipeWord != null && lastCommittedSwipeWord!!.endsWith(" ")) {
            injectKey(KeyEvent.KEYCODE_DEL, 0)
            android.util.Log.d("DroidOS_Swipe", "PUNCTUATION: Removed trailing space before '$char'")
            lastCommittedSwipeWord = lastCommittedSwipeWord!!.trimEnd()
        }

        // 1. Inject the key event
        injectKey(keyCode, metaState)

// 2. Handle Backspace - delete from composing word
        if (keyCode == KeyEvent.KEYCODE_DEL) {
            if (currentComposingWord.isNotEmpty()) {
                currentComposingWord.deleteCharAt(currentComposingWord.length - 1)
                originalCaseWord.deleteCharAt(originalCaseWord.length - 1)
                android.util.Log.d("DroidOS_Compose", "BACKSPACE: Now composing '$originalCaseWord'")
                updateSuggestions()
            } else {
                // Composing word is empty, clear prediction bar
                updateSuggestionsWithSync(emptyList())
            }
            return
        }


        // 3. Handle Enter - clears everything
        if (keyCode == KeyEvent.KEYCODE_ENTER) {
            isSentenceStart = true
            predictionEngine.clearContext()  // Clear context at sentence boundary
            lastCommittedSwipeWord = null

            currentComposingWord.clear()
            originalCaseWord.clear()
            updateSuggestionsWithSync(emptyList())  // CLEAR prediction bar
            return
        }

                // 4. Handle Space - clears composition, clears prediction bar
        if (char != null && Character.isWhitespace(char)) {
            isSentenceStart = false
            lastCommittedSwipeWord = null
            predictionEngine.clearTemporaryPenalties() // Manual typing clears penalties
            currentComposingWord.clear()
            originalCaseWord.clear()
            updateSuggestionsWithSync(emptyList())  // CLEAR prediction bar
            return
        }


        // 5. Handle ending punctuation (. , ! ? ; : ") - clears composition
        if (isEndingPunctuation) {
            if (char == '.' || char == '!' || char == '?') {
                isSentenceStart = true
                predictionEngine.clearContext()  // Clear context at sentence boundary
            }
            lastCommittedSwipeWord = null

            currentComposingWord.clear()
            originalCaseWord.clear()
            updateSuggestionsWithSync(emptyList())  // CLEAR prediction bar
            return
        }

        // 6. Handle letters, digits, and apostrophe - ADD to composition
        if (char != null && (Character.isLetterOrDigit(char) || char == '\'')) {
            // Clear swipe history when manually typing
            lastCommittedSwipeWord = null
            
            // Add to composition trackers
            currentComposingWord.append(char.lowercaseChar())  // Lowercase for lookup
            originalCaseWord.append(char)  // Original case for display/saving
            
            isSentenceStart = false
            updateSuggestions()
            // android.util.Log.d("DroidOS_Compose", "Composing: '$originalCaseWord' (lookup: '$currentComposingWord')")
            return
        }

        // 7. Any other character - ignore, don't clear composition
        // This prevents random symbols from breaking the composition
        // android.util.Log.d("DroidOS_Key", "Ignored char: '$char'")
    }
    // =================================================================================
    // END BLOCK: onKeyPress with proper clearing and case tracking
    // =================================================================================
    // =================================================================================
    // END BLOCK: onKeyPress with punctuation spacing fix
    // =================================================================================

    
    override fun onTextInput(text: String) {
        if (shellService == null) return
        Thread { try { val cmd = "input -d $targetDisplayId text \"$text\""; shellService.runCommand(cmd) } catch (e: Exception) { Log.e(TAG, "Text injection failed", e) } }.start()
    }

    override fun onScreenToggle() { onScreenToggleAction() }
    override fun onScreenModeChange() { onScreenModeChangeAction() }

    override fun onSpecialKey(key: KeyboardView.SpecialKey, metaState: Int) {
        if (key == KeyboardView.SpecialKey.VOICE_INPUT) {
            triggerVoiceTyping()
            return
        }
        if (key == KeyboardView.SpecialKey.HIDE_KEYBOARD) {
            onCloseAction() // Calls the close/hide action passed from Service
            return
        }

        // =================================================================================
        // BACKSPACE HANDLING - SWIPE WORD DELETE
        // SUMMARY: If the last action was a swipe word commit, backspace deletes the
        //          entire word (plus trailing space). Otherwise, normal backspace behavior.
        //          This allows quick correction of mis-swiped words.
        // =================================================================================
        if (key == KeyboardView.SpecialKey.BACKSPACE) {
            // CHECK: Was the last input a swiped word?

            if (lastCommittedSwipeWord != null && lastCommittedSwipeWord!!.isNotEmpty()) {
                // Delete the entire swiped word (including trailing space)
                val deleteCount = lastCommittedSwipeWord!!.length
                android.util.Log.d("DroidOS_Swipe", "BACKSPACE: Deleting swiped word '${lastCommittedSwipeWord}' ($deleteCount chars)")

                // [FIX] Use Bulk Delete for reliability (especially with KB Blocker)
                (context as? OverlayService)?.injectBulkDelete(deleteCount)

                // NEGATIVE REINFORCEMENT: Penalize this word temporarily
                predictionEngine.penalizeWord(lastCommittedSwipeWord!!.trim())

                // Clear the swipe history so next backspace is normal
                lastCommittedSwipeWord = null

                
                // Also clear composition state
                currentComposingWord.clear()
                originalCaseWord.clear()
                updateSuggestionsWithSync(emptyList())

                // Don't inject another backspace - we already deleted
                return
            }

            // Normal backspace: delete from composing word
            if (currentComposingWord.isNotEmpty()) {
                currentComposingWord.deleteCharAt(currentComposingWord.length - 1)
                originalCaseWord.deleteCharAt(originalCaseWord.length - 1)
                android.util.Log.d("DroidOS_Compose", "BACKSPACE (special): Now composing '$originalCaseWord'")
                updateSuggestions()
            } else {
                // Nothing to delete from composition, clear prediction bar
                updateSuggestionsWithSync(emptyList())
            }
        } else if (key == KeyboardView.SpecialKey.SPACE) {
            // Space clears swipe history (user is continuing to type)
            lastCommittedSwipeWord = null
            resetComposition()
        } else {
            // Enter, Tabs, Arrows all break the current word chain
            lastCommittedSwipeWord = null
            resetComposition()
        }
        // =================================================================================
        // END BLOCK: BACKSPACE HANDLING - SWIPE WORD DELETE
        // =================================================================================

        val keyCode = when (key) {
            KeyboardView.SpecialKey.BACKSPACE -> KeyEvent.KEYCODE_DEL
            KeyboardView.SpecialKey.ENTER -> KeyEvent.KEYCODE_ENTER
            KeyboardView.SpecialKey.SPACE -> KeyEvent.KEYCODE_SPACE
            KeyboardView.SpecialKey.TAB -> KeyEvent.KEYCODE_TAB
            KeyboardView.SpecialKey.ESCAPE -> KeyEvent.KEYCODE_ESCAPE
            KeyboardView.SpecialKey.ARROW_UP -> KeyEvent.KEYCODE_DPAD_UP
            KeyboardView.SpecialKey.ARROW_DOWN -> KeyEvent.KEYCODE_DPAD_DOWN
            KeyboardView.SpecialKey.ARROW_LEFT -> KeyEvent.KEYCODE_DPAD_LEFT
            KeyboardView.SpecialKey.ARROW_RIGHT -> KeyEvent.KEYCODE_DPAD_RIGHT
            KeyboardView.SpecialKey.HOME -> KeyEvent.KEYCODE_MOVE_HOME
            KeyboardView.SpecialKey.END -> KeyEvent.KEYCODE_MOVE_END
            KeyboardView.SpecialKey.DELETE -> KeyEvent.KEYCODE_FORWARD_DEL
            KeyboardView.SpecialKey.MUTE -> KeyEvent.KEYCODE_VOLUME_MUTE
            KeyboardView.SpecialKey.VOL_UP -> KeyEvent.KEYCODE_VOLUME_UP
            KeyboardView.SpecialKey.VOL_DOWN -> KeyEvent.KEYCODE_VOLUME_DOWN
            KeyboardView.SpecialKey.BACK_NAV -> KeyEvent.KEYCODE_BACK
            KeyboardView.SpecialKey.FWD_NAV -> KeyEvent.KEYCODE_FORWARD
            else -> return
        }
        injectKey(keyCode, metaState)
    }


    // =================================================================================
    // =================================================================================
    // FUNCTION: onSuggestionClick
    // SUMMARY: Handles when user taps a word in the prediction bar.
    //          Uses Gboard-style "completion" approach - instead of delete-all + retype,
    //          we calculate what's already typed correctly and only append the suffix.
    //          This avoids race conditions with Null Keyboard's async broadcast system.
    //
    //          SCENARIO 1: Swipe Correction - must delete previous swipe word, then type new
    //          SCENARIO 2: Manual Typing Completion - just append remaining suffix (no delete!)
    //          SCENARIO 3: Manual Typing with typo - delete only the mismatched portion
    // =================================================================================

    override fun onSuggestionClick(text: String, isNew: Boolean) {
        android.util.Log.d("DroidOS_Prediction", "=== SUGGESTION CLICK START ===")
        android.util.Log.d("DroidOS_Prediction", "Clicked word: '$text' (isNew=$isNew)")
        
        // FIX: Tell the engine we selected this word so it can learn!
        predictionEngine.recordSelection(context, text)
        
        // SUCCESS: Manual selection clears penalties
        predictionEngine.clearTemporaryPenalties()
        
        android.util.Log.d("DroidOS_Prediction", "currentComposingWord: '${currentComposingWord}'")

        android.util.Log.d("DroidOS_Prediction", "lastCommittedSwipeWord: '$lastCommittedSwipeWord'")

        // 1. Learn word if it was flagged as New
        if (isNew) {
            predictionEngine.learnWord(context, text, isSentenceStart)
            android.util.Log.d("DroidOS_Learn", "Learning new word: '$text' (sentenceStart=$isSentenceStart)")
        }

        // 2. Handle based on scenario
        if (!lastCommittedSwipeWord.isNullOrEmpty()) {
            // =====================================================================
            // SCENARIO 1: Correcting a previously swiped word
            // =====================================================================
            // We MUST delete the full swipe word because swipe doesn't leave
            // composing text - it commits directly. Use bulk delete for efficiency.
            val deleteCount = lastCommittedSwipeWord!!.length
            android.util.Log.d("DroidOS_Prediction", "SCENARIO 1: Swipe correction, deleting $deleteCount chars")
            
            (context as? OverlayService)?.injectBulkDelete(deleteCount)
            
            // Small delay to let delete complete before inserting
            // This is necessary because bulk delete is async via broadcast
            Handler(Looper.getMainLooper()).postDelayed({
                val newText = "$text "
                injectText(newText)
                
                // Update state
                lastCommittedSwipeWord = newText
                currentComposingWord.clear()
                originalCaseWord.clear()
                updateSuggestionsWithSync(emptyList())
                android.util.Log.d("DroidOS_Prediction", "Swipe correction complete: '$newText'")
            }, 50) // 50ms delay for delete to process
            
        } else if (currentComposingWord.isNotEmpty()) {
            // =====================================================================
            // SCENARIO 2 & 3: Manual Typing - Use Gboard-style completion
            // =====================================================================
            // Instead of delete-all + retype, calculate the suffix we need to append
            
            val typed = currentComposingWord.toString().lowercase()
            val target = text.lowercase()
            
            android.util.Log.d("DroidOS_Prediction", "Typed: '$typed', Target: '$target'")
            
            // Find how many characters at the start match
            var matchLength = 0
            for (i in typed.indices) {
                if (i < target.length && typed[i] == target[i]) {
                    matchLength++
                } else {
                    break // First mismatch found
                }
            }
            
            android.util.Log.d("DroidOS_Prediction", "Match length: $matchLength out of ${typed.length} typed")
            
            // Calculate what to delete (typos) and what to append (completion)
            val charsToDelete = typed.length - matchLength
            val suffixToAppend = if (matchLength < text.length) {
                text.substring(matchLength)
            } else {
                ""
            }
            
            android.util.Log.d("DroidOS_Prediction", "Will delete $charsToDelete chars, append: '$suffixToAppend'")
            
            if (charsToDelete > 0) {
                // SCENARIO 3: There's a typo - delete mismatched portion first
                (context as? OverlayService)?.injectBulkDelete(charsToDelete)
                
                // Delay before appending to let delete complete
                Handler(Looper.getMainLooper()).postDelayed({
                    val appendText = "$suffixToAppend "
                    if (appendText.length > 1) { // More than just space
                        injectText(appendText)
                    } else {
                        // Just space
                        injectText(" ")
                    }
                    
                    // Update state
                    lastCommittedSwipeWord = "$text "
                    currentComposingWord.clear()
                    originalCaseWord.clear()
                    updateSuggestionsWithSync(emptyList())
                    android.util.Log.d("DroidOS_Prediction", "Typo correction complete, appended: '$appendText'")
                }, 50) // 50ms delay
                
            } else {
                // SCENARIO 2: Pure completion - NO DELETE NEEDED!
                // This is the common case and is race-condition-free
                val appendText = "$suffixToAppend "
                injectText(appendText)
                
                // Update state immediately (no async delete to wait for)
                lastCommittedSwipeWord = "$text "
                currentComposingWord.clear()
                originalCaseWord.clear()
                updateSuggestionsWithSync(emptyList())
                android.util.Log.d("DroidOS_Prediction", "Pure completion: appended '$appendText'")
            }
            
        } else {
            // =====================================================================
            // SCENARIO 4: No composing word (edge case - just insert the word)
            // =====================================================================
            android.util.Log.d("DroidOS_Prediction", "SCENARIO 4: No composing word, inserting full word")
            val newText = "$text "
            injectText(newText)
            lastCommittedSwipeWord = newText
            updateSuggestionsWithSync(emptyList())
        }
        
        android.util.Log.d("DroidOS_Prediction", "=== SUGGESTION CLICK END ===")
    }
    // =================================================================================
    // END BLOCK: onSuggestionClick - Gboard-style completion approach
    // This implementation avoids delete race conditions by:
    // 1. For swipe corrections: uses bulk delete with small delay before insert
    // 2. For typing completion: only appends the suffix (no delete at all!)
    // 3. For typos: deletes only the mismatched portion, then appends
    // =================================================================================
    // =================================================================================
    // FUNCTION: onSuggestionDropped
    // SUMMARY: Called when user drags a suggestion to backspace to delete/block it.
    //          DEBUG: Logging to confirm this is being called.
    // =================================================================================
    override fun onSuggestionDropped(text: String) {
        android.util.Log.d("DroidOS_Drag", ">>> onSuggestionDropped CALLED: '$text'")

        // Block the word
        predictionEngine.blockWord(context, text)

        android.widget.Toast.makeText(context, "Removed: $text", android.widget.Toast.LENGTH_SHORT).show()

        // Refresh suggestions to remove the blocked word
        updateSuggestions()

        android.util.Log.d("DroidOS_Drag", "<<< onSuggestionDropped COMPLETE: '$text' blocked")
    }
    // =================================================================================
    // END BLOCK: onSuggestionDropped with debug logging
    // =================================================================================

    // Layer change notification for mirror keyboard sync
    override fun onLayerChanged(state: KeyboardView.KeyboardState) {
        onLayerChanged?.invoke(state)
    }

    // =================================================================================
    // FUNCTION: onSwipeDetected
    // SUMMARY: Handles swipe gesture completion. Runs decoding in background thread.
    //          OPTIMIZED: Reduced logging for better performance.
    // =================================================================================

    // =================================================================================
    // FUNCTION: onSwipeDetectedTimed (PHASE 2 - Dual Algorithm with Color Coding)
    // SUMMARY: Receives swipe path and gets predictions from dual algorithm.
    //          Winner is selected based on swipe speed:
    //            - Slow swipes: PRECISE wins (GREEN text)
    //            - Fast swipes: SHAPE_CONTEXT wins (BLUE text)
    // =================================================================================
    override fun onSwipeDetectedTimed(path: List<TimedPoint>) {
        if (keyboardView == null || path.size < 3) return

        val keyMap = keyboardView?.getKeyCenters()
        if (keyMap.isNullOrEmpty()) return

        // Run dual prediction in background
        Thread {
            try {
                // decodeSwipeTimed now returns List<SwipeResult>
                val results = predictionEngine.decodeSwipeTimed(path, keyMap)
                
                if (results.isEmpty()) {
                    android.util.Log.d("DroidOS_Swipe", "DUAL DECODE: No suggestions returned")
                    return@Thread
                }
                
                val winner = results.first()
                android.util.Log.d("DroidOS_Swipe", "DUAL DECODE: Winner='${winner.word}' via ${winner.source}")

                handler.post {
                    var bestMatch = winner.word
                    val winningSource = winner.source
                    val isCap = isSentenceStart

                    if (isCap) {
                        bestMatch = bestMatch.replaceFirstChar { 
                            if (it.isLowerCase()) it.titlecase() else it.toString() 
                        }
                    }

                    // Build display suggestions with source info for color coding
                    val displaySuggestions = results.map { result ->
                        var word = result.word
                        if (isCap) {
                            word = word.replaceFirstChar { c -> c.titlecase() }
                        }
                        KeyboardView.Candidate(
                            text = word, 
                            isNew = false,
                            isCustom = predictionEngine.isCustomWord(result.word),
                            source = result.source  // Pass source for color coding!
                        )
                    }

                    updateSuggestionsWithSync(displaySuggestions)

                    // Commit text with proper spacing
                    var textToCommit = bestMatch
                    if (currentComposingWord.isNotEmpty()) {
                        textToCommit = " $bestMatch"
                        currentComposingWord.clear()
                    }
                    textToCommit = "$textToCommit "

                    injectText(textToCommit)
                    
                    // Update context model for future predictions
                    predictionEngine.updateContextModel(bestMatch)
                    
                    // SUCCESS: We committed a new word, so clear any previous backspace penalties
                    predictionEngine.clearTemporaryPenalties()
                    
                    lastCommittedSwipeWord = textToCommit
                    isSentenceStart = false
                    
                    // Clear composition state
                    currentComposingWord.clear()
                    originalCaseWord.clear()
                }
            } catch (e: Exception) {
                android.util.Log.e("DroidOS_Swipe", "Dual swipe decode error: ${e.message}")
                e.printStackTrace()
            }
        }.start()
    }
    // =================================================================================
    // END BLOCK: onSwipeDetectedTimed
    // =================================================================================

    // =================================================================================
    // FUNCTION: onSwipeDetected (Legacy - now just logs, actual work done in Timed version)
    // =================================================================================
    override fun onSwipeDetected(path: List<android.graphics.PointF>) {
        if (keyboardView == null) return
        
        val keyMap = keyboardView?.getKeyCenters()
        if (keyMap.isNullOrEmpty()) return

        Thread {
            try {
                val suggestions = predictionEngine.decodeSwipe(path, keyMap)

                if (suggestions.isNotEmpty()) {
                    handler.post {
                        var bestMatch = suggestions[0]
                        if (isSentenceStart) {
                            bestMatch = bestMatch.replaceFirstChar { 
                                if (it.isLowerCase()) it.titlecase() else it.toString() 
                            }
                        }

                        val isCap = Character.isUpperCase(bestMatch.firstOrNull() ?: ' ')
                        val displaySuggestions = if (isCap) {
                            suggestions.map { it.replaceFirstChar { c -> c.titlecase() } }
                        } else {
                            suggestions
                        }.map { KeyboardView.Candidate(it, isNew = false) }

                        updateSuggestionsWithSync(displaySuggestions)

                        // Commit text with proper spacing
                        var textToCommit = bestMatch
                        if (currentComposingWord.isNotEmpty()) {
                            textToCommit = " $bestMatch"
                            currentComposingWord.clear()
                        }
                        textToCommit = "$textToCommit "

                        injectText(textToCommit)
                        lastCommittedSwipeWord = textToCommit
                        isSentenceStart = false
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("DroidOS_Swipe", "Swipe decode error: ${e.message}")
            }
        }.start()
    }
    // =================================================================================
    // END BLOCK: onSwipeDetected
    // =================================================================================

    // =================================================================================

    // =================================================================================
    // FUNCTION: onSwipeProgress (PHASE 3 - Dual Live Preview)
    // SUMMARY: Shows BOTH algorithms' predictions during swiping.
    //          Left slot = Precise (GREEN), Middle slot = Shape (BLUE)
    //          This lets users see what both algorithms predict in real-time.
    // =================================================================================
    override fun onSwipeProgress(path: List<android.graphics.PointF>) {
        if (keyboardView == null || path.size < 5) return
        
        val keyMap = keyboardView?.getKeyCenters()
        if (keyMap.isNullOrEmpty()) return

        // Run dual preview in background
        Thread {
            try {
                val (preciseResult, shapeResult) = predictionEngine.decodeSwipeDualPreview(path, keyMap)

                // Only update if we have at least one result
                if (preciseResult != null || shapeResult != null) {
                    handler.post {
                        val isCap = isSentenceStart
                        val displaySuggestions = mutableListOf<KeyboardView.Candidate>()
                        
                        // LEFT SLOT: Precise prediction (GREEN)
                        if (preciseResult != null) {
                            var word = preciseResult.word
                            if (isCap) {
                                word = word.replaceFirstChar { c -> c.titlecase() }
                            }
                            displaySuggestions.add(KeyboardView.Candidate(
                                text = word,
                                isNew = false,
                                isCustom = predictionEngine.isCustomWord(preciseResult.word),
                                source = PredictionSource.PRECISE
                            ))
                        } else {
                            // Empty placeholder to maintain layout
                            displaySuggestions.add(KeyboardView.Candidate("", false, false, null))
                        }
                        
                        // MIDDLE SLOT: Shape/Context prediction (BLUE)
                        if (shapeResult != null) {
                            var word = shapeResult.word
                            if (isCap) {
                                word = word.replaceFirstChar { c -> c.titlecase() }
                            }
                            displaySuggestions.add(KeyboardView.Candidate(
                                text = word,
                                isNew = false,
                                isCustom = predictionEngine.isCustomWord(shapeResult.word),
                                source = PredictionSource.SHAPE_CONTEXT
                            ))
                        } else {
                            displaySuggestions.add(KeyboardView.Candidate("", false, false, null))
                        }
                        
                        // RIGHT SLOT: Empty during preview (filled on completion)
                        displaySuggestions.add(KeyboardView.Candidate("", false, false, null))

                        updateSuggestionsWithSync(displaySuggestions)
                    }
                }
            } catch (e: Exception) {
                // Silent fail for preview - don't spam logs
            }
        }.start()
    }
    // =================================================================================
    // END BLOCK: onSwipeProgress (Dual Live Preview)
    // =================================================================================


// =================================================================================
    // FUNCTION: updateSuggestions
    // SUMMARY: Updates the suggestion bar based on current composing word.
    //          
    // STYLING:
    //   - isNew=true (RED): Word not in any dictionary, can be added
    //   - isCustom=true (ITALIC): Word is in user dictionary  
    //   - Both false (WHITE BOLD): Word is in main dictionary
    // =================================================================================
    private fun updateSuggestions() {
        val prefix = currentComposingWord.toString()  // Lowercase for lookup
        val displayPrefix = originalCaseWord.toString()  // Original case for display
        
        if (prefix.isEmpty()) {
            updateSuggestionsWithSync(emptyList())
            return
        }

        // Strip apostrophe for dictionary lookup
        val lookupPrefix = prefix.replace("'", "")
        
        // Get dictionary suggestions
        val suggestions = if (lookupPrefix.isNotEmpty()) {
            predictionEngine.getSuggestions(lookupPrefix, 3)
        } else {
            emptyList()
        }
        
        val candidates = ArrayList<KeyboardView.Candidate>()

        // 1. Add Raw Input with ORIGINAL CASE as first option
        val rawExistsInMain = predictionEngine.hasWord(lookupPrefix) || predictionEngine.hasWord(prefix)
        val rawIsCustom = predictionEngine.isCustomWord(lookupPrefix) || predictionEngine.isCustomWord(prefix)
        val rawIsNew = !rawExistsInMain && !rawIsCustom
        
        candidates.add(KeyboardView.Candidate(
            text = displayPrefix, 
            isNew = rawIsNew,
            isCustom = rawIsCustom
        ))

// 2. Add dictionary suggestions (avoiding duplicates)
        // Apply display forms for proper capitalization (DroidOS, iPhone, etc.)
        for (s in suggestions) {
            val displayForm = predictionEngine.getDisplayForm(s)
            if (!displayForm.equals(lookupPrefix, ignoreCase = true) && 
                !displayForm.equals(prefix, ignoreCase = true) &&
                !displayForm.equals(displayPrefix, ignoreCase = true)) {
                // Check if this suggestion is a custom word
                val isCustom = predictionEngine.isCustomWord(s)
                candidates.add(KeyboardView.Candidate(
                    text = displayForm,  // Use display form with proper caps
                    isNew = false,
                    isCustom = isCustom
                ))
            }
        }

        updateSuggestionsWithSync(candidates.take(3))
        android.util.Log.d("DroidOS_Suggest", "Updated: ${candidates.map { "${it.text}(new=${it.isNew},custom=${it.isCustom})" }}")
    }
    // =================================================================================
    // END BLOCK: updateSuggestions with styling flags
    // =================================================================================

    // =================================================================================
    // FUNCTION: resetSwipeHistory
    // SUMMARY: Public access to reset swipe state. Called by OverlayService when
    //          external cursor movement (e.g. touching the app) is detected.
    // =================================================================================
    fun resetSwipeHistory() {
        if (lastCommittedSwipeWord != null) {
            android.util.Log.d("DroidOS_Swipe", "External cursor move detected -> Reset swipe history")
        }
        lastCommittedSwipeWord = null
        resetComposition()
    }

    private fun resetComposition() {
        currentComposingWord.clear()
        originalCaseWord.clear()
        updateSuggestionsWithSync(emptyList())
    }


    private fun injectKey(keyCode: Int, metaState: Int) {
        (context as? OverlayService)?.injectKeyFromKeyboard(keyCode, metaState)
    }

    // --- Voice Logic & Mic Check Loop ---
    
    // Handler for the 1-second loop
    private val micCheckHandler = Handler(Looper.getMainLooper())
    
    // Runnable that checks if the Microphone is currently recording
    private val micCheckRunnable = object : Runnable {
        override fun run() {
            try {
                val audioManager = context.getSystemService(android.content.Context.AUDIO_SERVICE) as AudioManager
                
                // Use activeRecordingConfigurations (API 24+) to check if any app is recording
                var isMicOn = false
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                    if (audioManager.activeRecordingConfigurations.isNotEmpty()) {
                        isMicOn = true
                    }
                }
                
                if (isMicOn) {
                    // Still recording, check again in 1 second
                    micCheckHandler.postDelayed(this, 1000)
                } else {
                    // Mic stopped (or not supported), turn off the green light
                    keyboardView?.setVoiceActive(false)
                }
            } catch (e: Exception) {
                // If check fails, fail safe to off
                keyboardView?.setVoiceActive(false)
            }
        }
    }

    private fun triggerVoiceTyping() {
        if (shellService == null) return

        // 1. UI: Turn Button Green Immediately
        keyboardView?.setVoiceActive(true)
        
        // 2. Start Monitoring Loop
        // Delay 3 seconds to allow the Voice IME to open and start recording
        micCheckHandler.removeCallbacks(micCheckRunnable)
        micCheckHandler.postDelayed(micCheckRunnable, 3000)

        // 3. Notify Service to stop blocking touches
        val intent = android.content.Intent("VOICE_TYPE_TRIGGERED")
        intent.setPackage(context.packageName)
        context.sendBroadcast(intent)

        // 4. Perform IME Switch via Shell
        Thread {
            try {
                // Fetch IME list and find Google Voice Typing
                val output = shellService?.runCommand("ime list -a -s") ?: ""
                val voiceIme = output.lines().find { it.contains("google", true) && it.contains("voice", true) } 
                    ?: output.lines().find { it.contains("voice", true) }
                
                if (voiceIme != null) {
                    shellService?.runCommand("ime set $voiceIme")
                } else {
                    android.util.Log.w(TAG, "Voice IME not found")
                    // If IME missing, turn off light
                    micCheckHandler.post { keyboardView?.setVoiceActive(false) }
                }
            } catch (e: Exception) {
                android.util.Log.e(TAG, "Voice Switch Failed", e)
                micCheckHandler.post { keyboardView?.setVoiceActive(false) }
            }
        }.start()
    }

            // [FIX] Helper to fix Z-Order relative to Trackpad
        fun bringToFront() {
            if (!isVisible || keyboardContainer == null) return
            try {
                // Remove and Re-add to move to the top of the WindowManager stack
                windowManager.removeView(keyboardContainer)
                windowManager.addView(keyboardContainer, keyboardParams)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

    // =================================================================================
    // FUNCTION: setNumberLayerOverride
    // SUMMARY: Automatically switches to Number/Symbol layer when Visual Queue is active.
    //          Saves previous state to restore later.
    // =================================================================================
    private var savedLayerState: KeyboardView.KeyboardState? = null

    fun setNumberLayerOverride(active: Boolean) {
        val kb = keyboardView ?: return
        if (active) {
            // Save current state if not already saved (prevents overwriting if called twice)
            if (savedLayerState == null) {
                savedLayerState = kb.getKeyboardState()
                android.util.Log.d(TAG, "Auto-Switch: Saved layer $savedLayerState, switching to SYMBOLS")
            }
            // SYMBOLS_1 contains the Number Row on main grid
            kb.setKeyboardState(KeyboardView.KeyboardState.SYMBOLS_1)
        } else {
            // Restore
            if (savedLayerState != null) {
                android.util.Log.d(TAG, "Auto-Switch: Restoring layer $savedLayerState")
                kb.setKeyboardState(savedLayerState!!)
                savedLayerState = null
            }
        }
    }

    // =================================================================================
    // FUNCTION: getKeyboardBounds
    // SUMMARY: Returns the screen bounds of the keyboard overlay for tap-outside detection.
    // =================================================================================
    fun getKeyboardBounds(): android.graphics.Rect? {
        val container = keyboardContainer ?: return null
        val params = keyboardParams ?: return null
        
        val location = IntArray(2)
        container.getLocationOnScreen(location)
        
        return android.graphics.Rect(
            location[0],
            location[1],
            location[0] + container.width,
            location[1] + container.height
        )
    }
    // =================================================================================
    // END BLOCK: getKeyboardBounds
    // =================================================================================
}
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/KeyboardView.kt
```kotlin
package com.example.coverscreentester

import android.content.Context
import android.graphics.Color
import android.graphics.drawable.GradientDrawable
import android.os.Build
import android.os.Handler
import android.os.Looper
import android.os.SystemClock
import android.os.VibrationEffect
import android.os.Vibrator
import android.util.AttributeSet
import android.util.SparseArray
import android.util.TypedValue
import android.view.Gravity
import android.view.HapticFeedbackConstants
import android.view.KeyEvent
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.widget.FrameLayout
import android.widget.LinearLayout
import android.widget.TextView
import kotlin.math.roundToInt
import android.annotation.SuppressLint
import android.util.Log

class KeyboardView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : LinearLayout(context, attrs, defStyleAttr) {

    companion object {
        private const val TAG = "KeyboardView"
    }


    // =================================================================================
    // DATA CLASS: Candidate
    // SUMMARY: Represents a word suggestion in the prediction bar.
    //   - text: The word to display
    //   - isNew: True if word is NOT in any dictionary (shown in RED, can be added)
    //   - isCustom: True if word is in USER dictionary (shown in ITALIC)
    //   - source: Which algorithm produced this (for color-coding)
    //             PRECISE = Green, SHAPE_CONTEXT = Blue, null = White
    // =================================================================================
    data class Candidate(
        val text: String, 
        val isNew: Boolean = false,
        val isCustom: Boolean = false,
        val source: PredictionSource? = null
    )
    // =================================================================================
    // END BLOCK: Candidate data class
    // =================================================================================

    // =================================================================================
    // INTERFACE: KeyboardListener
    // SUMMARY: Callbacks for keyboard events including key presses, swipe gestures,
    //          and the NEW live swipe preview for real-time predictions.
    // =================================================================================
    interface KeyboardListener {
        fun onKeyPress(keyCode: Int, char: Char?, metaState: Int)
        fun onTextInput(text: String)
        fun onSpecialKey(key: SpecialKey, metaState: Int)
        fun onScreenToggle()
        fun onScreenModeChange()
        fun onSuggestionClick(text: String, isNew: Boolean) // Updated
        fun onSwipeDetected(path: List<android.graphics.PointF>)
        fun onSuggestionDropped(text: String) // New: Drag to Delete
        fun onLayerChanged(state: KeyboardState) // Sync to mirror keyboard

        // NEW: Live swipe preview - called during swipe to show predictions in real-time
        // This enables GBoard-style "predict as you swipe" functionality
        fun onSwipeProgress(path: List<android.graphics.PointF>) {}  // Default empty impl for backwards compat
        
        // =======================================================================
        // NEW: Time-weighted swipe detection for dwell-based disambiguation
        // Called with TimedPoints so PredictionEngine can detect key lingering
        // =======================================================================
        fun onSwipeDetectedTimed(path: List<TimedPoint>) {}  // Default empty for backwards compat
        // =======================================================================
        // END BLOCK: Time-weighted swipe detection
        // =======================================================================
    }
    // =================================================================================
    // END BLOCK: KeyboardListener interface
    // =================================================================================

    enum class SpecialKey {
        BACKSPACE, ENTER, SPACE, SHIFT, CAPS_LOCK, SYMBOLS, ABC,
        TAB, ARROW_UP, ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT,
        HOME, END, DELETE, ESCAPE, CTRL, ALT,
        VOL_UP, VOL_DOWN, MUTE, BACK_NAV, FWD_NAV, VOICE_INPUT, HIDE_KEYBOARD
    }

    enum class KeyboardState {
        LOWERCASE, UPPERCASE, CAPS_LOCK, SYMBOLS_1, SYMBOLS_2
    }

    private var listener: KeyboardListener? = null
    private var currentState = KeyboardState.LOWERCASE
    private var vibrationEnabled = true

    private var isCtrlActive = false
    private var isAltActive = false

private var isMetaActive = false // For Windows/Command key


    private var isVoiceActive = false
    private var isInputCaptureActive = false

private var customModKeyCode = 0
    private var isCustomModLatchedLocal = false
    private var overrideSystemShortcuts = true

    // =================================================================================
    // LAUNCHER BLOCKED SHORTCUTS SET
    // SUMMARY: Contains shortcuts registered in the Launcher (format: "modifier|keyCode").
    //          Only block shortcuts that exist in this set when overrideSystemShortcuts is true.
    //          Empty set = block nothing (allow all shortcuts through to system)
    // =================================================================================
    private var launcherBlockedShortcuts: Set<String> = emptySet()
    // =================================================================================
    // END BLOCK: LAUNCHER BLOCKED SHORTCUTS SET
    // =================================================================================

    // [NEW] Mirror Mode & Visual Helpers
    private var isMirrorMode = false
    fun setMirrorMode(active: Boolean) { isMirrorMode = active }




    fun highlightKey(tag: String, active: Boolean, color: Int) {
        val view = findViewWithTag<View>(tag) ?: return
        
        // TARGET THE VISUAL ELEMENT: 
        // 1. Try the container background
        var bg = view.background
        
        // 2. If container has no background, try the child TextView/ImageView
        if (bg == null && view is ViewGroup && view.childCount > 0) {
            bg = view.getChildAt(0).background
        }

        if (bg != null) {
            if (active) {
                // FORCE RED using PorterDuff (Works on any Drawable type)
                bg.setColorFilter(color, android.graphics.PorterDuff.Mode.SRC_ATOP)
            } else {
                // RESET: Clear the filter to restore original look
                bg.clearColorFilter()
            }
            view.invalidate()
        }
    }



    // [NEW] Helper for Mirror Keyboard to refresh itself locally
    fun removeCandidateAtIndex(index: Int) {
        if (index < 0 || index >= currentCandidates.size) return
        currentCandidates.removeAt(index)
        // Add empty placeholder to keep alignment
        while (currentCandidates.size < 3) currentCandidates.add(Candidate("", false))
        setSuggestions(ArrayList(currentCandidates))
    }



    // =================================================================================
    // LIVE SWIPE PREVIEW THROTTLING

    // SUMMARY: Variables to control how often we send live swipe previews.
    //          Too frequent = laggy, too slow = not responsive.
    // =================================================================================
    private var lastSwipePreviewTime = 0L
    private val SWIPE_PREVIEW_INTERVAL_MS = 150L  // Update predictions every 150ms
    private val SWIPE_PREVIEW_MIN_POINTS = 5      // Need at least 5 points before previewing
    // =================================================================================
    // END BLOCK: LIVE SWIPE PREVIEW THROTTLING
    // =================================================================================

    // =================================================================================
    // VIRTUAL MIRROR ORIENTATION MODE STATE
    // SUMMARY: When true, key input is blocked and touches are forwarded for
    //          orientation trail rendering. Set by KeyboardOverlay during mirror mode.
    // =================================================================================
    private var isOrientationModeActive = false
    // =================================================================================
    // END BLOCK: VIRTUAL MIRROR ORIENTATION MODE STATE
    // =================================================================================

    private val BASE_KEY_HEIGHT = 40
    private val BASE_FONT_SIZE = 14f
    private var scaleFactor = 1.0f
    
    private var keyHeight = BASE_KEY_HEIGHT
    private var keySpacing = 2
    private var fontSize = BASE_FONT_SIZE

    // --- REPEAT LOGIC ---
    private val repeatHandler = Handler(Looper.getMainLooper())
    private var currentRepeatKey: String? = null
    private var isRepeating = false
    private val REPEAT_INITIAL_DELAY = 400L
    private val REPEAT_INTERVAL = 50L 

    // --- MULTITOUCH STATE ---
    private val activePointers = SparseArray<View>()
    
    // Caps Lock Logic
    private var capsLockPending = false
    private val capsHandler = Handler(Looper.getMainLooper())

    private val repeatRunnable = object : Runnable {
        override fun run() {
            currentRepeatKey?.let { key ->
                if (isRepeating) {
                    handleKeyPress(key, fromRepeat = true)
                    repeatHandler.postDelayed(this, REPEAT_INTERVAL)
                }
            }
        }
    }
    
    private val capsLockRunnable = Runnable {
        capsLockPending = true
        toggleCapsLock()
    }

    // UI Elements for Suggestions
    private var suggestionStrip: LinearLayout? = null
    // Track current suggestions for blocking logic
    private var currentCandidates: MutableList<Candidate> = ArrayList()
    private var cand1: TextView? = null
    private var cand2: TextView? = null
    private var cand3: TextView? = null
    private var div1: View? = null
    private var div2: View? = null
    private val handler = Handler(Looper.getMainLooper())

// =================================================================================
    // GESTURE TYPING STATE
    // SUMMARY: Variables for swipe/gesture typing detection. Swipe is only tracked for
    //          single-finger gestures. Multitouch cancels swipe detection to prevent
    //          false triggers during fast two-thumb typing.
    // =================================================================================
    private var swipeTrail: SwipeTrailView? = null
    private val keyCenters = HashMap<String, android.graphics.PointF>()
    private var isSwiping = false
    private val SWIPE_THRESHOLD = 35f // pixels of movement to trigger swipe mode (increased from 20)
    private val SWIPE_MIN_DISTANCE = 80f // minimum start-to-end distance for valid swipe
    private val SWIPE_MIN_PATH_POINTS = 10 // minimum path points for valid swipe (increased from 5)
    private var startTouchX = 0f
    private var startTouchY = 0f
    private var swipePointerId = -1 // Track which pointer started the swipe (-1 = none)

    // Store the full path for the decoder WITH TIMESTAMPS for dwell detection
    private val currentPath = ArrayList<TimedPoint>()
    // =================================================================================
    // END BLOCK: GESTURE TYPING STATE
    // =================================================================================


    // --- SPACEBAR TRACKPAD VARIABLES ---

    var isPredictiveBarEmpty: Boolean = true

    
    // Actions triggered by Spacebar Trackpad
    var cursorMoveAction: ((Float, Float, Boolean) -> Unit)? = null // dx, dy, isDragging
    var cursorClickAction: ((Boolean) -> Unit)? = null // isRight

    var touchDownAction: (() -> Unit)? = null
    var touchUpAction: (() -> Unit)? = null
    var touchTapAction: (() -> Unit)? = null


    // =================================================================================
    // VIRTUAL MIRROR MODE CALLBACK
    // SUMMARY: Callback to forward touch events to OverlayService for mirror keyboard.
    //          Called at the START of every touch event. If it returns true, the touch
    //          is in orientation mode and normal key input should be blocked.
    // @param x - Touch X coordinate
    // @param y - Touch Y coordinate  
    // @param action - MotionEvent action (DOWN, MOVE, UP, CANCEL)
    // @return true if orientation mode is active (block key input), false otherwise
    // =================================================================================
    var mirrorTouchCallback: ((Float, Float, Int) -> Boolean)? = null
    // =================================================================================
    // END BLOCK: VIRTUAL MIRROR MODE CALLBACK
    // =================================================================================

    private var spacebarPointerId = -1
    private var isSpaceTrackpadActive = false
    private var lastSpaceX = 0f
    private var lastSpaceY = 0f
    private val touchSlop = 15f
    private val cursorSensitivity = 2.5f
    private var currentActiveKey: View? = null

    // Touch Mode State
    private var isTrackpadTouchMode = false
    
    // =================================================================================
    // SPACEBAR MOUSE EXTENDED MODE STATE
    // SUMMARY: When true, spacebar mouse mode stays active indefinitely (no timer reset).
    //          Mode only deactivates when exitSpacebarMouseMode() is called externally
    //          (triggered by tapping the drag handle).
    // =================================================================================
    private var isSpacebarMouseExtendedMode = false
    
    // Callback to notify overlay when extended mode state changes (for drag handle color)
    var onExtendedModeChanged: ((Boolean) -> Unit)? = null
    
    // =================================================================================
    // ARROW KEYS SWIPE CALLBACK
    // SUMMARY: When in spacebar mouse mode, arrow keys trigger swipe instead of arrows.
    //          Parameters: dx (horizontal), dy (vertical) - values are -1, 0, or 1
    // =================================================================================
    var onArrowSwipe: ((Float, Float) -> Unit)? = null
    // =================================================================================
    // END BLOCK: SPACEBAR MOUSE EXTENDED MODE STATE
    // =================================================================================

    // =================================================================================
    // TRACKPAD RESET RUNNABLE
    // SUMMARY: Called after 1-second timeout in normal (non-extended) mode to deactivate
    //          spacebar mouse mode. Resets visual state and notifies overlay.
    // =================================================================================
    private val trackpadResetRunnable = Runnable { 
        isTrackpadTouchMode = false
        
        // Find Spacebar and turn off highlight
        val spaceView = findViewWithTag<View>("SPACE")
        if (spaceView != null) {
            setKeyVisual(spaceView, false, "SPACE")
            spaceView.invalidate() // Force redraw
        }
        this.invalidate() // Force keyboard redraw
        
        // Notify overlay (in case color was set)
        onExtendedModeChanged?.invoke(false)
        
        // Rebuild keyboard to reset arrow key colors
        buildKeyboard()
    }
    // =================================================================================
    // END BLOCK: TRACKPAD RESET RUNNABLE
    // =================================================================================


    // Hold / Drag Logic
    private var isDragging = false
    private var hasMovedWhileDown = false

    private val holdToDragRunnable = Runnable {
        if (isTrackpadTouchMode) {
            isDragging = true
            touchDownAction?.invoke() // Inject Down
            performHapticFeedback(HapticFeedbackConstants.LONG_PRESS)
            startTrackpadTimer()
            android.util.Log.d("SpaceTrackpad", "Hold detected -> Touch DOWN injected, drag mode activated")
        }
    }


    // =================================================================================
    // FUNCTION: setSpacebarExtendedMode
    // SUMMARY: Enables or disables spacebar mouse extended mode. When enabled, the normal
    //          1-second timer is bypassed and mode stays active until explicitly exited.
    //          Called from OverlayService when preference changes.
    // =================================================================================
    fun setSpacebarExtendedMode(enabled: Boolean) {
        isSpacebarMouseExtendedMode = enabled
        android.util.Log.d("SpaceTrackpad", "Extended Mode set to: $enabled")
        
        // If we just disabled extended mode and trackpad mode is active, start the normal timer
        if (!enabled && isTrackpadTouchMode) {
            handler.removeCallbacks(trackpadResetRunnable)
            handler.postDelayed(trackpadResetRunnable, 1000)
        }
    }
    // =================================================================================
    // END BLOCK: setSpacebarExtendedMode
    // =================================================================================

    // =================================================================================
    // FUNCTION: exitSpacebarMouseMode
    // SUMMARY: Forcibly exits spacebar mouse mode. Called when user taps the drag handle
    //          in extended mode. Resets all trackpad state and notifies overlay to
    //          reset drag handle color back to grey.
    // =================================================================================
    fun exitSpacebarMouseMode() {
        if (!isTrackpadTouchMode) return
        
        android.util.Log.d("SpaceTrackpad", "Exiting spacebar mouse mode (external request)")
        
        // Cancel any pending timers
        handler.removeCallbacks(trackpadResetRunnable)
        handler.removeCallbacks(holdToDragRunnable)
        
        // Reset state
        isTrackpadTouchMode = false
        isSpaceTrackpadActive = false
        isDragging = false
        spacebarPointerId = -1
        
        // Reset visual
        val spaceView = findViewWithTag<View>("SPACE")
        if (spaceView != null) {
            setKeyVisual(spaceView, false, "SPACE")
            spaceView.invalidate()
        }
        this.invalidate()
        
        // Notify overlay to turn drag handle back to grey
        onExtendedModeChanged?.invoke(false)
        
        // Rebuild keyboard to reset arrow key colors
        buildKeyboard()
    }
    // =================================================================================
    // END BLOCK: exitSpacebarMouseMode
    // =================================================================================

    // =================================================================================
    // FUNCTION: isInSpacebarMouseMode
    // SUMMARY: Returns true if spacebar mouse mode is currently active. Used by
    //          OverlayService to determine if tap-outside should exit mode.
    // =================================================================================
    fun isInSpacebarMouseMode(): Boolean {
        return isTrackpadTouchMode
    }
    // =================================================================================
    // END BLOCK: isInSpacebarMouseMode
    // =================================================================================
    // =================================================================================
    // FUNCTION: startTrackpadTimer
    // SUMMARY: Activates spacebar mouse mode with visual feedback. In normal mode, starts
    //          a 1-second timer that will deactivate mode. In EXTENDED mode, no timer is
    //          started - mode stays active until exitSpacebarMouseMode() is called.
    //          Also notifies overlay to update drag handle color when in extended mode.
    // =================================================================================
    private fun startTrackpadTimer() {
        isTrackpadTouchMode = true
        
        // FORCE VISUAL: Keep Spacebar Green while mode is active
        val spaceView = findViewWithTag<View>("SPACE")
        if (spaceView != null) {
            setKeyVisual(spaceView, true, "SPACE")
            spaceView.invalidate()
        }
        
        handler.removeCallbacks(trackpadResetRunnable)
        
        // =================================================================================
        // EXTENDED MODE CHECK
        // In extended mode, skip the timer - mode stays active until explicit exit
        // =================================================================================
        if (!isSpacebarMouseExtendedMode) {
            handler.postDelayed(trackpadResetRunnable, 1000)
        } else {
            android.util.Log.d("SpaceTrackpad", "Extended mode active - timer skipped")
            // Notify overlay to turn drag handle red
            onExtendedModeChanged?.invoke(true)
            // Rebuild keyboard to update arrow key colors to blue
            buildKeyboard()
        }
        // =================================================================================
        // END BLOCK: EXTENDED MODE CHECK
        // =================================================================================
    }
    // =================================================================================
    // END BLOCK: startTrackpadTimer
    // =================================================================================



    fun blockPredictionAtIndex(index: Int) {
        if (index < 0 || index >= currentCandidates.size) return

        val candidate = currentCandidates[index]
        val wordToBlock = candidate.text
        
        Log.d("KeyboardView", "Blocking prediction: $wordToBlock")

        // 1. Block in Engine (Prevent it from appearing again)
        // FIX: Use 'PredictionEngine.instance' instead of 'predictionEngine'
        PredictionEngine.instance.blockWord(context, wordToBlock) 

        // 2. Remove from UI immediately
        currentCandidates.removeAt(index)
        
        // 3. Refresh the Suggestion Bar with the updated list
        setSuggestions(ArrayList(currentCandidates))
    }




    private fun handleSpacebarClick(xRelativeToKey: Float, keyWidth: Int) {
        val zone = xRelativeToKey / keyWidth
        // 0: Left (0-33%), 2: Middle (33-66%), 1: Right (66-100%)
        val isRightClick = zone > 0.66f
        
        // Trigger click in OverlayService
        cursorClickAction?.invoke(isRightClick)
        
        performHapticFeedback(HapticFeedbackConstants.CONFIRM)
    }

    private fun moveMouse(dx: Float, dy: Float) {
        if (dx == 0f && dy == 0f) return

        // Active movement triggers Touch Mode
        startTrackpadTimer()

        // Send delta to OverlayService to move the fake cursor
        // Pass dragging state to service
        cursorMoveAction?.invoke(dx * cursorSensitivity, dy * cursorSensitivity, isDragging)
    }



    // We attach the trail view externally from the Overlay
    fun attachTrailView(view: SwipeTrailView) {
        this.swipeTrail = view
    }

    // Expose key centers for the overlay to retrieve
    fun getKeyCenters(): Map<String, android.graphics.PointF> {
        return keyCenters
    }

    private val lowercaseRows = listOf(
        listOf("q", "w", "e", "r", "t", "y", "u", "i", "o", "p"),
        listOf("a", "s", "d", "f", "g", "h", "j", "k", "l"),
        listOf("SHIFT", "z", "x", "c", "v", "b", "n", "m", "BKSP")
    )

    private val uppercaseRows = listOf(
        listOf("Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P"),
        listOf("A", "S", "D", "F", "G", "H", "J", "K", "L"),
        listOf("SHIFT", "Z", "X", "C", "V", "B", "N", "M", "BKSP")
    )

    private val symbols1Rows = listOf(
        listOf("1", "2", "3", "4", "5", "6", "7", "8", "9", "0"),
        listOf("@", "#", "\$", "%", "&", "-", "+", "(", ")"),
        listOf("SYM2", "*", "\"", "'", ":", ";", "!", "?", "BKSP")
    )

    private val symbols2Rows = listOf(
        listOf("~", "`", "|", "^", "=", "{", "}", "[", "]", "\\"),
        listOf("<", ">", "/", "_", "", "", "", "", ""),
        // Replaced MODE with root to keep layout balanced, MODE is now contextual on SCREEN key
        listOf("", "", "", "", "", "", "", "", "BKSP")
    )

    // Row 4 
    private val row4Lower = listOf("SYM", ",", "SPACE", ".")
    private val row4Sym = listOf("ABC", ",", "SPACE", ".")

    // Row 5 (Changed TAB to META)
    private val arrowRow = listOf("META", "CTRL", "ALT", "", "", "", "", "ESC")
    
    // Row 6 (Replaced SCREEN with TAB, Removed SCREEN)
    // Note: SCREEN logic is removed, but we keep the key for layout balance, now acting as TAB.
    private val navRow = listOf("TAB", "HIDE_KB", "MUTE", "VOL-", "VOL+", "BACK", "FWD", "MIC")

    // Keys allowed to repeat when held

    private val alwaysRepeatable = setOf(
        "BKSP", "", "DEL", "SPACE", "ENTER", 
        "", "", "", "", 
        "VOL_UP", "VOL_DOWN", "FWD_DEL", "MUTE",
        "HOME", "END", "PGUP", "PGDN"
    )


    init {
        orientation = VERTICAL
        setBackgroundColor(Color.parseColor("#1A1A1A"))
        setPadding(4, 4, 4, 4)
        buildKeyboard()
    }

    fun setKeyboardListener(l: KeyboardListener) { listener = l }
    fun setVibrationEnabled(enabled: Boolean) { vibrationEnabled = enabled }
    
    fun setScale(scale: Float) {
        this.scaleFactor = scale.coerceIn(0.5f, 2.0f)
        this.keyHeight = (BASE_KEY_HEIGHT * scaleFactor).toInt()
        this.fontSize = BASE_FONT_SIZE * scaleFactor
        buildKeyboard()
    }

    fun setVoiceActive(active: Boolean) {
        if (isVoiceActive != active) {
            isVoiceActive = active
            // Try to find and update just the MIC key to save resources
            val micView = findViewWithTag<View>("MIC")
            if (micView != null) {
                setKeyVisual(micView, false, "MIC")
            } else {
                invalidate() // Fallback: Redraw full view
            }
        }
    }

    fun setInputCaptureMode(active: Boolean) {
        isInputCaptureActive = active
        // Visual feedback? maybe dim the keyboard slightly or change border
        if (active) setBackgroundColor(Color.parseColor("#330000")) // Subtle Red tint
        else setBackgroundColor(Color.parseColor("#1A1A1A"))
    }

    fun setOverrideSystemShortcuts(enabled: Boolean) {
        overrideSystemShortcuts = enabled
    }

    // =================================================================================
    // FUNCTION: setLauncherBlockedShortcuts
    // SUMMARY: Updates the set of shortcuts that should be blocked when
    //          overrideSystemShortcuts is enabled. Only shortcuts in this set
    //          will be blocked; others pass through to the system.
    // @param shortcuts - Set of "modifier|keyCode" strings from Launcher
    // =================================================================================
    fun setLauncherBlockedShortcuts(shortcuts: Set<String>) {
        launcherBlockedShortcuts = shortcuts
        android.util.Log.d(TAG, "KeyboardView: Updated blocked shortcuts: ${shortcuts.size} entries")
    }
    // =================================================================================
    // END FUNCTION: setLauncherBlockedShortcuts
    // =================================================================================

    // =================================================================================
    // FUNCTION: setOrientationModeActive
    // SUMMARY: Sets whether orientation mode is active. When active, normal key input
    //          is blocked to allow the user to see the orientation trail and find
    //          their finger position on the physical keyboard.
    // @param active - true to block key input, false to resume normal operation
    // =================================================================================
    fun setOrientationModeActive(active: Boolean) {
        isOrientationModeActive = active

        // If exiting orientation mode, clear any pending key states
        if (!active) {
            currentActiveKey?.let {
                val tag = it.tag as? String
                if (tag != null) setKeyVisual(it, false, tag)
            }
            currentActiveKey = null
        }
    }
    // =================================================================================
    // END BLOCK: setOrientationModeActive
    // =================================================================================

    // =================================================================================
    // FUNCTION: startSwipeFromPosition
    // SUMMARY: Initializes swipe tracking from a given position mid-gesture.
    //          Called when switching from orange (orientation) to blue (typing) trail.
    //          Sets up all the swipe state so subsequent MOVE events are tracked.
    // =================================================================================
    fun startSwipeFromPosition(x: Float, y: Float) {
        Log.d("KeyboardView", "Starting swipe from position ($x, $y)")

        // Initialize swipe tracking as if this was the ACTION_DOWN point
        startTouchX = x
        startTouchY = y
        isSwiping = true  // Already swiping
        swipePointerId = 0  // Assume primary pointer

        // Clear and start the blue trail
        swipeTrail?.clear()
        swipeTrail?.visibility = View.VISIBLE
        swipeTrail?.addPoint(x, y)

        // Start the path collection with timestamp
        currentPath.clear()
        currentPath.add(TimedPoint(x, y, android.os.SystemClock.uptimeMillis()))

    }
    // =================================================================================
    // END BLOCK: startSwipeFromPosition
    // =================================================================================

    // =================================================================================
    // FUNCTION: handleDeferredTap
    // SUMMARY: Called when a quick tap happens during mirror orientation mode.
    //          Handles all keys including spacebar for single character input.
    //          Also handles taps on prediction bar candidates.
    // =================================================================================
    fun handleDeferredTap(x: Float, y: Float) {
        // First, check if tap is on a prediction candidate
        val tappedCandidate = findCandidateAt(x, y)
        if (tappedCandidate != null) {
            Log.d("KeyboardView", "Deferred tap on prediction: '${tappedCandidate.first}'")
            listener?.onSuggestionClick(tappedCandidate.first, tappedCandidate.second)
            return
        }

        // Otherwise, check for keyboard key
        val touchedView = findKeyView(x, y)
        val keyTag = touchedView?.tag as? String

        if (touchedView != null && keyTag != null) {
            Log.d("KeyboardView", "Deferred tap on key: $keyTag")

            if (keyTag == "SPACE") {
                // =================================================================================
                // DEFERRED SPACEBAR TAP - ROUTE THROUGH handleKeyPress
                // SUMMARY: Same fix as main spacebar handling - route through handleKeyPress
                //          so modifier shortcuts and logging work correctly.
                // =================================================================================
                handleKeyPress("SPACE")
                // =================================================================================
                // END BLOCK: DEFERRED SPACEBAR TAP
                // =================================================================================
            } else {
                // For other keys, trigger the full key press sequence
                onKeyDown(keyTag, touchedView)
                onKeyUp(keyTag, touchedView)
            }
        }
    }
    // =================================================================================
    // END BLOCK: handleDeferredTap
    // =================================================================================
// =================================================================================
    // FUNCTION: getKeyAtPosition
    // SUMMARY: Returns the key tag at the given coordinates, or null if no key found.
    //          Used by mirror mode to check if finger is on a repeatable key.
    // =================================================================================
    fun getKeyAtPosition(x: Float, y: Float): String? {
        val touchedView = findKeyView(x, y)
        return touchedView?.tag as? String
    }
    // =================================================================================
    // END BLOCK: getKeyAtPosition
    // =================================================================================

    // =================================================================================
    // FUNCTION: triggerKeyPress
    // SUMMARY: Triggers a key press by key tag without going through touch events.
    //          Used by mirror mode key repeat for backspace/arrow key repetition.
    //          Directly calls handleKeyPress to inject the key event.
    // =================================================================================
    fun triggerKeyPress(keyTag: String) {
        Log.d("KeyboardView", "triggerKeyPress: $keyTag")
        handleKeyPress(keyTag, fromRepeat = true)
    }
    // =================================================================================
    // END BLOCK: triggerKeyPress
    // =================================================================================    // =================================================================================
    // FUNCTION: findCandidateAt
    // SUMMARY: Checks if the given coordinates are within one of the prediction
    //          candidates (cand1, cand2, cand3). Returns the text and isNew flag
    //          if found, null otherwise.
    // =================================================================================
    private fun findCandidateAt(x: Float, y: Float): Pair<String, Boolean>? {
        val candidates = listOf(cand1, cand2, cand3)

        for (candView in candidates) {
            if (candView == null || candView.visibility != View.VISIBLE) continue

            // Get the view's position relative to this KeyboardView
            val loc = IntArray(2)
            candView.getLocationInWindow(loc)

            val myLoc = IntArray(2)
            this.getLocationInWindow(myLoc)

            // Calculate relative position
            val relX = loc[0] - myLoc[0]
            val relY = loc[1] - myLoc[1]

            // Check if tap is within this candidate
            if (x >= relX && x < relX + candView.width &&
                y >= relY && y < relY + candView.height) {

                val text = candView.text?.toString() ?: continue
                // Check if it's a "new" word by text color (cyan = new)
                val isNew = candView.currentTextColor == Color.CYAN

                return Pair(text, isNew)
            }
        }

        return null
    }
    // =================================================================================
    // END BLOCK: findCandidateAt
    // =================================================================================

    // =================================================================================
    // FUNCTION: getKeyboardState / setKeyboardState
    // SUMMARY: Gets/sets the current keyboard layer state for syncing to mirror.
    // =================================================================================
    fun getKeyboardState(): KeyboardState {
        return currentState
    }

    fun setKeyboardState(state: KeyboardState) {
        if (currentState != state) {
            currentState = state
            buildKeyboard()
        }
    }

    fun getShiftState(): Pair<Boolean, Boolean> {
        // Returns (isShifted, isCapsLock)
        return Pair(
            currentState == KeyboardState.UPPERCASE,
            currentState == KeyboardState.CAPS_LOCK
        )
    }

    fun getCtrlAltState(): Pair<Boolean, Boolean> {
        return Pair(isCtrlActive, isAltActive)
    }

    fun setCtrlAltState(ctrl: Boolean, alt: Boolean) {
        if (isCtrlActive != ctrl || isAltActive != alt) {
            isCtrlActive = ctrl
            isAltActive = alt
            buildKeyboard()
        }
    }
    // =================================================================================
    // END BLOCK: getKeyboardState / setKeyboardState
    // =================================================================================

    // =================================================================================
    // FUNCTION: isOrientationModeActive
    // SUMMARY: Returns whether orientation mode is currently active.
    // @return true if orientation mode is blocking key input
    // =================================================================================
    fun isOrientationModeActive(): Boolean {
        return isOrientationModeActive
    }
    // =================================================================================
    // END BLOCK: isOrientationModeActive
    // =================================================================================

    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {
        super.onLayout(changed, l, t, r, b)
        if (changed) {
            mapKeys()
        }
    }

    private fun mapKeys() {
        keyCenters.clear()

        // 1. Get the absolute position of the KeyboardView itself
        val parentLoc = IntArray(2)
        this.getLocationOnScreen(parentLoc)
        val parentX = parentLoc[0]
        val parentY = parentLoc[1]

        // 2. Traverse all children to find tagged TextViews
        fun traverse(view: View) {
            if (view is android.view.ViewGroup) {
                for (i in 0 until view.childCount) {
                    traverse(view.getChildAt(i))
                }
            }

            // Check if this view (could be ViewGroup or TextView) has a tag
            if (view.tag is String) {
                val key = view.tag as String
                // We only care about single letters for swipe decoding (A-Z)
                if (key.length == 1 && Character.isLetter(key[0])) {
                    val loc = IntArray(2)
                    view.getLocationOnScreen(loc)

                    // Calculate center relative to the KeyboardView (0,0 is top-left of keyboard)
                    // This matches the MotionEvent coordinates we get in dispatchTouchEvent
                    val centerX = (loc[0] - parentX) + (view.width / 2f)
                    val centerY = (loc[1] - parentY) + (view.height / 2f)

                    keyCenters[key.uppercase()] = android.graphics.PointF(centerX, centerY)
                    // Also store lowercase for easier matching
                    keyCenters[key.lowercase()] = android.graphics.PointF(centerX, centerY)
                }
            }
        }
        traverse(this)

        android.util.Log.d("DroidOS_Swipe", "Keys mapped: ${keyCenters.size / 2} (Unique Letters)")
        if (keyCenters.isNotEmpty()) {
             android.util.Log.d("DroidOS_Swipe", "Example 'H': ${keyCenters["h"]}")
        }
    }





private fun buildKeyboard() {
        // =======================================================================
        // SAVE CURRENT CANDIDATES before rebuilding
        // This preserves the prediction bar when SHIFT/layout changes occur
        // =======================================================================
        val savedCandidates = ArrayList(currentCandidates)
        // =======================================================================
        // END BLOCK: Save candidates
        // =======================================================================
        
        removeAllViews()

        // --- 1. SUGGESTION STRIP ---
        suggestionStrip = LinearLayout(context).apply {
            orientation = HORIZONTAL
            layoutParams = LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, (35 * scaleFactor).toInt()) 
            setBackgroundColor(Color.parseColor("#222222"))
            setPadding(0, 0, 0, 4)
            
            // Mouse Click Handler for Empty Bar
            setOnTouchListener { v, event ->
                if (isPredictiveBarEmpty) {
                    when (event.action) {
                        MotionEvent.ACTION_DOWN -> true // Capture touch
                        MotionEvent.ACTION_UP -> {
                            val w = v.width.toFloat()
                            val x = event.x
                            if (x < w * 0.33f) {
                                // Left Click Section (Left 33%)
                                cursorClickAction?.invoke(false) 
                                performHapticFeedback(HapticFeedbackConstants.CONFIRM)
                            } else if (x > w * 0.66f) {
                                // Right Click Section (Right 33%)
                                cursorClickAction?.invoke(true)
                                performHapticFeedback(HapticFeedbackConstants.CONFIRM)
                            } else {
                                // Middle Section
                            }
                            v.performClick()
                            true
                        }
                        else -> false
                    }
                } else {
                    false // Pass through to candidates
                }
            }
        }

        
        // Check initial state (hide children if empty by default)
        if (isPredictiveBarEmpty) {
            cand1?.visibility = View.GONE; cand2?.visibility = View.GONE; cand3?.visibility = View.GONE
            div1?.visibility = View.GONE; div2?.visibility = View.GONE
        }
        // --- END SUGGESTION STRIP ---


        fun createCandidateView(): TextView {
            return TextView(context).apply {
                layoutParams = LinearLayout.LayoutParams(0, LayoutParams.MATCH_PARENT, 1f)
                gravity = Gravity.CENTER
                setTextColor(Color.WHITE)
                textSize = fontSize * 0.9f
                typeface = android.graphics.Typeface.DEFAULT_BOLD
                setBackgroundResource(android.R.drawable.list_selector_background)
                maxLines = 1
                ellipsize = android.text.TextUtils.TruncateAt.END
            }
        }

        cand1 = createCandidateView(); suggestionStrip?.addView(cand1)
        // Divider
        val div1 = View(context).apply { layoutParams = LinearLayout.LayoutParams(1, LayoutParams.MATCH_PARENT); setBackgroundColor(Color.GRAY) }
        suggestionStrip?.addView(div1)

        cand2 = createCandidateView(); suggestionStrip?.addView(cand2)
        // Divider
        val div2 = View(context).apply { layoutParams = LinearLayout.LayoutParams(1, LayoutParams.MATCH_PARENT); setBackgroundColor(Color.GRAY) }
        suggestionStrip?.addView(div2)

        cand3 = createCandidateView(); suggestionStrip?.addView(cand3)

        addView(suggestionStrip)
        // --- END SUGGESTION STRIP ---
        
        val topRows = when (currentState) {
            KeyboardState.LOWERCASE -> lowercaseRows
            KeyboardState.UPPERCASE, KeyboardState.CAPS_LOCK -> uppercaseRows
            KeyboardState.SYMBOLS_1 -> symbols1Rows
            KeyboardState.SYMBOLS_2 -> symbols2Rows
        }
        for ((index, rowKeys) in topRows.withIndex()) {
            addView(createRow(rowKeys, index))
        }
        
        val bottomContainer = LinearLayout(context)
        bottomContainer.orientation = HORIZONTAL
        bottomContainer.layoutParams = LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT)
        
        val leftCol = LinearLayout(context)
        leftCol.orientation = VERTICAL
        val leftParams = LayoutParams(0, LayoutParams.WRAP_CONTENT, 8.5f)
        leftCol.layoutParams = leftParams
        
        val r4Keys = if (currentState == KeyboardState.LOWERCASE || currentState == KeyboardState.UPPERCASE || currentState == KeyboardState.CAPS_LOCK) row4Lower else row4Sym
        leftCol.addView(createRow(r4Keys, 3))
        leftCol.addView(createRow(arrowRow, 4))
        
        bottomContainer.addView(leftCol)
        
        val enterContainer = FrameLayout(context)
        val enterParams = LayoutParams(0, LayoutParams.MATCH_PARENT, 1.5f)
        enterParams.setMargins(dpToPx(keySpacing), dpToPx(keySpacing), 0, 0)
        enterContainer.layoutParams = enterParams
        
        val enterKey = createKey("ENTER", 1f)
        val kParams = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)
        enterKey.layoutParams = kParams
        
        enterContainer.addView(enterKey)
        bottomContainer.addView(enterContainer)

        addView(bottomContainer)

        addView(createRow(navRow, 5))

        // Notify listener of layer change for mirror sync
        listener?.onLayerChanged(currentState)
// =======================================================================
        // RESTORE SAVED CANDIDATES after rebuilding
        // This preserves the prediction bar when SHIFT/layout changes occur
        // =======================================================================
        if (savedCandidates.isNotEmpty()) {
            setSuggestions(savedCandidates)
        }
        // =======================================================================
        // END BLOCK: Restore candidates
        // =======================================================================
    }

    private fun createRow(keys: List<String>, rowIndex: Int): LinearLayout {
        val row = LinearLayout(context)
        row.orientation = HORIZONTAL
        row.gravity = Gravity.CENTER
        row.layoutParams = LayoutParams(LayoutParams.MATCH_PARENT, dpToPx(keyHeight)).apply {
            setMargins(0, dpToPx(keySpacing), 0, 0)
        }
        if (rowIndex == 1) row.setPadding(dpToPx((12 * scaleFactor).toInt()), 0, dpToPx((12 * scaleFactor).toInt()), 0)
        
        for (key in keys) { 
            val weight = getKeyWeight(key, rowIndex)
            row.addView(createKey(key, weight)) 
        }
        return row
    }

    private fun getKeyWeight(key: String, rowIndex: Int): Float {
        if (rowIndex >= 4) return 1f 
        return when (key) {
            "SPACE" -> 4.0f
            "SHIFT", "BKSP" -> 1.5f
            "SYM", "SYM1", "SYM2", "ABC" -> 1.3f
            else -> 1f
        }
    }

    private fun createKey(key: String, weight: Float): View {
        val container = FrameLayout(context)
        val params = if (weight > 0) {
            LayoutParams(0, LayoutParams.MATCH_PARENT, weight)
        } else {
            LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)
        }
        
        params.setMargins(dpToPx(keySpacing), 0, dpToPx(keySpacing), 0)
        container.layoutParams = params

        val keyView = TextView(context)
        keyView.gravity = Gravity.CENTER
        val rowFontSize = if (key in arrowRow || key in navRow) fontSize - 4 else fontSize
        keyView.setTextSize(TypedValue.COMPLEX_UNIT_SP, rowFontSize)
        keyView.setTextColor(Color.WHITE)
        keyView.text = getDisplayText(key)

        val bg = GradientDrawable()
        bg.cornerRadius = dpToPx(6).toFloat()
        bg.setColor(getKeyColor(key))
        keyView.background = bg
        
        val viewParams = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)
        container.addView(keyView, viewParams)

        container.tag = key
        return container
    }

    // --- MULTITOUCH HANDLING ---

// =================================================================================
    // FUNCTION: dispatchTouchEvent
    // SUMMARY: Intercepts touch events to detect swipe/gesture typing. Key safeguards:
    //          1. Only tracks swipe for single-finger gestures (pointer index 0)
    //          2. Multitouch (second finger down) cancels any active swipe detection
    //          3. Requires minimum movement threshold AND minimum path distance
    //          4. Validates swipe has enough points and traveled enough distance
    //          This prevents false swipe triggers during fast two-thumb typing.
    // =================================================================================

    // =================================================================================
    // FUNCTION: dispatchTouchEvent
    // SUMMARY: Intercepts touch events to detect swipe/gesture typing. Key safeguards:
    //          1. Skips swipe detection if touch starts on SPACE (trackpad mode)
    //          2. Skips swipe detection if a candidate is being dragged to delete
    //          3. Only tracks swipe for single-finger gestures
    //          4. Validates swipe has enough points and distance
    // =================================================================================
    override fun dispatchTouchEvent(event: android.view.MotionEvent): Boolean {
        // =================================================================================
        // VIRTUAL MIRROR MODE - BLOCK SWIPE TYPING
        // SUMMARY: When orientation mode is active, we must block swipe typing here
        //          because dispatchTouchEvent runs BEFORE onTouchEvent. If we don't
        //          block here, swipe paths get collected and committed even though
        //          onTouchEvent blocks individual key presses.
        // =================================================================================
        val callback = mirrorTouchCallback
        if (callback != null) {
            val shouldBlock = callback.invoke(event.x, event.y, event.actionMasked)
            if (shouldBlock) {
                // Orientation mode - block ALL input including swipe
                isOrientationModeActive = true

                // Cancel any in-progress swipe
                if (isSwiping) {
                    isSwiping = false
                    swipeTrail?.clear()
                    swipeTrail?.visibility = View.INVISIBLE
                }
                currentPath.clear()
                swipePointerId = -1

                // Still call super so child views can process, but return true to consume
                super.dispatchTouchEvent(event)
                return true
            }
        }

        // Also check the flag directly (for when callback isn't active)
        if (isOrientationModeActive) {
            // Cancel any in-progress swipe
            if (isSwiping) {
                isSwiping = false
                swipeTrail?.clear()
                swipeTrail?.visibility = View.INVISIBLE
            }
            currentPath.clear()
            swipePointerId = -1

            super.dispatchTouchEvent(event)
            return true
        }
        // =================================================================================
        // END BLOCK: VIRTUAL MIRROR MODE - BLOCK SWIPE TYPING
        // =================================================================================


        // [FIX] Block Swipe Logic when Trackpad Mode is active
        // This prevents the blue trail and swipe decoder from running while using the mouse
        if (isTrackpadTouchMode) {
            return super.dispatchTouchEvent(event)
        }

        // --- 1. PREVENT SWIPE TRAIL ON SPACEBAR ---

        // If the touch starts on the SPACE key, we skip the swipe detection logic entirely.
        if (event.actionMasked == android.view.MotionEvent.ACTION_DOWN) {
            val touchedView = findKeyView(event.x, event.y)
            if (touchedView?.tag == "SPACE") {
                return super.dispatchTouchEvent(event)
            }
        }

        // --- 2. CALL SUPER FIRST ---
        // This delivers touch events to child views (including suggestion candidates)
        // handleCandidateTouch will set activeDragCandidate/isCandidateDragging
        val superResult = super.dispatchTouchEvent(event)

        // --- 3. CHECK IF CANDIDATE IS BEING DRAGGED ---
        // If user is dragging a suggestion candidate, cancel any swipe tracking
        // and skip the swipe detection logic below
        if (activeDragCandidate != null) {
            // Cancel any active swipe tracking
            if (isSwiping) {
                isSwiping = false
                swipeTrail?.clear()
                swipeTrail?.visibility = View.INVISIBLE
            }
            currentPath.clear()
            swipePointerId = -1
            return superResult
        }

        // --- 4. SWIPE / GESTURE TRACKING LOGIC ---
        val action = event.actionMasked
        val pointerIndex = event.actionIndex
        val pointerId = event.getPointerId(pointerIndex)

        when (action) {
            android.view.MotionEvent.ACTION_DOWN -> {
                // First finger down - initialize potential swipe tracking
                isSwiping = false
                swipePointerId = pointerId
                startTouchX = event.x
                startTouchY = event.y
                swipeTrail?.clear()
                swipeTrail?.addPoint(event.x, event.y)
                currentPath.clear()
                // FIX: Use event.eventTime for consistent timestamps with ACTION_MOVE
                currentPath.add(TimedPoint(event.x, event.y, event.eventTime))

            }

            android.view.MotionEvent.ACTION_POINTER_DOWN -> {
                // Second finger touched - CANCEL swipe detection (user is typing with two thumbs)
                if (isSwiping) {
                    isSwiping = false
                    swipeTrail?.clear()
                    swipeTrail?.visibility = View.INVISIBLE
                    currentPath.clear()
                }
                swipePointerId = -1 // Disable swipe tracking for this gesture
            }

            android.view.MotionEvent.ACTION_MOVE -> {
                // Only track movement for the original swipe pointer
                if (swipePointerId == -1) return superResult

                // Find the index of our tracked pointer
                val trackedIndex = event.findPointerIndex(swipePointerId)
                if (trackedIndex == -1) return superResult

                val currentX = event.getX(trackedIndex)
                val currentY = event.getY(trackedIndex)

                if (!isSwiping) {
                    val dx = Math.abs(currentX - startTouchX)
                    val dy = Math.abs(currentY - startTouchY)
                    // Require movement in BOTH axes or significant movement in one
                    val totalMovement = Math.sqrt((dx * dx + dy * dy).toDouble()).toFloat()
                    if (totalMovement > SWIPE_THRESHOLD) {
                        isSwiping = true
                        currentRepeatKey = null
                        repeatHandler.removeCallbacks(repeatRunnable)
                        swipeTrail?.visibility = View.VISIBLE
                    }
                }

                if (isSwiping) {
                    swipeTrail?.addPoint(currentX, currentY)
                    // Sample historical points for smoother path WITH TIMESTAMPS
                    if (event.historySize > 0) {
                        for (h in 0 until event.historySize) {
                            val hx = event.getHistoricalX(trackedIndex, h)
                            val hy = event.getHistoricalY(trackedIndex, h)
                            val ht = event.getHistoricalEventTime(h)
                            currentPath.add(TimedPoint(hx, hy, ht))
                        }
                    }
                    currentPath.add(TimedPoint(currentX, currentY, event.eventTime))

                    // =======================================================================
                    // LIVE SWIPE PREVIEW
                    // SUMMARY: Send current path to listener for real-time predictions.
                    //          Throttled to avoid performance issues.
                    // =======================================================================
                    val now = System.currentTimeMillis()
                    if (currentPath.size >= SWIPE_PREVIEW_MIN_POINTS &&
                        now - lastSwipePreviewTime > SWIPE_PREVIEW_INTERVAL_MS) {
                        lastSwipePreviewTime = now
                        listener?.onSwipeProgress(currentPath.map { it.toPointF() })
                    }
                    // =======================================================================
                    // END BLOCK: LIVE SWIPE PREVIEW
                    // =======================================================================
                }
            }

            android.view.MotionEvent.ACTION_UP -> {
                if (isSwiping && pointerId == swipePointerId) {
                    swipeTrail?.clear()
                    swipeTrail?.visibility = View.INVISIBLE

                    // FIX: Clear any key highlight that may have been set during swipe
                    currentActiveKey?.let { key ->
                        val tag = key.tag as? String
                        if (tag != null) setKeyVisual(key, false, tag)
                    }
                    currentActiveKey = null

                    // Validate swipe before triggering decoder
                    val isValidSwipe = validateSwipe()

                    if (isValidSwipe) {
                        // LOG: Swipe passed validation, sending to decoder
                        android.util.Log.d("DroidOS_Swipe", "DISPATCH: Sending ${currentPath.size} points to onSwipeDetectedTimed")

                        // Check if listener exists
                        if (listener == null) {
                            android.util.Log.e("DroidOS_Swipe", "DISPATCH FAIL: listener is NULL!")
                        } else {
                            // NEW: Send timed path for dwell detection
                            listener?.onSwipeDetectedTimed(ArrayList(currentPath))
                        }
                    } else {
                        android.util.Log.d("DroidOS_Swipe", "DISPATCH SKIP: validateSwipe returned false")
                    }

                    isSwiping = false
                    swipePointerId = -1
                    currentPath.clear()
                    return true
                }
                // Clean up even if this wasn't our tracked pointer
                swipeTrail?.clear()
                swipePointerId = -1
            }

            android.view.MotionEvent.ACTION_POINTER_UP -> {
                // One finger lifted but another still down - just clean up if it was our pointer
                if (pointerId == swipePointerId) {
                    isSwiping = false
                    swipePointerId = -1
                    swipeTrail?.clear()
                    swipeTrail?.visibility = View.INVISIBLE
                    currentPath.clear()
                }
            }

            android.view.MotionEvent.ACTION_CANCEL -> {
                isSwiping = false
                swipePointerId = -1
                swipeTrail?.clear()
                swipeTrail?.visibility = View.INVISIBLE
                currentPath.clear()
            }
        }
        return superResult
    }
    // =================================================================================
    // END BLOCK: dispatchTouchEvent
    // =================================================================================


    // =================================================================================
    // FUNCTION: validateSwipe
    // SUMMARY: Checks if the recorded path qualifies as a valid swipe gesture.
    //          Requirements: minimum number of points AND minimum TOTAL PATH LENGTH.
    //          Uses total traveled distance (not start-to-end) to handle words that
    //          start and end on the same or nearby letters (e.g., "test", "that").
    //          LOGGING: Always logs validation result to diagnose failures.
    // =================================================================================
    private fun validateSwipe(): Boolean {
        // CHECK 1: Minimum path points
        if (currentPath.size < SWIPE_MIN_PATH_POINTS) {
            android.util.Log.d("DroidOS_Swipe", "VALIDATE FAIL: Path too short (${currentPath.size} < $SWIPE_MIN_PATH_POINTS points)")
            return false
        }

        // CHECK 2: Calculate TOTAL PATH LENGTH (not start-to-end distance)
        // This properly handles words like "test" where start and end keys are the same
        var totalPathLength = 0f
        for (i in 1 until currentPath.size) {
            val prev = currentPath[i - 1]
            val curr = currentPath[i]
            val dx = curr.x - prev.x
            val dy = curr.y - prev.y
            totalPathLength += Math.sqrt((dx * dx + dy * dy).toDouble()).toFloat()
        }

        if (totalPathLength < SWIPE_MIN_DISTANCE) {
            android.util.Log.d("DroidOS_Swipe", "VALIDATE FAIL: Path length too short (${totalPathLength.toInt()}px < ${SWIPE_MIN_DISTANCE.toInt()}px)")
            return false
        }

        android.util.Log.d("DroidOS_Swipe", "VALIDATE OK: ${currentPath.size} points, ${totalPathLength.toInt()}px total path length")
        return true
    }
    // =================================================================================
    // END BLOCK: validateSwipe with total path length check
    // =================================================================================





    @SuppressLint("ClickableViewAccessibility")
    override fun onTouchEvent(event: MotionEvent): Boolean {
        val action = event.actionMasked
        val pointerIndex = event.actionIndex
        val pointerId = event.getPointerId(pointerIndex)
        val x = event.getX(pointerIndex)
        val y = event.getY(pointerIndex)

        // =================================================================================
        // BLOCK: VIRTUAL MIRROR MODE - INTERCEPT TOUCHES (EXCEPT PREDICTIONS)
        // SUMMARY: All key touches go through orientation mode, but prediction bar
        //          touches should work immediately so users can tap suggestions.
        // =================================================================================

        // Check if touch is in the prediction bar area (top portion of keyboard)
        val isPredictionBarTouch = suggestionStrip != null && y < (suggestionStrip?.bottom ?: 0)

        val touchedView = findKeyView(x, y)
        val keyTag = touchedView?.tag as? String

        val callback = mirrorTouchCallback
        if (callback != null && !isPredictionBarTouch) {
            val shouldBlock = callback.invoke(x, y, action)
            if (shouldBlock) {
                // Orientation mode is active - set flag and block ALL input
                isOrientationModeActive = true

                // Clear any active key highlight
                currentActiveKey?.let { key ->
                    val tag = key.tag as? String
                    if (tag != null) setKeyVisual(key, false, tag)
                }
                currentActiveKey = null

                // CRITICAL: Return immediately - do not process as key input
                return true
            }
        }
        // =================================================================================
        // END BLOCK: VIRTUAL MIRROR MODE - INTERCEPT TOUCHES
        // =================================================================================

        // =================================================================================
        // ORIENTATION MODE CHECK (fallback, but skip for prediction bar)
        // =================================================================================
        if (isOrientationModeActive && !isPredictionBarTouch) {
            currentActiveKey?.let {
                val tag = it.tag as? String
                if (tag != null) setKeyVisual(it, false, tag)
            }
            currentActiveKey = null
            return true
        }
        // =================================================================================
        // END BLOCK: ORIENTATION MODE CHECK
        // =================================================================================




// --- SPACEBAR TRACKPAD HANDLING ---
        // [MODIFIED] Check for Spacebar OR Active Trackpad Mode (Full Keyboard)
        // If mode is active (Green), ALL keyboard touches become mouse inputs.
        // =================================================================================
        // ARROW KEYS EXCEPTION: When in spacebar mouse mode, arrow keys should NOT be
        // intercepted for cursor movement - they perform swipe actions instead.
        // =================================================================================
        val arrowKeys = listOf("", "", "", "")
        val isArrowKey = keyTag in arrowKeys
        val isTrackpadStart = (keyTag == "SPACE" && action == MotionEvent.ACTION_DOWN)
        val isTrackpadContinue = (isTrackpadTouchMode && action == MotionEvent.ACTION_DOWN && !isArrowKey)

        if (isTrackpadStart || isTrackpadContinue || spacebarPointerId == pointerId) {
            when (action) {
                MotionEvent.ACTION_DOWN, MotionEvent.ACTION_POINTER_DOWN -> {
                    if (isTrackpadStart || isTrackpadContinue) {
                        spacebarPointerId = pointerId
                        lastSpaceX = x
                        lastSpaceY = y

                        isSpaceTrackpadActive = false
                        isDragging = false
                        hasMovedWhileDown = false

                        // If in Touch Mode, start the "Hold to Drag" timer
                        // This allows hold-to-drag behavior from ANY key when active
                        if (isTrackpadTouchMode) {
                            // [FIX] Increased to 700ms to prevent accidental drags while typing fast
                            handler.postDelayed(holdToDragRunnable, 700) 
                            android.util.Log.d("SpaceTrackpad", "Touch Mode: Started hold-to-drag timer (700ms)")
                        }

                        // Visual feedback: Always keep SPACE green, even if touching other keys
                        val spaceView = findViewWithTag<View>("SPACE")
                        if (spaceView != null) setKeyVisual(spaceView, true, "SPACE")
                        
                        // Return true to BLOCK normal key processing
                        return true
                    }
                }
                MotionEvent.ACTION_MOVE -> {
                    if (pointerId == spacebarPointerId) {
                        val dx = x - lastSpaceX
                        val dy = y - lastSpaceY

                        // Check if user moved significantly
                        // [FIX] Increased threshold to 80f (approx 5x touchSlop) to prevent
                        // accidental trackpad activation when hitting spacebar quickly.
                        if (kotlin.math.hypot(dx, dy) > 80f) {
                            hasMovedWhileDown = true

                            // If we moved BEFORE the hold timer fired, cancel the hold
                            // (Unless we are already dragging, in which case we continue dragging)
                            if (!isDragging) {
                                handler.removeCallbacks(holdToDragRunnable)
                            }

                            isSpaceTrackpadActive = true
                        }

                        // Move Cursor
                        if (isSpaceTrackpadActive) {
                            moveMouse(dx, dy)
                            lastSpaceX = x
                            lastSpaceY = y
                        }
                        return true
                    }
                }

                MotionEvent.ACTION_UP, MotionEvent.ACTION_POINTER_UP -> {
                    if (pointerId == spacebarPointerId) {
                        handler.removeCallbacks(holdToDragRunnable)

                        // VISUAL LOGIC:
                        // Only reset to Grey if we are NOT staying in Touch Mode.
                        // If we are in Touch Mode, startTrackpadTimer() will ensure it stays Green.
                        val stayingInMode = isTrackpadTouchMode || isSpaceTrackpadActive
                        
                        val spaceView = findViewWithTag<View>("SPACE")
                        if (spaceView != null && !stayingInMode) {
                            setKeyVisual(spaceView, false, "SPACE")
                        }

                        if (isTrackpadTouchMode) {
                            if (isDragging) {
                                touchUpAction?.invoke()
                                isDragging = false
                            } else if (!hasMovedWhileDown) {
                                touchTapAction?.invoke()
                            }
                            // Reset timer on lift (keeps mode alive for 1s after touch ends)
                            startTrackpadTimer()
                        } else {
                            if (!isSpaceTrackpadActive) {
                                // =================================================================================
                                // SPACEBAR TAP - ROUTE THROUGH handleKeyPress
                                // SUMMARY: Previously called listener?.onSpecialKey() directly, which bypassed
                                //          handleKeyPress() and all its modifier/shortcut logic. Now we route
                                //          through handleKeyPress("SPACE") so that:
                                //          1. Spacebar is logged in debug output
                                //          2. Alt+Space, Ctrl+Space can work as shortcuts
                                //          3. Spacebar broadcasts to Launcher when modifiers are active
                                // =================================================================================
                                handleKeyPress("SPACE")
                                performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)
                                // =================================================================================
                                // END BLOCK: SPACEBAR TAP - ROUTE THROUGH handleKeyPress
                                // =================================================================================
                            } else {
                                // Drag Finished -> Enter Touch Mode (Stays Green)
                                startTrackpadTimer()
                            }
                        }
                        
                        spacebarPointerId = -1
                        isSpaceTrackpadActive = false
                        return true
                    }
                }


                MotionEvent.ACTION_CANCEL -> {
                    if (pointerId == spacebarPointerId) {
                        handler.removeCallbacks(holdToDragRunnable)
                        if (isDragging) { touchUpAction?.invoke(); isDragging = false }
                        spacebarPointerId = -1
                        isSpaceTrackpadActive = false
                        
                        // Only turn off visual if timer isn't running
                        if (!isTrackpadTouchMode) {
                            val spaceView = findViewWithTag<View>("SPACE")
                            if (spaceView != null) setKeyVisual(spaceView, false, "SPACE")
                        }
                        return true
                    }
                }

            }
        }




        // --- STANDARD KEYBOARD HANDLING (Fixes Stuck Highlights) ---
        // We track the active key and update it as the finger slides.
        
        when (action) {
            MotionEvent.ACTION_DOWN, MotionEvent.ACTION_POINTER_DOWN -> {
                if (touchedView != null && keyTag != null && keyTag != "SPACE") {
                    currentActiveKey = touchedView
                    onKeyDown(keyTag, touchedView)
                }
            }
            MotionEvent.ACTION_MOVE -> {
                // If we slid to a new key
                if (touchedView != currentActiveKey) {
                    // Deactivate old key
                    currentActiveKey?.let {
                        val oldTag = it.tag as? String
                        if (oldTag != null) {
                            setKeyVisual(it, false, oldTag)
                            // CRITICAL: Stop any repeat when sliding off a key
                            if (oldTag == currentRepeatKey) {
                                stopRepeat()
                            }
                        }
                    }

                    // Activate new
                    if (touchedView != null && keyTag != null && keyTag != "SPACE") {
                        currentActiveKey = touchedView
                        onKeyDown(keyTag, touchedView) // Visual on + Haptic
                    } else {
                        currentActiveKey = null
                    }
                }
            }
            MotionEvent.ACTION_POINTER_UP -> {
                // Multitouch Lift: Try to find the key under this specific pointer
                val idx = event.actionIndex
                val xUp = event.getX(idx)
                val yUp = event.getY(idx)
                
                // 1. Reset specific key under finger (Fixes Multitouch Ghosting)
                val viewUnderFinger = findKeyView(xUp, yUp)
                if (viewUnderFinger != null) {
                    val tag = viewUnderFinger.tag as? String
                    if (tag != null) {
                        // If this was the active key, trigger Up logic
                        if (viewUnderFinger == currentActiveKey) {
                            onKeyUp(tag, viewUnderFinger)
                        } else {
                            // Just visual reset if it wasn't the "primary" active key
                            setKeyVisual(viewUnderFinger, false, tag)
                        }
                    }
                }

                // 2. Fallback: Reset currentActiveKey if it matches
                if (currentActiveKey != null && currentActiveKey == viewUnderFinger) {
                    currentActiveKey = null
                }
            }
            
            MotionEvent.ACTION_UP -> {
                // Final Lift: Clean EVERYTHING
                currentActiveKey?.let {
                    val tag = it.tag as? String
                    if (tag != null) {
                        onKeyUp(tag, it)
                        setKeyVisual(it, false, tag)
                    }
                }
                currentActiveKey = null
                
                // [SAFETY] Force scan all children to ensure no other keys are stuck green
                resetAllKeysVisual()
            }
            
            MotionEvent.ACTION_CANCEL -> {
                currentActiveKey?.let {
                    val tag = it.tag as? String
                    if (tag != null) setKeyVisual(it, false, tag)
                }
                currentActiveKey = null
                
                // [SAFETY] Force scan all children
                resetAllKeysVisual()
            }
        }
        
        return true
    }






    // =================================================================================
    // FUNCTION: findKeyView
    // SUMMARY: Finds the key at the given coordinates. First tries exact hit detection,
    //          then falls back to nearest-key detection to eliminate input gaps.
    //          This ensures taps between keys still register on the closest key.
    // =================================================================================
    private fun findKeyView(targetX: Float, targetY: Float): View? {
        // First, try exact hit detection (touch is within key bounds)
        val exactMatch = findKeyRecursively(this, targetX, targetY)
        if (exactMatch != null) return exactMatch
        
        // No exact match - find the nearest key within threshold
        // This eliminates "dead zones" between keys
        return findNearestKey(targetX, targetY)
    }
    // =================================================================================
    // END BLOCK: findKeyView
    // =================================================================================

    // =================================================================================
    // FUNCTION: findKeyRecursively
    // SUMMARY: Recursively searches for a key view at the exact coordinates.
    //          Returns null if touch is in a gap between keys.
    // =================================================================================
    private fun findKeyRecursively(parent: ViewGroup, targetX: Float, targetY: Float): View? {
        for (i in 0 until parent.childCount) {
            val child = parent.getChildAt(i)
            if (child.visibility != View.VISIBLE) continue
            val cx = child.x
            val cy = child.y
            if (targetX >= cx && targetX < cx + child.width && targetY >= cy && targetY < cy + child.height) {
                if (child.tag != null) return child
                if (child is ViewGroup) return findKeyRecursively(child, targetX - cx, targetY - cy)
            }
        }
        return null
    }
    // =================================================================================
    // END BLOCK: findKeyRecursively
    // =================================================================================

    // =================================================================================
    // FUNCTION: findNearestKey
    // SUMMARY: Finds the closest key to the touch point when the touch falls in a gap.
    //          Uses center-to-point distance calculation. Returns null if no key is
    //          within the maximum threshold (prevents edge-of-keyboard false triggers).
    //
    //          MAX_GAP_THRESHOLD: Maximum distance from key center to consider.
    //          Set to ~20dp to cover typical key gaps without triggering from far away.
    // =================================================================================
    private fun findNearestKey(targetX: Float, targetY: Float): View? {
        // Maximum distance threshold in pixels (~20dp covers gaps but not wild misses)
        val maxThresholdPx = dpToPx(20).toFloat()
        
        var nearestKey: View? = null
        var nearestDistance = Float.MAX_VALUE
        
        // Collect all key views and their bounds
        collectKeysWithDistance(this, targetX, targetY, 0f, 0f) { keyView, distance ->
            if (distance < nearestDistance && distance < maxThresholdPx) {
                nearestDistance = distance
                nearestKey = keyView
            }
        }
        
        return nearestKey
    }
    // =================================================================================
    // END BLOCK: findNearestKey
    // =================================================================================

    // =================================================================================
    // FUNCTION: collectKeysWithDistance
    // SUMMARY: Recursively traverses the view hierarchy, calculating the distance
    //          from the touch point to the center of each key view.
    //          Calls the provided callback for each key found with its distance.
    //
    // PARAMETERS:
    //   - parent: The ViewGroup to search within
    //   - targetX, targetY: Touch coordinates (relative to this KeyboardView)
    //   - offsetX, offsetY: Accumulated offset from parent containers
    //   - onKeyFound: Callback invoked for each key with (view, distance)
    // =================================================================================
    private fun collectKeysWithDistance(
        parent: ViewGroup, 
        targetX: Float, 
        targetY: Float,
        offsetX: Float,
        offsetY: Float,
        onKeyFound: (View, Float) -> Unit
    ) {
        for (i in 0 until parent.childCount) {
            val child = parent.getChildAt(i)
            if (child.visibility != View.VISIBLE) continue
            
            // Calculate child's absolute position within KeyboardView
            val childAbsX = offsetX + child.x
            val childAbsY = offsetY + child.y
            
            if (child.tag != null) {
                // This is a key - calculate distance from touch to key center
                val keyCenterX = childAbsX + child.width / 2f
                val keyCenterY = childAbsY + child.height / 2f
                
                val dx = targetX - keyCenterX
                val dy = targetY - keyCenterY
                val distance = Math.sqrt((dx * dx + dy * dy).toDouble()).toFloat()
                
                onKeyFound(child, distance)
            } else if (child is ViewGroup) {
                // Recurse into child container (rows, etc.)
                collectKeysWithDistance(child, targetX, targetY, childAbsX, childAbsY, onKeyFound)
            }
        }
    }
    // =================================================================================
    // END BLOCK: collectKeysWithDistance
    // This approach ensures:
    // 1. Exact touches still work as before (fast path)
    // 2. Gap touches find the nearest key (eliminates dead zones)
    // 3. Edge-of-keyboard touches don't trigger random keys (threshold limit)
    // 4. Works for both tap and swipe input methods
    // =================================================================================


// =================================================================================
    // FUNCTION: onKeyDown
    // SUMMARY: Handles initial touch on a key. For swipe-compatible keys (single letters),
    //          we ONLY provide visual/haptic feedback here. The actual character input is
    //          deferred to onKeyUp to prevent double-letters during swipe typing.
    //          Special/modifier keys still trigger immediately for responsiveness.
    // =================================================================================

    // =================================================================================
    // KEY HANDLING LOGIC (DEFERRED TOGGLES)
    // =================================================================================
    // Keys that trigger layout changes (?123, ABC) or state toggles (CTRL, ALT)
    // must fire on UP to prevent "Flickering" caused by immediate layout rebuilds
    // while the finger is still pressing the screen.
    private val deferredKeys = setOf("SHIFT", "?123", "ABC", "SYM", "SYM1", "SYM2", "CTRL", "ALT", "META", "MODE", "SCREEN", "TAB")

    // =================================================================================
    // FUNCTION: onKeyDown
    // SUMMARY: Handles initial touch on a key. For swipe-compatible keys (single letters),
    //          we ONLY provide visual/haptic feedback here. The actual character input is
    //          deferred to onKeyUp to prevent double-letters during swipe typing.
    //          Special/modifier keys still trigger immediately for responsiveness.
    //          FIX: ALL key presses are blocked during active swipe to match Gboard behavior.
    // =================================================================================
    private fun onKeyDown(key: String, view: View) {
        // FIX: Block ALL key presses during active swipe
        // This prevents SHIFT, ENTER, BACKSPACE etc from triggering mid-swipe
        if (isSwiping) {
            // Still provide visual feedback so user sees they touched something
            setKeyVisual(view, true, key)
            return
        }

        setKeyVisual(view, true, key)

        // Haptic Feedback
        if (vibrationEnabled) {
            val v = context.getSystemService(Context.VIBRATOR_SERVICE) as? Vibrator
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                v?.vibrate(VibrationEffect.createOneShot(30, VibrationEffect.DEFAULT_AMPLITUDE))
            } else {
                @Suppress("DEPRECATION") v?.vibrate(30)
            }
        }

        val isSwipeableKey = key.length == 1 && Character.isLetter(key[0])
        val isDeferred = deferredKeys.contains(key)

        // FIRE IMMEDIATE: Navigation, Numbers, Punctuation, Backspace
        // But only if NOT a swipeable key and NOT a deferred key
        if (!isSwipeableKey && !isDeferred) {
            handleKeyPress(key, fromRepeat = false)

            if (isKeyRepeatable(key)) {
                currentRepeatKey = key
                isRepeating = true
                repeatHandler.postDelayed(repeatRunnable, REPEAT_INITIAL_DELAY)
            }
        }

        // SPECIAL: SHIFT Caps Lock Timer
        if (key == "SHIFT") {
            capsLockPending = false
            capsHandler.postDelayed(capsLockRunnable, 500)
        }
    }
    // =================================================================================
    // END BLOCK: onKeyDown
    // =================================================================================


    // =================================================================================
    // END BLOCK: KEY HANDLING LOGIC
    // =================================================================================

    // =================================================================================
    // END BLOCK: onKeyDown
    // =================================================================================

// =================================================================================
    // FUNCTION: onKeyUp
    // SUMMARY: Handles key release. For swipe-compatible keys (single letters), this is
    //          where we actually commit the character - BUT ONLY if we're not currently
    //          in a swipe gesture. This prevents double letters with swipe typing.
    //          FIX: ALL key presses are blocked during active swipe to match Gboard behavior.
    //          Also handles SHIFT toggle and repeat cancellation.
    // =================================================================================

    private fun onKeyUp(key: String, view: View) {
        setKeyVisual(view, false, key)

        // Stop any active key repeat
        if (key == currentRepeatKey) stopRepeat()

        // FIX: Block ALL key presses during active swipe
        // This includes letter keys, special keys, and deferred keys
        if (isSwiping) {
            // Cancel SHIFT caps lock timer if it was started
            if (key == "SHIFT") {
                capsHandler.removeCallbacks(capsLockRunnable)
                capsLockPending = false
            }
            return
        }

        // Determine if this is a swipeable key that was deferred
        val isSwipeableKey = key.length == 1 && Character.isLetter(key[0])

        if (isSwipeableKey) {
            // SWIPEABLE KEY + NOT SWIPING = Normal tap, commit the character now
            handleKeyPress(key, fromRepeat = false)
        }

        // --- Handle Deferred Keys (CTRL, ALT, SYM, etc) ---
        // These are skipped in onKeyDown to prevent rebuild loops.
        // We must fire them here on release.
        val isDeferred = deferredKeys.contains(key)
        if (isDeferred && key != "SHIFT") {
             handleKeyPress(key, fromRepeat = false)
        }

        // SHIFT toggle handling
        if (key == "SHIFT") {
            capsHandler.removeCallbacks(capsLockRunnable)
            if (!capsLockPending) toggleShift()
            capsLockPending = false
        }
    }

    // =================================================================================
    // END BLOCK: onKeyUp
    // =================================================================================


    // Changed to public to allow external highlighting (e.g. from OverlayService during drag)
    fun setKeyVisual(container: View, pressed: Boolean, key: String, overrideColor: Int? = null) {
        val tv = (container as? ViewGroup)?.getChildAt(0) as? TextView ?: return
        val bg = tv.background as? GradientDrawable ?: return

        if (overrideColor != null) {
            bg.setColor(overrideColor)
        } else if (pressed) {
            bg.setColor(Color.parseColor("#3DDC84"))
        } else {
            bg.setColor(getKeyColor(key))
        }
    }

    // New helper to highlight a specific key by tag
    fun highlightKey(tag: String, active: Boolean, color: Int? = null) {
        val view = findViewWithTag<View>(tag)
        if (view != null) {
            setKeyVisual(view, active, tag, color)
        }
    }

    // [FIX] Safety method to iterate all keys and turn off highlights
    // Used on ACTION_UP and CANCEL to prevent "Sticky Green Keys"
    private fun resetAllKeysVisual() {
        fun traverse(view: View) {
            if (view is ViewGroup) {
                for (i in 0 until view.childCount) {
                    traverse(view.getChildAt(i))
                }
            }
            // If it's a key (has tag), reset it
            val tag = view.tag as? String
            if (tag != null) {
                setKeyVisual(view, false, tag)
            }
        }
        traverse(this)
    }


    private fun stopRepeat() {
        isRepeating = false
        currentRepeatKey = null
        repeatHandler.removeCallbacks(repeatRunnable)
    }

    private fun isKeyRepeatable(key: String): Boolean {
        // 1. Strict Whitelist Check (Nav & Deletion)
        if (alwaysRepeatable.contains(key)) return true
        
        // 2. Single letters/numbers (Standard typing) should repeat
        if (key.length == 1) return true
        
        // 3. Explicitly BLOCK everything else (SHIFT, ?123, CTRL, ALT, TAB, ESC)
        // This ensures they only trigger ONCE per press (Sticky/Toggle behavior)
        return false
    }

    private fun getDisplayText(key: String): String = when (key) {
        "SHIFT" -> if (currentState == KeyboardState.CAPS_LOCK) "" else ""
        "BKSP" -> ""; "ENTER" -> ""; "SPACE" -> " "
        "SYM", "SYM1", "SYM2" -> "?123"; "ABC" -> "ABC"
        "TAB" -> ""; "CTRL" -> "Ctrl"; "ALT" -> "Alt"; "META" -> ""; "ESC" -> "Esc"
        "" -> ""; "" -> ""; "" -> ""; "" -> ""
        "MUTE" -> "Mute"; "VOL-" -> "Vol-"; "VOL+" -> "Vol+"
        "BACK" -> "Back"; "FWD" -> "Fwd"; "MIC" -> ""
        "SCREEN" -> if (isSymbolsActive()) "MODE" else ""
        "HIDE_KB" -> ""
        else -> key
    }

    private fun getKeyColor(key: String): Int {
        if (key == "CTRL" && isCtrlActive) return Color.parseColor("#3DDC84")
        if (key == "ALT" && isAltActive) return Color.parseColor("#3DDC84")

if (key == "META" && isMetaActive) return Color.parseColor("#3DDC84")
        
        // NEW: Voice Active Indicator
        // UPDATED: Voice Key Color
        // Green if active, standard dark gray if inactive (removed red alert color)
        if (key == "MIC") {
            return if (isVoiceActive) Color.parseColor("#3DDC84") else Color.parseColor("#252525")
        }

        if (key == "SCREEN") {
            return if (isSymbolsActive()) Color.parseColor("#FF9800") else Color.parseColor("#FF5555")
        }
        
        // =================================================================================
        // ARROW KEYS COLOR - BLUE WHEN IN SPACEBAR MOUSE MODE
        // =================================================================================
        if (key in arrowRow) {
            if (key in listOf("", "", "", "") && isTrackpadTouchMode) {
                return Color.parseColor("#4488FF") // Blue for swipe mode
            }
            return Color.parseColor("#252525")
        }
        if (key in navRow) return Color.parseColor("#252525")
        // =================================================================================
        // END BLOCK: ARROW KEYS COLOR
        // =================================================================================
        
        return when (key) {
            "SHIFT" -> when (currentState) {
                KeyboardState.CAPS_LOCK -> Color.parseColor("#3DDC84")
                KeyboardState.UPPERCASE -> Color.parseColor("#4A90D9")
                else -> Color.parseColor("#3A3A3A")
            }
            "ENTER" -> Color.parseColor("#4A90D9")
            "BKSP", "SYM", "SYM1", "SYM2", "ABC" -> Color.parseColor("#3A3A3A")
            "SPACE" -> Color.parseColor("#2D2D2D")
            else -> Color.parseColor("#2D2D2D")
        }
    }
    
    private fun isSymbolsActive(): Boolean {
        return currentState == KeyboardState.SYMBOLS_1 || currentState == KeyboardState.SYMBOLS_2
    }

    private fun getMetaState(): Int {
        var meta = 0
        if (isCtrlActive) meta = meta or 0x1000 
        if (isAltActive) meta = meta or 0x02 

if (isMetaActive) meta = meta or 0x10000 // META_META_ON 
        return meta
    }


    fun setCustomModKey(keyCode: Int) {
        android.util.Log.d("DroidOS_Debug", "setCustomModKey: Old=$customModKeyCode New=$keyCode")
        customModKeyCode = keyCode
    }

        private fun handleKeyPress(key: String, fromRepeat: Boolean = false) {
            if (isMirrorMode) return // STOP Ghost Typing
            var meta = getMetaState()

        // DEBUG: Log Raw Input
        android.util.Log.d("DroidOS_Debug", "handleKeyPress: key='$key' customModKeyCode=$customModKeyCode")
    
            // 1. RESOLVE KEYCODE
            // We need the keycode early to check against customModKeyCode
            val charPair = if (key.length == 1) getSymbolKeyCode(key[0]) else Pair(0, false)
            var keyCode = charPair.first

            android.util.Log.d("DroidOS_Debug", "Resolved KeyCode: $keyCode")
            
            // Handle special keys mapping
            if (keyCode == 0 || keyCode == KeyEvent.KEYCODE_UNKNOWN) {
                 keyCode = when(key) {
                    "" -> KeyEvent.KEYCODE_DPAD_LEFT
                    "" -> KeyEvent.KEYCODE_DPAD_RIGHT
                    "" -> KeyEvent.KEYCODE_DPAD_UP
                    "" -> KeyEvent.KEYCODE_DPAD_DOWN
                    "ENTER" -> KeyEvent.KEYCODE_ENTER
                    "BKSP" -> KeyEvent.KEYCODE_DEL
                    "SPACE" -> KeyEvent.KEYCODE_SPACE
                    "TAB" -> KeyEvent.KEYCODE_TAB
                    "ESC" -> KeyEvent.KEYCODE_ESCAPE
                    else -> 0
                }
            }
    
                            // 2. CHECK CUSTOM MODIFIER (Toggle Latch)
                            if (!fromRepeat && customModKeyCode != 0 && keyCode == customModKeyCode) {
                                android.util.Log.d(TAG, "Custom Mod Key MATCH ($keyCode). Broadcasting & Latching...")

                                // Broadcast the modifier to Launcher so IT latches too
                                val intent = android.content.Intent("com.katsuyamaki.DroidOSLauncher.REMOTE_KEY")
                                intent.setPackage("com.katsuyamaki.DroidOSLauncher")
                                intent.putExtra("keyCode", keyCode)
                                intent.putExtra("metaState", meta)
                                context.sendBroadcast(intent)

                                // Latch locally so next key is broadcast too
                                isCustomModLatchedLocal = true
                                // No timer - stays latched until next non-modifier key press

                                return
                            }            // 3. INPUT CAPTURE REDIRECT (For Launcher Commands)
            val isLayerKey = key in setOf("SYM", "SYM1", "SYM2", "ABC", "SHIFT", "CAPS")
            if (isInputCaptureActive && !isLayerKey) {
                var finalCode = 0

                // Handle Digits (0-9) with reliable math
                if (key.length == 1 && Character.isDigit(key[0])) {
                    val digit = key[0] - '0'
                    finalCode = KeyEvent.KEYCODE_0 + digit
                }
                // Use already-resolved keyCode for other keys
                else if (keyCode != 0) {
                    finalCode = keyCode
                }

                // Send if valid
                if (finalCode != 0) {
                    val intent = android.content.Intent("com.katsuyamaki.DroidOSLauncher.REMOTE_KEY")
                    intent.setPackage("com.katsuyamaki.DroidOSLauncher")
                    intent.putExtra("keyCode", finalCode)
                    intent.putExtra("metaState", meta)
                    context.sendBroadcast(intent)
                    android.util.Log.d("KeyboardView", "Capture Mode: Sent $finalCode for key $key")
                }

                // BLOCK EVERYTHING - don't let keys leak to app
                return
            }
    
            if (fromRepeat && !isKeyRepeatable(key)) return
    
                    // =================================================================================
                    // MODIFIER SHORTCUT HANDLING WITH SELECTIVE BLOCKING
                    // SUMMARY: When a modifier is active (Ctrl/Alt/Meta/Custom), broadcasts the key
                    //          to the Launcher. Only blocks the system shortcut if:
                    //          1. overrideSystemShortcuts is enabled AND
                    //          2. The shortcut exists in launcherBlockedShortcuts set
                    //          This allows standard shortcuts like Ctrl+C/V to pass through.
                    // =================================================================================
                    val isModifierKey = key in setOf("SHIFT", "CTRL", "ALT", "META", "SYM", "SYM1", "SYM2", "ABC", "CAPS")

                    if (!fromRepeat && (isAltActive || isCtrlActive || isMetaActive || isCustomModLatchedLocal) && !isModifierKey) {
                        // Build the shortcut key string to check against blocked set
                        val shortcutKey = "$meta|$keyCode"
                        val isShortcutRegistered = launcherBlockedShortcuts.contains(shortcutKey)

                        android.util.Log.d(TAG, "Shortcut check: $shortcutKey, registered=$isShortcutRegistered, override=$overrideSystemShortcuts")

                        // Only broadcast to Launcher if this shortcut is registered there
                        if (isShortcutRegistered && keyCode != 0) {
                            val intent = android.content.Intent("com.katsuyamaki.DroidOSLauncher.REMOTE_KEY")
                            intent.setPackage("com.katsuyamaki.DroidOSLauncher")
                            intent.putExtra("keyCode", keyCode)
                            intent.putExtra("metaState", meta)
                            context.sendBroadcast(intent)
                            android.util.Log.d(TAG, "Broadcasting Remote Key: $key ($keyCode) (Latched: $isCustomModLatchedLocal)")
                        }

                        // Reset ALL modifiers (One-shot)
                        isCtrlActive = false
                        isAltActive = false
                        isMetaActive = false
                        isCustomModLatchedLocal = false
                        buildKeyboard()

                        // Only block system shortcut if:
                        // 1. Override is enabled
                        // 2. This specific shortcut is registered in the Launcher
                        if (overrideSystemShortcuts && isShortcutRegistered) {
                            android.util.Log.d(TAG, "Blocking system shortcut: $shortcutKey")
                            return
                        }
                        // If shortcut is NOT registered, let it pass through to the system
                        // (e.g., Ctrl+C, Ctrl+V will work normally)
                    }
                    // =================================================================================
                    // END BLOCK: MODIFIER SHORTCUT HANDLING WITH SELECTIVE BLOCKING
                    // =================================================================================            
            // 5. INTERNAL KEY LOGIC (Toggles)
            // ... (Keep existing switch(key) logic) ...
            when (key) {
                "CTRL" -> { if (!fromRepeat) { isCtrlActive = !isCtrlActive; buildKeyboard() } }
                "ALT" -> { if (!fromRepeat) { isAltActive = !isAltActive; buildKeyboard() } }
                
                "META" -> { if (!fromRepeat) { isMetaActive = !isMetaActive; buildKeyboard() } }            "SHIFT" -> { /* Handled in onKeyUp/Down */ }
                
                "BKSP" -> listener?.onSpecialKey(SpecialKey.BACKSPACE, meta)
                "ENTER" -> { if (!fromRepeat) listener?.onSpecialKey(SpecialKey.ENTER, meta) }
                "SPACE" -> listener?.onSpecialKey(SpecialKey.SPACE, meta)
                "ESC" -> { if (!fromRepeat) listener?.onSpecialKey(SpecialKey.ESCAPE, meta) }
                
                "" -> listener?.onSpecialKey(SpecialKey.ARROW_LEFT, meta)
                "" -> listener?.onSpecialKey(SpecialKey.ARROW_RIGHT, meta)
                "" -> listener?.onSpecialKey(SpecialKey.ARROW_UP, meta)
                "" -> listener?.onSpecialKey(SpecialKey.ARROW_DOWN, meta)
                
                "MUTE" -> { if (!fromRepeat) listener?.onSpecialKey(SpecialKey.MUTE, meta) }
                "VOL-" -> listener?.onSpecialKey(SpecialKey.VOL_DOWN, meta)
                "VOL+" -> listener?.onSpecialKey(SpecialKey.VOL_UP, meta)
                "BACK" -> { if (!fromRepeat) listener?.onSpecialKey(SpecialKey.BACK_NAV, meta) }
                "FWD" -> { if (!fromRepeat) listener?.onSpecialKey(SpecialKey.FWD_NAV, meta) }
                "MIC" -> { if (!fromRepeat) listener?.onSpecialKey(SpecialKey.VOICE_INPUT, meta) }
                
                                        // SCREEN key reused as TAB
                
                                        "TAB" -> { if (!fromRepeat) listener?.onSpecialKey(SpecialKey.TAB, meta) }            "HIDE_KB" -> { if (!fromRepeat) listener?.onSpecialKey(SpecialKey.HIDE_KEYBOARD, meta) }
                
                "SYM", "SYM1" -> { if (!fromRepeat) { currentState = KeyboardState.SYMBOLS_1; buildKeyboard() } }
                "SYM2" -> { if (!fromRepeat) { currentState = KeyboardState.SYMBOLS_2; buildKeyboard() } }
                "ABC" -> { if (!fromRepeat) { currentState = KeyboardState.LOWERCASE; buildKeyboard() } }
                
                else -> {
                    if (key.length == 1) {
                        val char = key[0]
                        val pair = getSymbolKeyCode(char)
                        val code = pair.first
                        val shiftNeeded = pair.second
                        if (shiftNeeded) meta = meta or KeyEvent.META_SHIFT_ON
                        listener?.onKeyPress(code, char, meta)
                        if (!fromRepeat && currentState == KeyboardState.UPPERCASE) { 
                            currentState = KeyboardState.LOWERCASE
                            buildKeyboard()
                        }
                    }
                }
            }
            // === DIRECT LINE TO LAUNCHER ===
            // If modifiers are active, broadcast the key to the Launcher immediately.
            // This bypasses Android's restriction on Accessibility Services seeing injected keys.
            if (!fromRepeat && (isAltActive || isCtrlActive || isMetaActive)) {
                val charCode = if (key.length == 1) getSymbolKeyCode(key[0]).first else 0
                // If it's a special key (like Arrow), convert it
                val finalCode = if (charCode != KeyEvent.KEYCODE_UNKNOWN && charCode != 0) charCode else when(key) {
                    "" -> KeyEvent.KEYCODE_DPAD_LEFT
                    "" -> KeyEvent.KEYCODE_DPAD_RIGHT
                    "" -> KeyEvent.KEYCODE_DPAD_UP
                    "" -> KeyEvent.KEYCODE_DPAD_DOWN
                    "ENTER" -> KeyEvent.KEYCODE_ENTER
                    "BKSP" -> KeyEvent.KEYCODE_DEL
                    "SPACE" -> KeyEvent.KEYCODE_SPACE
                    "TAB" -> KeyEvent.KEYCODE_TAB
                    else -> 0
                }
    
                if (finalCode != 0) {
                    val intent = android.content.Intent("com.katsuyamaki.DroidOSLauncher.REMOTE_KEY")
                    intent.setPackage("com.katsuyamaki.DroidOSLauncher") // Target the Launcher explicitly
                    intent.putExtra("keyCode", finalCode)
                    intent.putExtra("metaState", getMetaState())
                    context.sendBroadcast(intent)
                    android.util.Log.d("KeyboardView", "Broadcasting Remote Key: $key ($finalCode) Meta: ${getMetaState()}")
                }
            }
            // === END DIRECT LINE ===
    
            if (!fromRepeat && key != "CTRL" && key != "ALT" && key != "SHIFT" && key != "META") {
                if (isCtrlActive || isAltActive || isMetaActive) {
                    isCtrlActive = false; isAltActive = false; isMetaActive = false; buildKeyboard()
                }
            }
        }
    private fun getSymbolKeyCode(c: Char): Pair<Int, Boolean> {
        return when (c) {
            in 'a'..'z' -> KeyEvent.keyCodeFromString("KEYCODE_${c.uppercase()}") to false
            in 'A'..'Z' -> KeyEvent.keyCodeFromString("KEYCODE_${c}") to true
            in '0'..'9' -> KeyEvent.keyCodeFromString("KEYCODE_${c}") to false
            ' ' -> KeyEvent.KEYCODE_SPACE to false
            '.' -> KeyEvent.KEYCODE_PERIOD to false
            ',' -> KeyEvent.KEYCODE_COMMA to false
            ';' -> KeyEvent.KEYCODE_SEMICOLON to false
            ':' -> KeyEvent.KEYCODE_SEMICOLON to true
            '=' -> KeyEvent.KEYCODE_EQUALS to false
            '+' -> KeyEvent.KEYCODE_PLUS to false
            '-' -> KeyEvent.KEYCODE_MINUS to false
            '_' -> KeyEvent.KEYCODE_MINUS to true
            '/' -> KeyEvent.KEYCODE_SLASH to false
            '?' -> KeyEvent.KEYCODE_SLASH to true
            '`' -> KeyEvent.KEYCODE_GRAVE to false
            '~' -> KeyEvent.KEYCODE_GRAVE to true
            '[' -> KeyEvent.KEYCODE_LEFT_BRACKET to false
            '{' -> KeyEvent.KEYCODE_LEFT_BRACKET to true
            ']' -> KeyEvent.KEYCODE_RIGHT_BRACKET to false
            '}' -> KeyEvent.KEYCODE_RIGHT_BRACKET to true
            '\\' -> KeyEvent.KEYCODE_BACKSLASH to false
            '|' -> KeyEvent.KEYCODE_BACKSLASH to true
            '\'' -> KeyEvent.KEYCODE_APOSTROPHE to false
            '"' -> KeyEvent.KEYCODE_APOSTROPHE to true
            '!' -> KeyEvent.KEYCODE_1 to true
            '@' -> KeyEvent.KEYCODE_2 to true
            '#' -> KeyEvent.KEYCODE_3 to true
            '$' -> KeyEvent.KEYCODE_4 to true
            '%' -> KeyEvent.KEYCODE_5 to true
            '^' -> KeyEvent.KEYCODE_6 to true
            '&' -> KeyEvent.KEYCODE_7 to true
            '*' -> KeyEvent.KEYCODE_8 to true
            '(' -> KeyEvent.KEYCODE_9 to true
            ')' -> KeyEvent.KEYCODE_0 to true
            '' -> KeyEvent.KEYCODE_UNKNOWN to false // Filler
            else -> KeyEvent.KEYCODE_UNKNOWN to false
        }
    }

    private fun toggleShift() {
        currentState = when (currentState) {
            KeyboardState.LOWERCASE -> KeyboardState.UPPERCASE
            KeyboardState.UPPERCASE -> KeyboardState.LOWERCASE
            KeyboardState.CAPS_LOCK -> KeyboardState.LOWERCASE
            else -> currentState
        }
        buildKeyboard()
    }

    private fun toggleCapsLock() {
        currentState = when (currentState) {
            KeyboardState.LOWERCASE, KeyboardState.UPPERCASE -> KeyboardState.CAPS_LOCK
            KeyboardState.CAPS_LOCK -> KeyboardState.LOWERCASE
            else -> currentState
        }
        if (vibrationEnabled) {
            val v = context.getSystemService(Context.VIBRATOR_SERVICE) as? Vibrator
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                v?.vibrate(VibrationEffect.createOneShot(50, VibrationEffect.DEFAULT_AMPLITUDE))
            } else { @Suppress("DEPRECATION") v?.vibrate(50) }
        }
        buildKeyboard()
    }

    private fun dpToPx(dp: Int): Int = TypedValue.applyDimension(
        TypedValue.COMPLEX_UNIT_DIP, dp.toFloat(), resources.displayMetrics
    ).roundToInt()


    override fun onDetachedFromWindow() {
        super.onDetachedFromWindow()
        handler.removeCallbacks(trackpadResetRunnable)
        handler.removeCallbacks(holdToDragRunnable)
        // ... (keep existing cleanup like stopRepeat)
    }

    // --- DRAG TO DELETE LOGIC ---
    private var dragStartX = 0f
    private var dragStartY = 0f
    private var isCandidateDragging = false
    private var activeDragCandidate: String? = null

    @SuppressLint("ClickableViewAccessibility")
    fun setSuggestions(candidates: List<Candidate>) {
        // [NEW] Sync local list
        currentCandidates.clear()
        currentCandidates.addAll(candidates)

        if (suggestionStrip == null) return
        // ... existing logic ...


        // Update empty state flag
        isPredictiveBarEmpty = candidates.isEmpty() || candidates.all { it.text.isEmpty() }

        if (isPredictiveBarEmpty) {
            cand1?.visibility = View.GONE
            cand2?.visibility = View.GONE
            cand3?.visibility = View.GONE
            div1?.visibility = View.GONE
            div2?.visibility = View.GONE
            return
        }

        div1?.visibility = View.VISIBLE
        div2?.visibility = View.VISIBLE

        val views = listOf(cand1, cand2, cand3)

for (i in 0 until 3) {
            val view = views[i] ?: continue
            if (i < candidates.size) {
                val item = candidates[i]
                view.text = item.text
                view.visibility = View.VISIBLE
                view.alpha = 1.0f


                // =======================================================================
                // VISUAL STYLING BASED ON WORD TYPE AND PREDICTION SOURCE
                // Priority order:
                //   1. isNew = RED (word not in dictionary)
                //   2. PRECISE source = GREEN (slow swipe winner)
                //   3. SHAPE_CONTEXT source = BLUE (fast swipe winner)
                //   4. isCustom = WHITE ITALIC (user dictionary)
                //   5. Default = WHITE BOLD (main dictionary)
                // =======================================================================
                val PRECISE_GREEN = Color.parseColor("#4CAF50")   // Material Green 500
                val SHAPE_BLUE = Color.parseColor("#2196F3")      // Material Blue 500
                
                when {
                    item.isNew -> {
                        // NOT IN DICTIONARY - Red, bold
                        view.setTextColor(Color.RED)
                        view.typeface = android.graphics.Typeface.DEFAULT_BOLD
                    }
                    item.source == PredictionSource.PRECISE -> {
                        // PRECISE ALGORITHM - Green, bold (slow swipe)
                        view.setTextColor(PRECISE_GREEN)
                        view.typeface = android.graphics.Typeface.DEFAULT_BOLD
                    }
                    item.source == PredictionSource.SHAPE_CONTEXT -> {
                        // SHAPE/CONTEXT ALGORITHM - Blue, bold (fast swipe)
                        view.setTextColor(SHAPE_BLUE)
                        view.typeface = android.graphics.Typeface.DEFAULT_BOLD
                    }
                    item.isCustom -> {
                        // USER DICTIONARY - White, italic
                        view.setTextColor(Color.WHITE)
                        view.typeface = android.graphics.Typeface.defaultFromStyle(android.graphics.Typeface.ITALIC)
                    }
                    else -> {
                        // MAIN DICTIONARY - White, bold
                        view.setTextColor(Color.WHITE)
                        view.typeface = android.graphics.Typeface.DEFAULT_BOLD
                    }
                }
                // =======================================================================
                // END BLOCK: Visual styling with algorithm color coding
                // =======================================================================

                // TOUCH LISTENER: Handle Click vs Drag
                view.setOnTouchListener { v, event ->
                    handleCandidateTouch(v, event, item)
                }
            } else {
                view.visibility = View.INVISIBLE
                view.setOnTouchListener(null)
            }
        }
    }

    // =================================================================================
    // FUNCTION: handleCandidateTouch
    // SUMMARY: Handles touch events on suggestion candidates. Detects click vs drag.
    //          Dragging to backspace triggers word deletion (block from dictionary).
    //          DEBUG: Comprehensive logging to trace touch flow.
    // =================================================================================
    private fun handleCandidateTouch(view: View, event: MotionEvent, item: Candidate): Boolean {
        when (event.action) {
            MotionEvent.ACTION_DOWN -> {
                android.util.Log.d("DroidOS_Drag", "CANDIDATE DOWN: '${item.text}' at (${event.rawX.toInt()}, ${event.rawY.toInt()})")
                dragStartX = event.rawX
                dragStartY = event.rawY
                isCandidateDragging = false
                activeDragCandidate = item.text
                return true
            }
            MotionEvent.ACTION_MOVE -> {
                val dx = event.rawX - dragStartX
                val dy = event.rawY - dragStartY
                val dist = kotlin.math.hypot(dx.toDouble(), dy.toDouble())

                // Threshold to start dragging (20px)
if (!isCandidateDragging && dist > 20) {
                    isCandidateDragging = true
                    android.util.Log.d("DroidOS_Drag", "CANDIDATE DRAG START: '${item.text}' (moved ${dist.toInt()}px)")
                    // Visual feedback: Keep White (No Dimming)
                    view.alpha = 1.0f
                }

                if (isCandidateDragging) {
                    // Check if hovering over BACKSPACE
                    val bkspKey = findViewWithTag<View>("BKSP")
                    if (bkspKey != null) {
                        val loc = IntArray(2)
                        bkspKey.getLocationOnScreen(loc)
                        val kx = loc[0]
                        val ky = loc[1]
                        val kw = bkspKey.width
                        val kh = bkspKey.height

                        // Check intersection
                        val isOverBksp = event.rawX >= kx && event.rawX <= kx + kw &&
                                         event.rawY >= ky && event.rawY <= ky + kh

                        if (isOverBksp) {
                            // HOVERING: Turn Red
                            setKeyVisual(bkspKey, false, "BKSP", overrideColor = Color.RED)
                        } else {
                            // NORMAL
                            setKeyVisual(bkspKey, false, "BKSP")
                        }
                    }
                }
                return true
            }
            MotionEvent.ACTION_UP -> {
                android.util.Log.d("DroidOS_Drag", "CANDIDATE UP: '${item.text}' isCandidateDragging=$isCandidateDragging")
                view.alpha = 1.0f
                val bkspKey = findViewWithTag<View>("BKSP")
                if (bkspKey != null) setKeyVisual(bkspKey, false, "BKSP") // Reset color

                if (isCandidateDragging) {
                    // Check Drop Target
                    if (bkspKey != null) {
                        val loc = IntArray(2)
                        bkspKey.getLocationOnScreen(loc)
                        val isOverBksp = event.rawX >= loc[0] && event.rawX <= loc[0] + bkspKey.width &&
                                         event.rawY >= loc[1] && event.rawY <= loc[1] + bkspKey.height

                        android.util.Log.d("DroidOS_Drag", "DROP CHECK: rawX=${event.rawX.toInt()}, rawY=${event.rawY.toInt()}, bksp=(${loc[0]},${loc[1]},${bkspKey.width},${bkspKey.height}), isOver=$isOverBksp")

                        if (isOverBksp) {
                            // DROPPED ON BACKSPACE -> DELETE
                            android.util.Log.d("DroidOS_Drag", "DROP ON BKSP: Calling onSuggestionDropped('${item.text}')")
                            listener?.onSuggestionDropped(item.text)
                            performHapticFeedback(HapticFeedbackConstants.LONG_PRESS)
                        }
                    } else {
                        android.util.Log.e("DroidOS_Drag", "ERROR: bkspKey is NULL!")
                    }
                } else {
                    // CLICK -> SELECT
                    android.util.Log.d("DroidOS_Drag", "CANDIDATE CLICK: '${item.text}'")
                    listener?.onSuggestionClick(item.text, item.isNew)
                    view.performClick()
                }
                isCandidateDragging = false
                activeDragCandidate = null
                return true
            }
            MotionEvent.ACTION_CANCEL -> {
                android.util.Log.d("DroidOS_Drag", "CANDIDATE CANCEL: '${item.text}'")
                view.alpha = 1.0f
                isCandidateDragging = false
                activeDragCandidate = null
                val bkspKey = findViewWithTag<View>("BKSP")
                if (bkspKey != null) setKeyVisual(bkspKey, false, "BKSP")
                return true
            }
        }
        return false
    }
    // =================================================================================
    // END BLOCK: handleCandidateTouch with debug logging
    // =================================================================================

}
```

## File: Cover-Screen-Trackpad/app/src/main/res/layout/layout_input_dock.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/dock_container"
    android:layout_width="match_parent"
    android:layout_height="40dp"
    android:minHeight="40dp"
    android:orientation="horizontal"
    android:background="#1A1A1A"
    android:gravity="center_vertical"
    android:weightSum="5">

    <!-- 1. Keyboard Toggle -->
    <ImageView
        android:id="@+id/btn_dock_keyboard"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1"
        android:src="@drawable/ic_dock_keyboard"
        android:scaleType="centerInside"
        android:padding="8dp"
        android:tint="#3DDC84"
        android:background="?android:attr/selectableItemBackground"
        android:contentDescription="Open DroidOS Keyboard"/>

    <!-- 2. Voice Input -->
    <ImageView
        android:id="@+id/btn_dock_voice"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1"
        android:src="@drawable/ic_dock_mic"
        android:scaleType="centerInside"
        android:padding="8dp"
        android:tint="#FFFFFF"
        android:background="?android:attr/selectableItemBackground"
        android:contentDescription="Voice Input"/>

    <!-- 3. Paste -->
    <ImageView
        android:id="@+id/btn_dock_paste"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1"
        android:src="@drawable/ic_dock_paste"
        android:scaleType="centerInside"
        android:padding="8dp"
        android:tint="#FFFFFF"
        android:background="?android:attr/selectableItemBackground"
        android:contentDescription="Paste"/>

    <!-- 4. Switch IME -->
    <ImageView
        android:id="@+id/btn_dock_switch"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1"
        android:src="@drawable/ic_dock_switch"
        android:scaleType="centerInside"
        android:padding="8dp"
        android:tint="#888888"
        android:background="?android:attr/selectableItemBackground"
        android:contentDescription="Switch Keyboard"/>

    <!-- 5. Hide -->
    <ImageView
        android:id="@+id/btn_dock_hide"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1"
        android:src="@drawable/ic_dock_close"
        android:scaleType="centerInside"
        android:padding="8dp"
        android:tint="#FF5555"
        android:background="?android:attr/selectableItemBackground"
        android:contentDescription="Hide Dock"/>

</LinearLayout>
```

## File: Cover-Screen-Launcher/app/src/main/java/com/example/quadrantlauncher/ShellUserService.kt
```kotlin
package com.example.quadrantlauncher

import android.content.ContentResolver
import android.content.Context
import android.content.ContextWrapper
import android.os.Binder
import android.os.IBinder
import android.provider.Settings
import android.util.Log
import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.ArrayList
import java.util.regex.Pattern
import android.os.Build

class ShellUserService : IShellService.Stub() {

    private val TAG = "ShellUserService"

    companion object {
        const val POWER_MODE_OFF = 0
        const val POWER_MODE_NORMAL = 2

        @Volatile private var displayControlClass: Class<*>? = null
        @Volatile private var displayControlClassLoaded = false
    }

    // === EFFICIENCY CACHE ===
    private var cachedVisiblePackages: List<String> = emptyList()
    private var lastVisibleCacheTime: Long = 0
    private val VISIBLE_CACHE_TTL = 800L // 800ms Cache Validity
    // Cache for Gemini task ID since it trampolines and becomes invisible
    // The BardEntryPointActivity creates a task, then immediately redirects to Google QSB
    // After trampoline, the original task disappears from am stack list
    // We cache the exact task ID when found and reuse it for subsequent repositions
    private var cachedGeminiTaskId: Int = -1
    private var cachedGeminiTaskTime: Long = 0
    private val GEMINI_CACHE_VALIDITY_MS = 30000L  // Cache valid for 30 seconds
    // === GEMINI TASK CACHE - END ===

    private val surfaceControlClass: Class<*> by lazy {
        Class.forName("android.view.SurfaceControl")
    }

    private fun getDisplayControlClass(): Class<*>? {
        if (displayControlClassLoaded && displayControlClass != null) return displayControlClass
        
        return try {
            val classLoaderFactoryClass = Class.forName("com.android.internal.os.ClassLoaderFactory")
            val createClassLoaderMethod = classLoaderFactoryClass.getDeclaredMethod(
                "createClassLoader",
                String::class.java,
                String::class.java,
                String::class.java,
                ClassLoader::class.java,
                Int::class.javaPrimitiveType,
                Boolean::class.javaPrimitiveType,
                String::class.java
            )
            val classLoader = createClassLoaderMethod.invoke(
                null, "/system/framework/services.jar", null, null,
                ClassLoader.getSystemClassLoader(), 0, true, null
            ) as ClassLoader

            val loadedClass = classLoader.loadClass("com.android.server.display.DisplayControl").also {
                val loadMethod = Runtime::class.java.getDeclaredMethod(
                    "loadLibrary0",
                    Class::class.java,
                    String::class.java
                )
                loadMethod.isAccessible = true
                loadMethod.invoke(Runtime.getRuntime(), it, "android_servers")
            }
            
            displayControlClass = loadedClass
            displayControlClassLoaded = true
            loadedClass
        } catch (e: Throwable) {
            // [STABILITY] Catch Throwable to handle NoClassDefFoundError/LinkageError
            Log.w(TAG, "DisplayControl reflection failed: ${e.message}")
            displayControlClassLoaded = true // Stop retrying if it fails
            null
        }
    }

    private fun getAllPhysicalDisplayTokens(): List<IBinder> {
        val tokens = ArrayList<IBinder>()
        try {
            val physicalIds: LongArray = if (Build.VERSION.SDK_INT >= 34) {
                val controlClass = getDisplayControlClass()
                if (controlClass != null) {
                    controlClass.getMethod("getPhysicalDisplayIds").invoke(null) as LongArray
                } else {
                     try {
                        surfaceControlClass.getMethod("getPhysicalDisplayIds").invoke(null) as LongArray
                     } catch (e: Exception) { LongArray(0) }
                }
            } else {
                surfaceControlClass.getMethod("getPhysicalDisplayIds").invoke(null) as LongArray
            }

            if (physicalIds.isEmpty()) {
                getSurfaceControlInternalToken()?.let { tokens.add(it) }
                return tokens
            }

            for (id in physicalIds) {
                try {
                    val token: IBinder? = if (Build.VERSION.SDK_INT >= 34) {
                        val controlClass = getDisplayControlClass()
                        if (controlClass != null) {
                             controlClass.getMethod("getPhysicalDisplayToken", Long::class.javaPrimitiveType)
                                .invoke(null, id) as? IBinder
                        } else {
                            surfaceControlClass.getMethod("getPhysicalDisplayToken", Long::class.javaPrimitiveType)
                                .invoke(null, id) as? IBinder
                        }
                    } else {
                        surfaceControlClass.getMethod("getPhysicalDisplayToken", Long::class.javaPrimitiveType)
                            .invoke(null, id) as? IBinder
                    }
                    
                    if (token != null) tokens.add(token)
                } catch (e: Throwable) {
                    Log.w(TAG, "Failed to get token for physical ID $id")
                }
            }
        } catch (e: Throwable) {
            Log.e(TAG, "Critical failure getting display tokens: ${e.message}")
        }
        return tokens
    }

    private fun getSurfaceControlInternalToken(): IBinder? {
        return try {
            if (Build.VERSION.SDK_INT < 29) {
                surfaceControlClass.getMethod("getBuiltInDisplay", Int::class.java).invoke(null, 0) as IBinder
            } else {
                surfaceControlClass.getMethod("getInternalDisplayToken").invoke(null) as IBinder
            }
        } catch (e: Exception) { null }
    }

    private fun setPowerModeOnToken(token: IBinder, mode: Int) {
        try {
            val method = surfaceControlClass.getMethod(
                "setDisplayPowerMode",
                IBinder::class.java,
                Int::class.javaPrimitiveType
            )
            method.invoke(null, token, mode)
        } catch (e: Exception) {
            Log.e(TAG, "setDisplayPowerMode failed for token $token", e)
        }
    }

    private fun setDisplayBrightnessOnToken(token: IBinder, brightness: Float): Boolean {
        try {
            val method = surfaceControlClass.getMethod(
                "setDisplayBrightness",
                IBinder::class.java,
                Float::class.javaPrimitiveType
            )
            method.invoke(null, token, brightness)
            return true
        } catch (e: Exception) {
             try {
                val method = surfaceControlClass.getMethod(
                    "setDisplayBrightness",
                    IBinder::class.java,
                    Float::class.javaPrimitiveType,
                    Float::class.javaPrimitiveType,
                    Float::class.javaPrimitiveType,
                    Float::class.javaPrimitiveType
                )
                method.invoke(null, token, brightness, brightness, brightness, brightness)
                return true
            } catch (e2: Exception) {
                return false
            }
        }
    }

    private fun setDisplayBrightnessInternal(displayId: Int, brightness: Float): Boolean {
        // Legacy shim for single-target calls
        val tokens = getAllPhysicalDisplayTokens()
        if (tokens.isNotEmpty()) return setDisplayBrightnessOnToken(tokens[0], brightness)
        return false
    }

    private val shLock = Object()
    private var _shProcess: Process? = null
    private val shProcess: Process
        get() = synchronized(shLock) {
            if (_shProcess?.isAlive == true) _shProcess!!
            else Runtime.getRuntime().exec(arrayOf("sh")).also { _shProcess = it }
        }

    private fun execShellCommand(command: String) {
        synchronized(shLock) {
            try {
                val output = shProcess.outputStream
                output.write("$command\n".toByteArray())
                output.flush()
            } catch (e: Exception) {
                Log.e(TAG, "Shell command failed", e)
            }
        }
    }

    // ============================================================
    // AIDL Interface Implementations
    // ============================================================

    
override fun setBrightness(displayId: Int, brightness: Int) {
        Log.d(TAG, "setBrightness(Global Broadcast, Value: $brightness)")
        val token = Binder.clearCallingIdentity()
        try {
            if (brightness < 0) {
                // === SCREEN OFF ===
                execShellCommand("settings put system screen_brightness_mode 0")
                
                // Get ALL tokens, but ONLY apply to the first 2 (Main + Cover)
                // This prevents killing the Glasses (which would be index 2+)
                val tokens = getAllPhysicalDisplayTokens()
                val safeTokens = tokens.take(2)
                
                for (t in safeTokens) {
                    setDisplayBrightnessOnToken(t, -1.0f)
                }
                
                execShellCommand("settings put system screen_brightness_float -1.0")
                execShellCommand("settings put system screen_brightness -1")
            } else {
                // === SCREEN ON ===
                val floatVal = brightness.toFloat() / 255.0f
                
                // Restore ALL tokens (safety, in case user replugged glasses)
                val tokens = getAllPhysicalDisplayTokens()
                for (t in tokens) {
                    setDisplayBrightnessOnToken(t, floatVal)
                }
                
                execShellCommand("settings put system screen_brightness_float $floatVal")
                execShellCommand("settings put system screen_brightness $brightness")
            }
        } catch (e: Exception) {
            Log.e(TAG, "setBrightness failed", e)
        } finally {
             Binder.restoreCallingIdentity(token)
        }
    }

    override fun setScreenOff(displayIndex: Int, turnOff: Boolean) {
        Log.d(TAG, "setScreenOff(Global Broadcast, TurnOff: $turnOff)")
        val token = Binder.clearCallingIdentity()
        try {
            val mode = if (turnOff) POWER_MODE_OFF else POWER_MODE_NORMAL
            
            // Same safety limit: Only affect first 2 physical screens
            val tokens = getAllPhysicalDisplayTokens()
            val safeTokens = tokens.take(2)
            
            for (t in safeTokens) {
                setPowerModeOnToken(t, mode)
            }
        } catch (e: Exception) {
            Log.e(TAG, "setScreenOff failed", e)
        } finally {
            Binder.restoreCallingIdentity(token)
        }
    }
    // --- V1.0 LOGIC: Window Management (Retained for Tiling/Minimizing) ---
    
    override fun forceStop(packageName: String) {
        val token = Binder.clearCallingIdentity()
        try { 
            val realPkg = if (packageName.endsWith(":gemini")) packageName.substringBefore(":") else packageName
            Runtime.getRuntime().exec("am force-stop $realPkg").waitFor() 
        } catch (e: Exception) {} finally { Binder.restoreCallingIdentity(token) }
    }

    override fun runCommand(command: String) {
        val token = Binder.clearCallingIdentity()
        try { Runtime.getRuntime().exec(command).waitFor() } catch (e: Exception) {} finally { Binder.restoreCallingIdentity(token) }
    }

    override fun injectKey(keyCode: Int, action: Int, flags: Int, displayId: Int, metaState: Int) {
        val token = Binder.clearCallingIdentity()
        try {
            val cmd = "input keyevent --display $displayId $keyCode"
            Runtime.getRuntime().exec(cmd).waitFor()
        } catch (e: Exception) {
            Log.e(TAG, "injectKey failed", e)
        } finally {
            Binder.restoreCallingIdentity(token)
        }
    }



    // === REPOSITION TASK - START ===
    // Repositions a task window to specified bounds using am task commands
    override fun repositionTask(packageName: String, className: String?, left: Int, top: Int, right: Int, bottom: Int) {
        // Log.d(TAG, "repositionTask: pkg=$packageName cls=$className bounds=[$left,$top,$right,$bottom]")

        val tid = getTaskId(packageName, className)
        // Log.d(TAG, "repositionTask: getTaskId returned $tid")

        if (tid == -1) {
            // Log.w(TAG, "repositionTask: No task found for $packageName / $className")
            return
        }

        val token = Binder.clearCallingIdentity()
        try {
            // Set freeform windowing mode (mode 5)
            val modeCmd = "am task set-windowing-mode $tid 5"
            Log.d(TAG, "repositionTask: $modeCmd")
            val modeProc = Runtime.getRuntime().exec(arrayOf("sh", "-c", modeCmd))
            modeProc.waitFor()
            
            // Wait for OS animation/state-change (Samsung needs ~300ms)
            Thread.sleep(300)

            // Apply resize
            val resizeCmd = "am task resize $tid $left $top $right $bottom"
            Log.d(TAG, "repositionTask: $resizeCmd")
            val resizeProc = Runtime.getRuntime().exec(arrayOf("sh", "-c", resizeCmd))
            val exitCode = resizeProc.waitFor()

            Log.d(TAG, "repositionTask: resize exitCode=$exitCode for task $tid")

        } catch (e: Exception) {
            Log.e(TAG, "repositionTask: FAILED", e)
        } finally {
            Binder.restoreCallingIdentity(token)
        }
    }
    // === REPOSITION TASK - END ===



    // === GET VISIBLE PACKAGES - START ===
    // Returns list of packages that are actually visible on the specified display
    // Checks both mViewVisibility AND window frame bounds
    // Windows moved off-screen (left >= 10000) are considered not visible
    override fun getVisiblePackages(displayId: Int): List<String> {
        val now = System.currentTimeMillis()
        
        // [EFFICIENCY] Return cached result if valid
        if (now - lastVisibleCacheTime < VISIBLE_CACHE_TTL && cachedVisiblePackages.isNotEmpty()) {
            // Log.d("EFFICIENCY", "getVisiblePackages: CACHE HIT (Age: ${now - lastVisibleCacheTime}ms)")
            return ArrayList(cachedVisiblePackages)
        }
        
        // Log.d("EFFICIENCY", "getVisiblePackages: CACHE MISS - Running dumpsys...")

        val list = ArrayList<String>()
        val token = Binder.clearCallingIdentity()
        try {
            // Log.d(TAG, "getVisiblePackages: Checking display $displayId")
            val p = Runtime.getRuntime().exec("dumpsys window windows")
            val r = BufferedReader(InputStreamReader(p.inputStream))
            var line: String?
            var currentPkg: String? = null
            var isVisible = false
            var onCorrectDisplay = false
            var isOffScreen = false
            val windowPattern = Pattern.compile("Window\\{[0-9a-f]+ u\\d+ ([^\\}/ ]+)")
            val framePattern = Pattern.compile("(?:frame|mFrame)=\\[(\\d+),(\\d+)\\]\\[(\\d+),(\\d+)\\]")

            while (r.readLine().also { line = it } != null) {
                val l = line!!.trim()

                if (l.startsWith("Window #")) {
                    currentPkg = null
                    isVisible = false
                    onCorrectDisplay = false
                    isOffScreen = false
                    val matcher = windowPattern.matcher(l)
                    if (matcher.find()) currentPkg = matcher.group(1)
                }

                if (l.contains("displayId=$displayId") || l.contains("mDisplayId=$displayId")) {
                    onCorrectDisplay = true
                }

                if (l.contains("mViewVisibility=0x0")) {
                    isVisible = true
                }

                val frameMatcher = framePattern.matcher(l)
                if (frameMatcher.find()) {
                    try {
                        val left = frameMatcher.group(1)?.toIntOrNull() ?: 0
                        if (left >= 10000) {
                            isOffScreen = true
                            // Log.d(TAG, "getVisiblePackages: $currentPkg is off-screen (left=$left)")
                        }
                    } catch (e: Exception) {}
                }

                if (currentPkg != null && isVisible && onCorrectDisplay && !isOffScreen) {
                    if (isUserApp(currentPkg!!) && !list.contains(currentPkg!!)) {
                        list.add(currentPkg!!)
                    }
                    currentPkg = null
                }
            }
            r.close()
            p.waitFor()
            
            // [EFFICIENCY] Update Cache
            cachedVisiblePackages = ArrayList(list)
            lastVisibleCacheTime = now
            
        } catch (e: Exception) {
            Log.e(TAG, "getVisiblePackages: Error", e)
        } finally {
            Binder.restoreCallingIdentity(token)
        }
        return list
    }

    // [EFFICIENCY] Manual cache invalidation for instant UI updates after actions
    fun invalidateVisibleCache() {
        lastVisibleCacheTime = 0
    }

    override fun getAllRunningPackages(): List<String> {
        val list = ArrayList<String>()
        val token = Binder.clearCallingIdentity()
        try {
            val p = Runtime.getRuntime().exec("dumpsys activity activities")
            val r = BufferedReader(InputStreamReader(p.inputStream))
            var line: String?
            val recordPattern = Pattern.compile("ActivityRecord\\{[0-9a-f]+ u\\d+ ([a-zA-Z0-9_.]+)/")
            while (r.readLine().also { line = it } != null) {
                if (line!!.contains("ActivityRecord{")) {
                    val m = recordPattern.matcher(line!!)
                    if (m.find()) { val pkg = m.group(1); if (pkg != null && !list.contains(pkg) && isUserApp(pkg)) list.add(pkg) }
                }
            }
        } catch (e: Exception) {} finally { Binder.restoreCallingIdentity(token) }
        return list
    }

override fun getWindowLayouts(displayId: Int): List<String> {
    val results = ArrayList<String>()
    val token = Binder.clearCallingIdentity()
    try {
        val p = Runtime.getRuntime().exec("dumpsys activity activities")
        val r = BufferedReader(InputStreamReader(p.inputStream))
        var line: String?
        
        var currentDisplayId = -1
        var currentTaskBounds: String? = null
        var foundPackages = mutableSetOf<String>()
        
        val displayPattern = Pattern.compile("Display #(\\d+)")
        val boundsPattern = Pattern.compile("bounds=\\[(\\d+),(\\d+)\\]\\[(\\d+),(\\d+)\\]")
        val rectPattern = Pattern.compile("mBounds=Rect\\((\\d+), (\\d+) - (\\d+), (\\d+)\\)")
        val activityPattern = Pattern.compile("ActivityRecord\\{[0-9a-f]+ u\\d+ ([a-zA-Z0-9_.]+)/")

        while (r.readLine().also { line = it } != null) {
            val l = line!!
            
            val displayMatcher = displayPattern.matcher(l)
            if (displayMatcher.find()) {
                currentDisplayId = displayMatcher.group(1)?.toIntOrNull() ?: -1
            }
            
            if (currentDisplayId != displayId) continue
            
            val boundsMatcher = boundsPattern.matcher(l)
            if (boundsMatcher.find()) {
                val left = boundsMatcher.group(1)
                val top = boundsMatcher.group(2)
                val right = boundsMatcher.group(3)
                val bottom = boundsMatcher.group(4)
                currentTaskBounds = "$left,$top,$right,$bottom"
            }
            
            val rectMatcher = rectPattern.matcher(l)
            if (rectMatcher.find()) {
                val left = rectMatcher.group(1)
                val top = rectMatcher.group(2)
                val right = rectMatcher.group(3)
                val bottom = rectMatcher.group(4)
                currentTaskBounds = "$left,$top,$right,$bottom"
            }
            
            if (l.contains("ActivityRecord{") && currentTaskBounds != null) {
                val activityMatcher = activityPattern.matcher(l)
                if (activityMatcher.find()) {
                    val pkg = activityMatcher.group(1)
                    if (pkg != null && isUserApp(pkg) && !foundPackages.contains(pkg)) {
                        results.add("$pkg|$currentTaskBounds")
                        foundPackages.add(pkg)
                    }
                }
            }
        }
        
        r.close()
        p.waitFor()
    } catch (e: Exception) {
        Log.e(TAG, "getWindowLayouts failed", e)
    } finally {
        Binder.restoreCallingIdentity(token)
    }
    return results
}


    // === GET TASK ID - START ===
    // Uses 'am stack list' to find task ID
    // PRIORITY: Full component match (pkg/cls) > package match > short activity match
    // Handles trampolining apps like Gemini which redirect to different packages
    // For Gemini: caches the exact task ID when found since it becomes invisible after trampoline

    // === GEMINI TASK CACHE - START ===
    // Cache for Gemini task ID since it trampolines and becomes invisible
    // The BardEntryPointActivity creates a task, then immediately redirects to Google QSB
    // After trampoline, the original task disappears from am stack list
    // We cache the exact task ID when found and reuse it for subsequent repositions
    // === GEMINI TASK CACHE - END ===

    // === GET TASK ID - START ===
    // Uses 'am stack list' to find task ID
    // PRIORITY: Full component match (pkg/cls) > package match > short activity match
    // Handles trampolining apps like Gemini which redirect to different packages
    // For Gemini: caches the exact task ID when found since it becomes invisible after trampoline

    override fun getTaskId(packageName: String, className: String?): Int {
        var exactTaskId = -1      // Best: full component match
        var packageTaskId = -1    // Good: package name match
        var fallbackTaskId = -1   // Last resort: short activity name match
        
        val token = Binder.clearCallingIdentity()
        try {
            // Log.d(TAG, "getTaskId: Looking for pkg=$packageName cls=$className")
            
            // === GEMINI DETECTION ===
            val isGemini = packageName == "com.google.android.apps.bard" || 
                          (className?.contains("Bard") == true) ||
                          (className?.contains("bard") == true)
            
            // === GEMINI CACHE CHECK - START ===
            // For Gemini, we use a very short cache validity because the original task
            // gets destroyed quickly. After ~500ms, we should always search fresh
            // to find the trampoline target instead of the dead original task.
            if (isGemini && cachedGeminiTaskId > 0) {
                val cacheAge = System.currentTimeMillis() - cachedGeminiTaskTime
                // Use very short validity - 500ms max, not 30 seconds
                // After trampoline completes, the cached ID is useless
                val shortValidity = 500L
                if (cacheAge < shortValidity) {
                    Log.d(TAG, "getTaskId: Gemini using CACHED taskId=$cachedGeminiTaskId (age=${cacheAge}ms)")
                    return cachedGeminiTaskId
                } else {
                    Log.d(TAG, "getTaskId: Gemini cache too old (age=${cacheAge}ms > ${shortValidity}ms), searching fresh")
                    cachedGeminiTaskId = -1
                }
            }
            // === GEMINI CACHE CHECK - END ===
            
            if (isGemini) {
                Log.d(TAG, "getTaskId: Gemini detected, will check trampoline targets")
            }
            
            val cmd = arrayOf("sh", "-c", "am stack list")
            val p = Runtime.getRuntime().exec(cmd)
            val r = BufferedReader(InputStreamReader(p.inputStream))
            var line: String?
            
            // Build component string for exact matching
            val fullComponent = if (!className.isNullOrEmpty() && className != "null" && className != "default") {
                "$packageName/$className"
            } else {
                null
            }
            
            // Short activity name (fallback only)
            val shortActivity = className?.substringAfterLast(".")
            
            Log.d(TAG, "getTaskId: fullComponent=$fullComponent shortActivity=$shortActivity")
            
            while (r.readLine().also { line = it } != null) {
                val l = line!!.trim()
                
                if (!l.contains("taskId=") || !l.contains(":")) continue
                
                // Extract task ID from line
                val match = Regex("taskId=(\\d+):").find(l)
                if (match == null) continue
                
                val foundId = match.groupValues[1].toIntOrNull() ?: continue
                if (foundId <= 0) continue
                
                // PRIORITY 1: Exact full component match (highest priority)
                if (fullComponent != null && l.contains(fullComponent)) {
                    Log.d(TAG, "getTaskId: EXACT MATCH taskId=$foundId component=$fullComponent")
                    exactTaskId = foundId
                    // Keep searching - want most recent exact match
                }
                // PRIORITY 2: Package name match
                else if (l.contains("$packageName/")) {
                    Log.d(TAG, "getTaskId: PACKAGE MATCH taskId=$foundId pkg=$packageName")
                    packageTaskId = foundId
                }
                // PRIORITY 3: Gemini trampoline - check for Google Quick Search Box with Assistant activity
                // The actual Gemini UI runs in Google QSB with an assistant/robin activity
                // Avoid matching Android Auto ghost activities
                else if (isGemini && l.contains("com.google.android.googlequicksearchbox")) {
                    // Check if this is the actual assistant activity (not Auto ghost)
                    val isAssistantActivity = l.contains("assistant") || l.contains("robin") || l.contains("MainActivity")
                    val isAutoGhost = l.contains("auto") || l.contains("ghost")
                    
                    if (isAssistantActivity && !isAutoGhost) {
                        if (foundId > packageTaskId) {
                            Log.d(TAG, "getTaskId: GEMINI TRAMPOLINE MATCH taskId=$foundId (assistant activity)")
                            packageTaskId = foundId
                        }
                    } else {
                        Log.d(TAG, "getTaskId: GEMINI TRAMPOLINE SKIP taskId=$foundId (not assistant activity)")
                    }
                }

                // PRIORITY 4: Short activity name (ONLY if no better match exists)
                // Skip generic names that cause false positives
                else if (shortActivity != null && 
                         shortActivity != "MainActivity" &&  // Too generic
                         shortActivity != "default" &&       // Too generic
                         l.contains(shortActivity)) {
                    Log.d(TAG, "getTaskId: FALLBACK MATCH taskId=$foundId activity=$shortActivity")
                    fallbackTaskId = foundId
                }
            }
            r.close()
            p.waitFor()
            
            // Return best match in priority order
            val result = when {
                exactTaskId > 0 -> exactTaskId
                packageTaskId > 0 -> packageTaskId
                fallbackTaskId > 0 -> fallbackTaskId
                else -> -1
            }
            
            // === GEMINI TASK HANDLING - START ===
            // Gemini (com.google.android.apps.bard) is a trampolining app:
            // - BardEntryPointActivity creates a task, then DESTROYS it within ~40ms
            // - User is redirected to Google Quick Search Box
            // - The original task ID is useless because the task no longer exists
            // 
            // Strategy: Don't cache the destroyed task. Instead:
            // - If we have an exact match AND the task has activities, cache it
            // - If task has trampolined (no exact match), use the trampoline target
            // - For repositioning, the trampoline target (Google QSB) is what's actually running
            
            if (isGemini) {
                if (exactTaskId > 0) {
                    // We found an exact match - but is the task still alive?
                    // Check if this task actually has activities (not destroyed)
                    // For now, we'll cache it but with a very short validity
                    cachedGeminiTaskId = exactTaskId
                    cachedGeminiTaskTime = System.currentTimeMillis()
                    Log.d(TAG, "getTaskId: Gemini exact match found, CACHED taskId=$exactTaskId (may be short-lived)")
                } else if (packageTaskId > 0) {
                    // No exact match means trampoline completed
                    // The packageTaskId is the Google QSB task that Gemini is running in
                    // This is actually what we should reposition!
                    Log.d(TAG, "getTaskId: Gemini trampolined, using trampoline target taskId=$packageTaskId")
                    
                    // DON'T use cached ID - it's destroyed. Use the live trampoline target.
                    // Clear any stale cache
                    if (cachedGeminiTaskId > 0) {
                        Log.d(TAG, "getTaskId: Clearing stale Gemini cache (old=$cachedGeminiTaskId)")
                        cachedGeminiTaskId = -1
                    }
                    
                    return packageTaskId
                }
            }
            // === GEMINI TASK HANDLING - END ===
            
            Log.d(TAG, "getTaskId: Final result=$result (exact=$exactTaskId pkg=$packageTaskId fallback=$fallbackTaskId)")
            return result
            
        } catch (e: Exception) {
            Log.e(TAG, "getTaskId: FAILED", e)
            return -1
        } finally { 
            Binder.restoreCallingIdentity(token) 
        }
    }
    // === GET TASK ID - END ===

    // === GET TASK ID - END ===

    // === GET TASK ID - END ===

    // === DEBUG DUMP TASKS - START ===
    // Dumps raw task info for debugging
    fun debugDumpTasks(): String {
        val token = Binder.clearCallingIdentity()
        val result = StringBuilder()
        try {
            val cmd = arrayOf("sh", "-c", "dumpsys activity activities | head -100")
            val p = Runtime.getRuntime().exec(cmd)
            val r = BufferedReader(InputStreamReader(p.inputStream))
            var line: String?
            while (r.readLine().also { line = it } != null) {
                result.appendLine(line)
            }
            r.close()
            p.waitFor()
        } catch (e: Exception) {
            result.appendLine("ERROR: ${e.message}")
        } finally {
            Binder.restoreCallingIdentity(token)
        }
        return result.toString()
    }
    // === DEBUG DUMP TASKS - END ===

    // === MOVE TASK TO BACK / MINIMIZE TASK - START ===
    // Minimizes a task using Samsung's IMultiTaskingBinder from ActivityTaskManager
    // This is what Android's freeform minimize button uses on Samsung devices
    override fun moveTaskToBack(taskId: Int) {
        val token = Binder.clearCallingIdentity()
        try {
            Log.d(TAG, "moveTaskToBack: Minimizing taskId=$taskId via ATM.getMultiTaskingBinder()")

            var success = false

            try {
                // Get ActivityTaskManager service
                val atmClass = Class.forName("android.app.ActivityTaskManager")
                val getServiceMethod = atmClass.getMethod("getService")
                val atm = getServiceMethod.invoke(null)

                Log.d(TAG, "moveTaskToBack: Got ATM service")

                // Call getMultiTaskingBinder()
                val getMultiTaskingBinder = atm.javaClass.getMethod("getMultiTaskingBinder")
                val multiTaskingBinder = getMultiTaskingBinder.invoke(atm)

                if (multiTaskingBinder != null) {
                    Log.d(TAG, "moveTaskToBack: Got MultiTaskingBinder: ${multiTaskingBinder.javaClass.name}")

                    // Call minimizeTaskById(taskId)
                    val minimizeMethod = multiTaskingBinder.javaClass.getMethod(
                        "minimizeTaskById",
                        Int::class.javaPrimitiveType
                    )
                    minimizeMethod.invoke(multiTaskingBinder, taskId)

                    Log.d(TAG, "moveTaskToBack: minimizeTaskById($taskId) SUCCEEDED!")
                    success = true
                } else {
                    Log.w(TAG, "moveTaskToBack: getMultiTaskingBinder() returned null")
                }

            } catch (e: Exception) {
                Log.e(TAG, "moveTaskToBack: Samsung MultiTaskingBinder failed", e)
                e.printStackTrace()
            }

            // FALLBACK: Off-screen positioning (only if Samsung API failed)
            if (!success) {
                Log.w(TAG, "moveTaskToBack: Using off-screen fallback")
                val modeCmd = "am task set-windowing-mode $taskId 5"
                Runtime.getRuntime().exec(arrayOf("sh", "-c", modeCmd)).waitFor()
                Thread.sleep(100)
                val resizeCmd = "am task resize $taskId 99999 99999 100000 100000"
                Runtime.getRuntime().exec(arrayOf("sh", "-c", resizeCmd)).waitFor()
            }

        } catch (e: Exception) {
            Log.e(TAG, "moveTaskToBack: FAILED", e)
        } finally {
            Binder.restoreCallingIdentity(token)
        }
    }
    // === MOVE TASK TO BACK / MINIMIZE TASK - END ===

    private fun isUserApp(pkg: String): Boolean {
        if (pkg == "com.android.systemui") return false
        if (pkg == "com.android.launcher3") return false 
        if (pkg == "com.sec.android.app.launcher") return false 
        if (pkg == "com.katsuyamaki.DroidOSLauncher") return false
        if (pkg == "com.example.coverscreentester") return false
        if (pkg == "com.katsuyamaki.trackpad") return false
        if (pkg.contains("inputmethod")) return false
        if (pkg.contains("navigationbar")) return false
        if (pkg == "ScreenDecorOverlayCover") return false
        if (pkg == "RecentsTransitionOverlay") return false
        if (pkg == "FreeformContainer") return false
        if (pkg == "StatusBar") return false
        if (pkg == "NotificationShade") return false
        return true
    }

    // Interface compliance stubs
    override fun setSystemBrightness(brightness: Int) { execShellCommand("settings put system screen_brightness $brightness") }
    override fun getSystemBrightness(): Int = 128
    override fun getSystemBrightnessFloat(): Float = 0.5f
    override fun setAutoBrightness(enabled: Boolean) { execShellCommand("settings put system screen_brightness_mode ${if (enabled) 1 else 0}") }
    override fun isAutoBrightness(): Boolean = true
    override fun setBrightnessViaDisplayManager(displayId: Int, brightness: Float): Boolean = setDisplayBrightnessInternal(displayId, brightness)
}
```

## File: Cover-Screen-Launcher/app/src/main/java/com/example/quadrantlauncher/AppPreferences.kt
```kotlin
package com.example.quadrantlauncher

import android.content.Context

object AppPreferences {

    private const val PREFS_NAME = "AppLauncherPrefs"
    private const val KEY_FAVORITES = "KEY_FAVORITES"
    private const val KEY_LAST_LAYOUT = "KEY_LAST_LAYOUT"
    private const val KEY_LAST_CUSTOM_LAYOUT_NAME = "KEY_LAST_CUSTOM_LAYOUT_NAME"
    private const val KEY_PROFILES = "KEY_PROFILES"
    private const val KEY_CUSTOM_LAYOUTS = "KEY_CUSTOM_LAYOUTS"
    private const val KEY_FONT_SIZE = "KEY_FONT_SIZE"
    private const val KEY_ICON_URI = "KEY_ICON_URI"
    
    // Settings
    private const val KEY_KILL_ON_EXECUTE = "KEY_KILL_ON_EXECUTE"
    private const val KEY_TARGET_DISPLAY_INDEX = "KEY_TARGET_DISPLAY_INDEX"
    private const val KEY_IS_INSTANT_MODE = "KEY_IS_INSTANT_MODE"
    private const val KEY_LAST_QUEUE = "KEY_LAST_QUEUE"
    private const val KEY_SHOW_SHIZUKU_WARNING = "KEY_SHOW_SHIZUKU_WARNING"
    private const val KEY_REORDER_TIMEOUT = "KEY_REORDER_TIMEOUT"
    private const val KEY_USE_ALT_SCREEN_OFF = "KEY_USE_ALT_SCREEN_OFF" // New
    private const val KEY_AUTO_RESTART_TRACKPAD = "KEY_AUTO_RESTART_TRACKPAD"

    // === BLACKLIST STORAGE - START ===
    // Stores blacklisted apps using "packageName:activityName" format
    // This allows us to blacklist "com.google.android.googlequicksearchbox:.SearchActivity"
    // while keeping "com.google.android.googlequicksearchbox:robin.main.MainActivity" (Gemini) available
    private const val KEY_BLACKLIST = "KEY_BLACKLIST"
    // === BLACKLIST STORAGE - END ===

    // Reorder Methods
    private const val KEY_REORDER_METHOD_DRAG = "KEY_REORDER_METHOD_DRAG"
    private const val KEY_REORDER_METHOD_TAP = "KEY_REORDER_METHOD_TAP"
    private const val KEY_REORDER_METHOD_SCROLL = "KEY_REORDER_METHOD_SCROLL"
    
    // Drawer Geometry
    private const val KEY_DRAWER_HEIGHT = "KEY_DRAWER_HEIGHT"
    private const val KEY_DRAWER_WIDTH = "KEY_DRAWER_WIDTH"
    private const val KEY_AUTO_RESIZE_KEYBOARD = "KEY_AUTO_RESIZE_KEYBOARD"
    
    // Custom Resolutions
    private const val KEY_CUSTOM_RESOLUTION_NAMES = "KEY_CUSTOM_RESOLUTION_NAMES"

    private fun getPrefs(context: Context) =
        context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

    fun savePackage(context: Context, key: String, packageName: String) {
        getPrefs(context).edit().putString(key, packageName).apply()
    }

    fun loadPackage(context: Context, key: String): String? {
        return getPrefs(context).getString(key, null)
    }

    fun getSimpleName(pkg: String?): String {
        if (pkg == null) return "Select App"
        val name = pkg.substringAfterLast('.')
        return if (name.isNotEmpty()) name else pkg
    }

    fun getFavorites(context: Context): MutableSet<String> {
        return getPrefs(context).getStringSet(KEY_FAVORITES, mutableSetOf()) ?: mutableSetOf()
    }

    fun isFavorite(context: Context, packageName: String): Boolean {
        return getFavorites(context).contains(packageName)
    }

    fun toggleFavorite(context: Context, packageName: String): Boolean {
        val favorites = getFavorites(context)
        val newSet = HashSet(favorites)
        val isAdded: Boolean
        if (newSet.contains(packageName)) {
            newSet.remove(packageName)
            isAdded = false
        } else {
            newSet.add(packageName)
            isAdded = true
        }
        getPrefs(context).edit().putStringSet(KEY_FAVORITES, newSet).apply()
        return isAdded
    }
    
    // --- GLOBAL LAYOUT PREFS ---
    
    private fun getLayoutKey(displayId: Int): String {
        return if (displayId > 1) "KEY_LAST_LAYOUT_VIRTUAL" else "KEY_LAST_LAYOUT_D$displayId"
    }
    
    private fun getCustomLayoutNameKey(displayId: Int): String {
        return if (displayId > 1) "KEY_LAST_CUSTOM_NAME_VIRTUAL" else "KEY_LAST_CUSTOM_NAME_D$displayId"
    }

    fun saveLastLayout(context: Context, layoutId: Int, displayId: Int) {
        getPrefs(context).edit().putInt(getLayoutKey(displayId), layoutId).apply()
    }

    fun getLastLayout(context: Context, displayId: Int): Int {
        return getPrefs(context).getInt(getLayoutKey(displayId), 2)
    }
    
    fun saveLastCustomLayoutName(context: Context, name: String?, displayId: Int) {
        getPrefs(context).edit().putString(getCustomLayoutNameKey(displayId), name).apply()
    }

    fun getLastCustomLayoutName(context: Context, displayId: Int): String? {
        return getPrefs(context).getString(getCustomLayoutNameKey(displayId), null)
    }

    // --- PER-DISPLAY SETTINGS ---
    
    fun saveDisplayResolution(context: Context, displayId: Int, resIndex: Int) {
        getPrefs(context).edit().putInt("RES_D$displayId", resIndex).apply()
    }

    fun getDisplayResolution(context: Context, displayId: Int): Int {
        return getPrefs(context).getInt("RES_D$displayId", 0)
    }

    fun saveDisplayDpi(context: Context, displayId: Int, dpi: Int) {
        getPrefs(context).edit().putInt("DPI_D$displayId", dpi).apply()
    }

    fun getDisplayDpi(context: Context, displayId: Int): Int {
        return getPrefs(context).getInt("DPI_D$displayId", -1)
    }

    // --- PROFILES ---
    fun getProfileNames(context: Context): MutableSet<String> {
        return getPrefs(context).getStringSet(KEY_PROFILES, mutableSetOf()) ?: mutableSetOf()
    }

    fun saveProfile(context: Context, name: String, layout: Int, resIndex: Int, dpi: Int, apps: List<String>) {
        val names = getProfileNames(context)
        val newNames = HashSet(names)
        newNames.add(name)
        getPrefs(context).edit().putStringSet(KEY_PROFILES, newNames).apply()
        val appString = apps.joinToString(",")
        val data = "$layout|$resIndex|$dpi|$appString"
        getPrefs(context).edit().putString("PROFILE_$name", data).apply()
    }

    fun getProfileData(context: Context, name: String): String? {
        return getPrefs(context).getString("PROFILE_$name", null)
    }

    fun deleteProfile(context: Context, name: String) {
        val names = getProfileNames(context)
        val newNames = HashSet(names)
        newNames.remove(name)
        getPrefs(context).edit().putStringSet(KEY_PROFILES, newNames).remove("PROFILE_$name").apply()
    }

    fun renameProfile(context: Context, oldName: String, newName: String): Boolean {
        if (oldName == newName) return false
        if (newName.isEmpty()) return false
        val names = getProfileNames(context)
        if (!names.contains(oldName)) return false
        val data = getProfileData(context, oldName) ?: return false
        val newNames = HashSet(names)
        newNames.remove(oldName)
        newNames.add(newName)
        getPrefs(context).edit().putStringSet(KEY_PROFILES, newNames).apply()
        getPrefs(context).edit().putString("PROFILE_$newName", data).remove("PROFILE_$oldName").apply()
        return true
    }

    // --- CUSTOM LAYOUTS ---
    fun getCustomLayoutNames(context: Context): MutableSet<String> {
        return getPrefs(context).getStringSet(KEY_CUSTOM_LAYOUTS, mutableSetOf()) ?: mutableSetOf()
    }

    fun saveCustomLayout(context: Context, name: String, rectsData: String) {
        val names = getCustomLayoutNames(context)
        val newNames = HashSet(names)
        newNames.add(name)
        getPrefs(context).edit().putStringSet(KEY_CUSTOM_LAYOUTS, newNames).apply()
        getPrefs(context).edit().putString("LAYOUT_$name", rectsData).apply()
    }

    fun getCustomLayoutData(context: Context, name: String): String? {
        return getPrefs(context).getString("LAYOUT_$name", null)
    }
    
    fun deleteCustomLayout(context: Context, name: String) {
        val names = getCustomLayoutNames(context)
        val newNames = HashSet(names)
        newNames.remove(name)
        getPrefs(context).edit().putStringSet(KEY_CUSTOM_LAYOUTS, newNames).remove("LAYOUT_$name").apply()
    }
    
    fun renameCustomLayout(context: Context, oldName: String, newName: String): Boolean {
        if (oldName == newName) return false
        if (newName.isEmpty()) return false
        val names = getCustomLayoutNames(context)
        if (!names.contains(oldName)) return false
        val data = getCustomLayoutData(context, oldName) ?: return false
        val newNames = HashSet(names)
        newNames.remove(oldName)
        newNames.add(newName)
        getPrefs(context).edit().putStringSet(KEY_CUSTOM_LAYOUTS, newNames).apply()
        getPrefs(context).edit().putString("LAYOUT_$newName", data).remove("LAYOUT_$oldName").apply()
        return true
    }
    
    // --- CUSTOM RESOLUTIONS ---
    fun getCustomResolutionNames(context: Context): MutableSet<String> {
        return getPrefs(context).getStringSet(KEY_CUSTOM_RESOLUTION_NAMES, mutableSetOf()) ?: mutableSetOf()
    }

    fun saveCustomResolution(context: Context, name: String, value: String) {
        val names = getCustomResolutionNames(context)
        val newNames = HashSet(names)
        newNames.add(name)
        getPrefs(context).edit().putStringSet(KEY_CUSTOM_RESOLUTION_NAMES, newNames).apply()
        getPrefs(context).edit().putString("RES_$name", value).apply()
    }
    
    fun getCustomResolutionValue(context: Context, name: String): String? {
        return getPrefs(context).getString("RES_$name", null)
    }

    fun deleteCustomResolution(context: Context, name: String) {
        val names = getCustomResolutionNames(context)
        val newNames = HashSet(names)
        newNames.remove(name)
        getPrefs(context).edit().putStringSet(KEY_CUSTOM_RESOLUTION_NAMES, newNames).remove("RES_$name").apply()
    }
    
    fun renameCustomResolution(context: Context, oldName: String, newName: String): Boolean {
        if (oldName == newName) return false
        if (newName.isEmpty()) return false
        val names = getCustomResolutionNames(context)
        if (!names.contains(oldName)) return false
        val data = getCustomResolutionValue(context, oldName) ?: return false
        val newNames = HashSet(names)
        newNames.remove(oldName)
        newNames.add(newName)
        getPrefs(context).edit().putStringSet(KEY_CUSTOM_RESOLUTION_NAMES, newNames).apply()
        getPrefs(context).edit().putString("RES_$newName", data).remove("RES_$oldName").apply()
        return true
    }

    // --- FONT SIZE & ICONS & DRAWER ---
    fun saveFontSize(context: Context, size: Float) {
        getPrefs(context).edit().putFloat(KEY_FONT_SIZE, size).apply()
    }

    fun getFontSize(context: Context): Float {
        return getPrefs(context).getFloat(KEY_FONT_SIZE, 16f)
    }

    fun saveIconUri(context: Context, uri: String) {
        getPrefs(context).edit().putString(KEY_ICON_URI, uri).apply()
    }

    fun getIconUri(context: Context): String? {
        return getPrefs(context).getString(KEY_ICON_URI, null)
    }
    
    fun setDrawerHeightPercent(context: Context, percent: Int) {
        getPrefs(context).edit().putInt(KEY_DRAWER_HEIGHT, percent).apply()
    }
    
    fun getDrawerHeightPercent(context: Context): Int {
        return getPrefs(context).getInt(KEY_DRAWER_HEIGHT, 70)
    }
    
    fun setDrawerWidthPercent(context: Context, percent: Int) {
        getPrefs(context).edit().putInt(KEY_DRAWER_WIDTH, percent).apply()
    }
    
    fun getDrawerWidthPercent(context: Context): Int {
        return getPrefs(context).getInt(KEY_DRAWER_WIDTH, 90)
    }
    
    fun setAutoResizeKeyboard(context: Context, enable: Boolean) {
        getPrefs(context).edit().putBoolean(KEY_AUTO_RESIZE_KEYBOARD, enable).apply()
    }
    
    fun getAutoResizeKeyboard(context: Context): Boolean {
        return getPrefs(context).getBoolean(KEY_AUTO_RESIZE_KEYBOARD, true)
    }

    // --- SETTINGS ---
    fun setKillOnExecute(context: Context, kill: Boolean) {
        getPrefs(context).edit().putBoolean(KEY_KILL_ON_EXECUTE, kill).apply()
    }

    fun getKillOnExecute(context: Context): Boolean {
        // Default is FALSE for Kill On Execute
        return getPrefs(context).getBoolean(KEY_KILL_ON_EXECUTE, false)
    }

    fun setAutoRestartTrackpad(context: Context, enable: Boolean) {
        getPrefs(context).edit().putBoolean(KEY_AUTO_RESTART_TRACKPAD, enable).apply()
    }

    fun getAutoRestartTrackpad(context: Context): Boolean {
        return getPrefs(context).getBoolean(KEY_AUTO_RESTART_TRACKPAD, true) // Default ON
    }

    fun setTargetDisplayIndex(context: Context, index: Int) {
        getPrefs(context).edit().putInt(KEY_TARGET_DISPLAY_INDEX, index).apply()
    }

    fun getTargetDisplayIndex(context: Context): Int {
        return getPrefs(context).getInt(KEY_TARGET_DISPLAY_INDEX, 1)
    }

    fun setInstantMode(context: Context, enable: Boolean) {
        getPrefs(context).edit().putBoolean(KEY_IS_INSTANT_MODE, enable).apply()
    }

    fun getInstantMode(context: Context): Boolean {
        // Default is TRUE for Instant Mode
        return getPrefs(context).getBoolean(KEY_IS_INSTANT_MODE, true)
    }
    
    fun saveLastQueue(context: Context, apps: List<String>) {
        val str = apps.joinToString(",")
        getPrefs(context).edit().putString(KEY_LAST_QUEUE, str).apply()
    }
    
    fun getLastQueue(context: Context): List<String> {
        val str = getPrefs(context).getString(KEY_LAST_QUEUE, "") ?: ""
        if (str.isEmpty()) return emptyList()
        return str.split(",").filter { it.isNotEmpty() }
    }
    
    fun setShowShizukuWarning(context: Context, enable: Boolean) {
        getPrefs(context).edit().putBoolean(KEY_SHOW_SHIZUKU_WARNING, enable).apply()
    }

    fun getShowShizukuWarning(context: Context): Boolean {
        return getPrefs(context).getBoolean(KEY_SHOW_SHIZUKU_WARNING, true)
    }
    
    fun setUseAltScreenOff(context: Context, enable: Boolean) {
        getPrefs(context).edit().putBoolean(KEY_USE_ALT_SCREEN_OFF, enable).apply()
    }

    fun getUseAltScreenOff(context: Context): Boolean {
        // Default false (use standard SurfaceControl method)
        return getPrefs(context).getBoolean(KEY_USE_ALT_SCREEN_OFF, false)
    }
    
    // --- REORDER PREFERENCES ---
    fun setReorderTimeout(context: Context, seconds: Int) {
        getPrefs(context).edit().putInt(KEY_REORDER_TIMEOUT, seconds).apply()
    }
    
    fun getReorderTimeout(context: Context): Int {
        return getPrefs(context).getInt(KEY_REORDER_TIMEOUT, 2) // Default 2 seconds
    }
    
    fun setReorderDrag(context: Context, enable: Boolean) {
        getPrefs(context).edit().putBoolean(KEY_REORDER_METHOD_DRAG, enable).apply()
    }
    
    fun getReorderDrag(context: Context): Boolean {
        return getPrefs(context).getBoolean(KEY_REORDER_METHOD_DRAG, true) // Default ON
    }
    
    fun setReorderTap(context: Context, enable: Boolean) {
        getPrefs(context).edit().putBoolean(KEY_REORDER_METHOD_TAP, enable).apply()
    }
    
    fun getReorderTap(context: Context): Boolean {
        return getPrefs(context).getBoolean(KEY_REORDER_METHOD_TAP, false) // Default OFF
    }
    
    fun setReorderScroll(context: Context, enable: Boolean) {
        getPrefs(context).edit().putBoolean(KEY_REORDER_METHOD_SCROLL, enable).apply()
    }
    
    fun getReorderScroll(context: Context): Boolean {
        return getPrefs(context).getBoolean(KEY_REORDER_METHOD_SCROLL, true) // Default Enabled
    }

    // === BLACKLIST METHODS - START ===
    fun getBlacklist(context: Context): Set<String> {
        return getPrefs(context).getStringSet(KEY_BLACKLIST, emptySet()) ?: emptySet()
    }

    fun isBlacklisted(context: Context, identifier: String): Boolean {
        return getBlacklist(context).contains(identifier)
    }

    fun addToBlacklist(context: Context, identifier: String) {
        val current = getBlacklist(context).toMutableSet()
        current.add(identifier)
        getPrefs(context).edit().putStringSet(KEY_BLACKLIST, current).apply()
    }

    fun removeFromBlacklist(context: Context, identifier: String) {
        val current = getBlacklist(context).toMutableSet()
        current.remove(identifier)
        getPrefs(context).edit().putStringSet(KEY_BLACKLIST, current).apply()
    }

    fun toggleBlacklist(context: Context, identifier: String): Boolean {
        return if (isBlacklisted(context, identifier)) {
            removeFromBlacklist(context, identifier)
            false
        } else {
            addToBlacklist(context, identifier)
            true
        }
    }
    // === BLACKLIST METHODS - END ===

    // === KEYBIND METHODS ===
    // Stores "MODIFIER|KEYCODE" string for a command ID

    fun saveKeybind(context: Context, cmdId: String, modifier: Int, keyCode: Int) {
        val value = "$modifier|$keyCode"
        getPrefs(context).edit().putString("BIND_$cmdId", value).apply()
    }

    fun getKeybind(context: Context, cmdId: String): Pair<Int, Int> {
        val savedData = getPrefs(context).getString("BIND_$cmdId", null)
        
        if (savedData != null) {
            return try {
                val parts = savedData.split("|")
                Pair(parts[0].toInt(), parts[1].toInt())
            } catch (e: Exception) {
                Pair(0, 0)
            }
        }

        // DEFAULTS (Alt = 2)
        // O=43, H=36, L=40, I=37, J=38, K=39, X=52, Space=62, F=34, G=35
        return when (cmdId) {
            "SWAP" -> Pair(2, 43)              // Alt + O
            "SWAP_ACTIVE_LEFT" -> Pair(2, 36)  // Alt + H
            "SWAP_ACTIVE_RIGHT" -> Pair(2, 40) // Alt + L
            "HIDE" -> Pair(2, 37)              // Alt + I
            "MINIMIZE" -> Pair(2, 38)          // Alt + J
            "UNMINIMIZE" -> Pair(2, 39)        // Alt + K
            "KILL" -> Pair(2, 52)              // Alt + X
            "OPEN_DRAWER" -> Pair(2, 62)       // Alt + Space
            "SET_FOCUS" -> Pair(2, 34)         // Alt + F
            "FOCUS_LAST" -> Pair(2, 35)        // Alt + G
            else -> Pair(0, 0)
        }
    }

    fun clearKeybind(context: Context, cmdId: String) {
        getPrefs(context).edit().remove("BIND_$cmdId").apply()
    }

// Custom Modifier Key (Stored as KeyCode Int)
    fun saveCustomModKey(context: Context, keyCode: Int) {
        getPrefs(context).edit().putInt("CUSTOM_MOD_KEY", keyCode).apply()
    }

    fun getCustomModKey(context: Context): Int {
        return getPrefs(context).getInt("CUSTOM_MOD_KEY", 0)
    }

// Soft Keyboard Support (TextWatcher)
    fun setSoftKeyboardSupport(context: Context, enabled: Boolean) {
        getPrefs(context).edit().putBoolean("SOFT_KB_SUPPORT", enabled).apply()
    }
    
    fun getSoftKeyboardSupport(context: Context): Boolean {
        return getPrefs(context).getBoolean("SOFT_KB_SUPPORT", false) // Default OFF for privacy
    }

    // Returns a list of all defined keybinds in format "modifier|keyCode"
    fun getAllKeybinds(context: Context): ArrayList<String> {
        val list = ArrayList<String>()
        val allPrefs = getPrefs(context).all
        for ((key, value) in allPrefs) {
            if (key.startsWith("BIND_") && value is String) {
                // value format is "modifier|keyCode"
                list.add(value)
            }
        }
        return list
    }

    // --- BOTTOM MARGIN (Per Display) ---
    // Keys format: MARGIN_BOTTOM_D0, MARGIN_BOTTOM_D1, etc.
    
    fun setBottomMarginPercent(context: Context, displayId: Int, percent: Int) {
        getPrefs(context).edit().putInt("MARGIN_BOTTOM_D$displayId", percent).apply()
    }

    fun getBottomMarginPercent(context: Context, displayId: Int): Int {
        return getPrefs(context).getInt("MARGIN_BOTTOM_D$displayId", 0)
    }

    // --- TOP MARGIN (Per Display) ---
    
    fun setTopMarginPercent(context: Context, displayId: Int, percent: Int) {
        getPrefs(context).edit().putInt("MARGIN_TOP_D$displayId", percent).apply()
    }

    fun getTopMarginPercent(context: Context, displayId: Int): Int {
        return getPrefs(context).getInt("MARGIN_TOP_D$displayId", 0)
    }

    // --- DEFAULT LAYOUT RENAMING ---
    fun saveDefaultLayoutName(context: Context, type: Int, name: String) {
        getPrefs(context).edit().putString("DEF_LAYOUT_NAME_$type", name).apply()
    }

    fun getDefaultLayoutName(context: Context, type: Int): String? {
        return getPrefs(context).getString("DEF_LAYOUT_NAME_$type", null)
    }

    fun clearDefaultLayoutNames(context: Context) {
        val editor = getPrefs(context).edit()
        // Clear known IDs
        val knownIds = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9)
        for (id in knownIds) {
            editor.remove("DEF_LAYOUT_NAME_$id")
        }
        editor.apply()
    }
}
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/DockInputMethodService.kt
```kotlin
package com.example.coverscreentester

import android.content.BroadcastReceiver
import android.content.ClipboardManager
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.inputmethodservice.InputMethodService
import android.os.Build
import android.os.SystemClock
import android.view.KeyEvent
import android.view.LayoutInflater
import android.view.View
import android.view.inputmethod.InputConnection
import android.view.inputmethod.InputMethodManager
import android.widget.ImageView

/**
 * DroidOS Input Dock (formerly Null Keyboard).
 * Provides a minimal toolbar for essential actions while keeping the screen clear.
 * Acts as the injection target for the DroidOS Overlay Trackpad/Keyboard.
 */
class DockInputMethodService : InputMethodService() {

    companion object {
        private const val TAG = "DockIME"
        // Keep the original broadcast action for backward compatibility with OverlayService
        private const val BROADCAST_ACTION_TEXT = "com.example.coverscreentester.INJECT_TEXT"
        private const val BROADCAST_ACTION_KEY = "com.example.coverscreentester.INJECT_KEY"
        private const val BROADCAST_ACTION_DELETE = "com.example.coverscreentester.INJECT_DELETE"
    }

    private var dockView: View? = null

    // Receiver to handle text injection from the Overlay Trackpad
    private val inputReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            val ic = currentInputConnection ?: return
            
            when (intent?.action) {
                BROADCAST_ACTION_TEXT -> {
                    val text = intent.getStringExtra("text")
                    if (!text.isNullOrEmpty()) ic.commitText(text, 1)
                }
                BROADCAST_ACTION_KEY -> {
                    val code = intent.getIntExtra("keyCode", 0)
                    val metaState = intent.getIntExtra("metaState", 0)
                    if (code > 0) sendKeyEventWithMeta(ic, code, metaState)
                }
                BROADCAST_ACTION_DELETE -> {
                    val length = intent.getIntExtra("length", 1)
                    if (length > 0) ic.deleteSurroundingText(length, 0)
                }
            }
        }
    }

    override fun onWindowShown() {
        super.onWindowShown()
        loadDockPrefs()
        
        // Auto-show overlay keyboard if enabled
        if (prefAutoShowOverlay) {
            android.util.Log.d(TAG, "Dock shown - auto-showing overlay keyboard")
            val intent = Intent("TOGGLE_CUSTOM_KEYBOARD")
            intent.setPackage(packageName)
            intent.putExtra("FORCE_SHOW", true)
            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND)
            sendBroadcast(intent)
        }
        
        // Apply dock mode if enabled
        if (prefDockMode) {
            android.util.Log.d(TAG, "Dock shown - applying dock mode")
            val intent = Intent("APPLY_DOCK_MODE")
            intent.setPackage(packageName)
            intent.putExtra("enabled", true)
            sendBroadcast(intent)
            
            // Apply auto resize if enabled
            if (prefAutoResize) {
                updateInputViewHeight()
            }
        }
    }
    
    override fun onWindowHidden() {
        super.onWindowHidden()
        loadDockPrefs()
        
        // Auto-hide overlay keyboard if enabled
        if (prefAutoShowOverlay) {
            android.util.Log.d(TAG, "Dock hidden - auto-hiding overlay keyboard")
            val intent = Intent("TOGGLE_CUSTOM_KEYBOARD")
            intent.setPackage(packageName)
            intent.putExtra("FORCE_HIDE", true)
            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND)
            sendBroadcast(intent)
        }
    }

    override fun onCreateInputView(): View {
        try {
            loadDockPrefs()
            val inflater = getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
            dockView = inflater.inflate(R.layout.layout_input_dock, null)
            setupDockListeners(dockView!!)
            return dockView!!


        } catch (e: Exception) {
            // Safety Fallback: Return 0-size view if XML fails (prevents OverlayService crash)
            android.util.Log.e(TAG, "Failed to inflate Dock UI", e)
            return View(this).apply { 
                layoutParams = android.view.ViewGroup.LayoutParams(0, 0)
                visibility = View.GONE
            }
        }
    }

    // =================================================================================
    // DOCK POPUP MENU STATE
    // =================================================================================
    private var popupWindow: android.widget.PopupWindow? = null
    private var prefAutoShowOverlay = false
    private var prefDockMode = false
    private var prefAutoResize = false
    private var prefResizeScale = 0 // Default 0% (Range 0-50%)
    private var prefSyncMargin = false
    
    private val ACTION_MARGIN_CHANGED = "com.katsuyamaki.DroidOSLauncher.MARGIN_CHANGED"
    private val ACTION_SET_MARGIN = "com.katsuyamaki.DroidOSLauncher.SET_MARGIN_BOTTOM"
    
    // Callback to update UI if popup is open
    private var onMarginUpdatedCallback: ((Int) -> Unit)? = null

    private val marginReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            if (intent?.action == ACTION_MARGIN_CHANGED && prefSyncMargin) {
                val percent = intent.getIntExtra("PERCENT", 0)
                // Always update if different
                if (prefResizeScale != percent) {
                    prefResizeScale = percent
                    saveDockPrefs()
                    updateInputViewHeight()
                    
                    // Update UI if visible
                    onMarginUpdatedCallback?.invoke(percent)
                }
            }
        }
    }


    override fun onCreate() {
        super.onCreate()
        val filter = IntentFilter().apply {
            addAction(BROADCAST_ACTION_TEXT)
            addAction(BROADCAST_ACTION_KEY)
            addAction(BROADCAST_ACTION_DELETE)
            addAction(ACTION_MARGIN_CHANGED)
        }
        if (Build.VERSION.SDK_INT >= 33) {
            registerReceiver(inputReceiver, filter, Context.RECEIVER_NOT_EXPORTED)
            registerReceiver(marginReceiver, IntentFilter(ACTION_MARGIN_CHANGED), Context.RECEIVER_EXPORTED)
        } else {
            registerReceiver(inputReceiver, filter)
            registerReceiver(marginReceiver, IntentFilter(ACTION_MARGIN_CHANGED))
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        try { unregisterReceiver(inputReceiver) } catch (e: Exception) {}
        try { unregisterReceiver(marginReceiver) } catch (e: Exception) {}
    }

    private fun loadDockPrefs() {
        val prefs = getSharedPreferences("DockIMEPrefs", Context.MODE_PRIVATE)
        prefAutoShowOverlay = prefs.getBoolean("auto_show_overlay", false)
        prefDockMode = prefs.getBoolean("dock_mode", false)
        prefAutoResize = prefs.getBoolean("auto_resize", false)
        prefResizeScale = prefs.getInt("auto_resize_scale", 0)
        prefSyncMargin = prefs.getBoolean("sync_margin", false)
    }
    
    private fun saveDockPrefs() {
        getSharedPreferences("DockIMEPrefs", Context.MODE_PRIVATE).edit()
            .putBoolean("auto_show_overlay", prefAutoShowOverlay)
            .putBoolean("dock_mode", prefDockMode)
            .putBoolean("auto_resize", prefAutoResize)
            .putInt("auto_resize_scale", prefResizeScale)
            .putBoolean("sync_margin", prefSyncMargin)
            .apply()
    }
    // =================================================================================

    // END BLOCK: DOCK POPUP STATE
    // =================================================================================




    // =================================================================================
    // FUNCTION: setupDockListeners
    // SUMMARY: Sets up click handlers for all dock buttons.
    //          KB button has swipe-up gesture to show popup menu.
    // =================================================================================
    private fun setupDockListeners(view: View) {
        loadDockPrefs()
        
        val btnKeyboard = view.findViewById<View>(R.id.btn_dock_keyboard)
        val btnVoice = view.findViewById<View>(R.id.btn_dock_voice)
        val btnPaste = view.findViewById<View>(R.id.btn_dock_paste)
        val btnSwitch = view.findViewById<View>(R.id.btn_dock_switch)
        val btnHide = view.findViewById<View>(R.id.btn_dock_hide)

        // 1. KB Button - Tap to toggle, Swipe Up OR Long Press for popup menu
        var kbTouchStartY = 0f
        var kbTouchStartX = 0f
        var kbTouchStartTime = 0L
        var kbLongPressTriggered = false
        val swipeThreshold = 30f // Lower threshold for easier swipe detection
        val longPressDelay = 400L // ms
        
        val longPressRunnable = Runnable {
            kbLongPressTriggered = true
            android.util.Log.d(TAG, "KB long press -> showing popup")
            // Vibrate feedback
            val vibrator = getSystemService(Context.VIBRATOR_SERVICE) as? android.os.Vibrator
            if (android.os.Build.VERSION.SDK_INT >= 26) {
                vibrator?.vibrate(android.os.VibrationEffect.createOneShot(30, android.os.VibrationEffect.DEFAULT_AMPLITUDE))
            } else {
                @Suppress("DEPRECATION")
                vibrator?.vibrate(30)
            }
            showDockPopup(btnKeyboard!!)
        }
        val longPressHandler = android.os.Handler(android.os.Looper.getMainLooper())
        
        btnKeyboard?.setOnTouchListener { v, event ->
            when (event.action) {
                android.view.MotionEvent.ACTION_DOWN -> {
                    kbTouchStartY = event.rawY
                    kbTouchStartX = event.rawX
                    kbTouchStartTime = System.currentTimeMillis()
                    kbLongPressTriggered = false
                    // Start long press timer
                    longPressHandler.postDelayed(longPressRunnable, longPressDelay)
                    true
                }
                android.view.MotionEvent.ACTION_MOVE -> {
                    val deltaY = kbTouchStartY - event.rawY
                    val deltaX = kotlin.math.abs(event.rawX - kbTouchStartX)
                    // Cancel long press if user is swiping
                    if (deltaY > 15f || deltaX > 15f) {
                        longPressHandler.removeCallbacks(longPressRunnable)
                    }
                    // Check for swipe up during move
                    if (deltaY > swipeThreshold && deltaX < swipeThreshold * 2 && !kbLongPressTriggered) {
                        longPressHandler.removeCallbacks(longPressRunnable)
                        kbLongPressTriggered = true
                        android.util.Log.d(TAG, "KB swipe up -> showing popup")
                        showDockPopup(v)
                    }
                    true
                }
                android.view.MotionEvent.ACTION_UP, android.view.MotionEvent.ACTION_CANCEL -> {
                    longPressHandler.removeCallbacks(longPressRunnable)
                    val deltaY = kbTouchStartY - event.rawY
                    val duration = System.currentTimeMillis() - kbTouchStartTime
                    
                    if (!kbLongPressTriggered) {
                        // Normal tap - toggle keyboard (only if no popup was shown)
                        if (duration < longPressDelay && kotlin.math.abs(deltaY) < swipeThreshold) {
                            android.util.Log.d(TAG, "Dock KB tap -> TOGGLE_CUSTOM_KEYBOARD")
                            val intent = Intent("TOGGLE_CUSTOM_KEYBOARD")
                            intent.setPackage(packageName)
                            intent.putExtra("FORCE_SHOW", true)
                            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND)
                            sendBroadcast(intent)
                        }
                    }
                    v.performClick()
                    true
                }
                else -> false
            }
        }





        // 2. Voice Input
        // FIX: Use SHORT action - OverlayService listens for "REQUEST_VOICE_INPUT"
        btnVoice?.setOnClickListener {
            android.util.Log.d(TAG, "Dock MIC pressed -> REQUEST_VOICE_INPUT")
            val intent = Intent("REQUEST_VOICE_INPUT")
            intent.setPackage(packageName)
            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND)
            sendBroadcast(intent)
        }

        // 3. Paste
        btnPaste?.setOnClickListener {
            android.util.Log.d(TAG, "Dock PST pressed -> pasting clipboard")
            val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
            if (clipboard.hasPrimaryClip()) {
                val item = clipboard.primaryClip?.getItemAt(0)
                val text = item?.text
                if (!text.isNullOrEmpty()) {
                    currentInputConnection?.commitText(text, 1)
                }
            }
        }

        // 4. Switch IME
        btnSwitch?.setOnClickListener {
            android.util.Log.d(TAG, "Dock IME pressed -> showing picker")
            val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
            imm.showInputMethodPicker()
        }

        // 5. Hide Dock
        btnHide?.setOnClickListener {
            android.util.Log.d(TAG, "Dock X pressed -> hiding")
            requestHideSelf(0)
        }
    }
    // =================================================================================
    // END BLOCK: setupDockListeners
    // =================================================================================

    // =================================================================================
    // FUNCTION: showDockPopup
    // SUMMARY: Shows popup menu above the KB button with toggle options.
    //          Auto Resize option is only enabled when Dock Mode is active.
    // =================================================================================
    private fun showDockPopup(anchor: View) {
        // Dismiss existing popup if any
        popupWindow?.dismiss()
        
        val inflater = getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popupView = inflater.inflate(R.layout.layout_dock_popup, null)
        
        // Setup toggle visuals
        val toggleAutoShow = popupView.findViewById<View>(R.id.toggle_auto_show)
        val toggleDockMode = popupView.findViewById<View>(R.id.toggle_dock_mode)
        val toggleAutoResize = popupView.findViewById<View>(R.id.toggle_auto_resize)
        val iconAutoShow = popupView.findViewById<android.widget.ImageView>(R.id.icon_auto_show)
        val iconDockMode = popupView.findViewById<android.widget.ImageView>(R.id.icon_dock_mode)
        val iconAutoResize = popupView.findViewById<android.widget.ImageView>(R.id.icon_auto_resize)
        val textAutoResize = popupView.findViewById<android.widget.TextView>(R.id.text_auto_resize)
        val optionAutoResize = popupView.findViewById<View>(R.id.option_auto_resize)
        
        val containerSlider = popupView.findViewById<View>(R.id.container_resize_slider)
        val dividerResize = popupView.findViewById<View>(R.id.divider_resize)
        val textSliderLabel = popupView.findViewById<android.widget.TextView>(R.id.text_resize_label)
        val seekResize = popupView.findViewById<android.widget.SeekBar>(R.id.seekbar_resize_height)
        val checkSync = popupView.findViewById<android.widget.CheckBox>(R.id.checkbox_sync_margin)

        fun updateToggleVisuals() {
            // Option 1 & 2 - always enabled
            toggleAutoShow?.setBackgroundColor(if (prefAutoShowOverlay) 0xFF3DDC84.toInt() else 0xFF555555.toInt())
            toggleDockMode?.setBackgroundColor(if (prefDockMode) 0xFF3DDC84.toInt() else 0xFF555555.toInt())
            iconAutoShow?.setColorFilter(if (prefAutoShowOverlay) 0xFF3DDC84.toInt() else 0xFF888888.toInt())
            iconDockMode?.setColorFilter(if (prefDockMode) 0xFF3DDC84.toInt() else 0xFF888888.toInt())
            
            // Option 3 - Auto Resize: Only enabled when Dock Mode is ON
            val autoResizeEnabled = prefDockMode
            optionAutoResize?.alpha = if (autoResizeEnabled) 1.0f else 0.4f
            optionAutoResize?.isClickable = autoResizeEnabled
            
            if (autoResizeEnabled) {
                toggleAutoResize?.setBackgroundColor(if (prefAutoResize) 0xFF3DDC84.toInt() else 0xFF555555.toInt())
                iconAutoResize?.setColorFilter(if (prefAutoResize) 0xFF3DDC84.toInt() else 0xFF888888.toInt())
                textAutoResize?.setTextColor(0xFFFFFFFF.toInt())
            } else {
                toggleAutoResize?.setBackgroundColor(0xFF333333.toInt())
                iconAutoResize?.setColorFilter(0xFF555555.toInt())
                textAutoResize?.setTextColor(0xFF666666.toInt())
                // Also disable auto resize if dock mode is off
                if (prefAutoResize) {
                    prefAutoResize = false
                    saveDockPrefs()
                }
            }
            
            // Slider Visibility
            if (prefAutoResize && prefDockMode) {
                containerSlider?.visibility = View.VISIBLE
                dividerResize?.visibility = View.VISIBLE
            } else {
                containerSlider?.visibility = View.GONE
                dividerResize?.visibility = View.GONE
            }
        }
        updateToggleVisuals()
        
        // Register callback for external updates (from Launcher)
        onMarginUpdatedCallback = { newPercent ->
            seekResize?.progress = newPercent
            textSliderLabel?.text = "Bottom Margin: $newPercent%"
        }
        
        // Cleanup callback on dismiss
        popupWindow?.setOnDismissListener {
            onMarginUpdatedCallback = null
        }

        // Setup Sync Checkbox
        checkSync?.isChecked = prefSyncMargin
        checkSync?.setOnCheckedChangeListener { _, isChecked ->
            prefSyncMargin = isChecked
            saveDockPrefs()
            
            // If turned ON, immediately sync values
            if (isChecked) {
                // 1. Force Launcher to match IME
                val intent = Intent(ACTION_SET_MARGIN)
                intent.setPackage("com.katsuyamaki.DroidOSLauncher") // Explicit Target
                intent.putExtra("PERCENT", prefResizeScale)
                sendBroadcast(intent)
            }
        }

        // Setup Slider
        seekResize?.progress = prefResizeScale
        textSliderLabel?.text = "Bottom Margin: $prefResizeScale%"
        
        seekResize?.setOnSeekBarChangeListener(object : android.widget.SeekBar.OnSeekBarChangeListener {
            override fun onProgressChanged(seekBar: android.widget.SeekBar?, progress: Int, fromUser: Boolean) {
                if (fromUser) {
                    prefResizeScale = progress
                    textSliderLabel?.text = "Bottom Margin: $progress%"
                }
            }
            override fun onStartTrackingTouch(seekBar: android.widget.SeekBar?) {}
            override fun onStopTrackingTouch(seekBar: android.widget.SeekBar?) {
                saveDockPrefs()
                updateInputViewHeight()
                
                // Sync to Launcher if enabled
                if (prefSyncMargin) {
                    val intent = Intent(ACTION_SET_MARGIN)
                    intent.setPackage("com.katsuyamaki.DroidOSLauncher") // Explicit Target
                    intent.putExtra("PERCENT", prefResizeScale)
                    sendBroadcast(intent)
                }
            }
        })


        
        // Option 1: Auto-show overlay

        popupView.findViewById<View>(R.id.option_auto_show)?.setOnClickListener {
            prefAutoShowOverlay = !prefAutoShowOverlay
            saveDockPrefs()
            updateToggleVisuals()
            
            val intent = Intent("DOCK_PREF_CHANGED")
            intent.setPackage(packageName)
            intent.putExtra("auto_show_overlay", prefAutoShowOverlay)
            sendBroadcast(intent)
            
            android.util.Log.d(TAG, "Auto-show overlay: $prefAutoShowOverlay")
        }
        
        // Option 2: Dock mode
        popupView.findViewById<View>(R.id.option_dock_mode)?.setOnClickListener {
            prefDockMode = !prefDockMode
            saveDockPrefs()
            updateToggleVisuals()
            
            val intent = Intent("DOCK_PREF_CHANGED")
            intent.setPackage(packageName)
            intent.putExtra("dock_mode", prefDockMode)
            sendBroadcast(intent)
            
            android.util.Log.d(TAG, "Dock mode: $prefDockMode")
        }
        
        // Option 3: Auto Resize Apps (only when dock mode enabled)
        optionAutoResize?.setOnClickListener {
            if (!prefDockMode) return@setOnClickListener // Ignore if dock mode is off
            
            prefAutoResize = !prefAutoResize
            saveDockPrefs()
            updateToggleVisuals()
            updateInputViewHeight()
            
            val intent = Intent("DOCK_PREF_CHANGED")
            intent.setPackage(packageName)
            intent.putExtra("auto_resize", prefAutoResize)
            sendBroadcast(intent)
            
            android.util.Log.d(TAG, "Auto resize: $prefAutoResize")
        }
        
        // Create popup window
        popupWindow = android.widget.PopupWindow(
            popupView,
            android.view.ViewGroup.LayoutParams.WRAP_CONTENT,
            android.view.ViewGroup.LayoutParams.WRAP_CONTENT,
            true // focusable
        )
        
        popupWindow?.elevation = 16f
        popupWindow?.setBackgroundDrawable(android.graphics.drawable.ColorDrawable(0xFF2A2A2A.toInt()))
        
        // HELPER: Calculate position and show/update
        fun positionAndShow() {
            // Measure content to calculate correct offset (Popup grows upwards)
            popupView.measure(
                View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), 
                View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)
            )
            val h = popupView.measuredHeight
            
            // Calculate Y offset: -AnchorHeight (top of button) - PopupHeight (move popup above)
            val yOff = -anchor.height - h
            
            if (popupWindow?.isShowing == true) {
                popupWindow?.update(anchor, 0, yOff, -1, -1)
            } else {
                popupWindow?.showAsDropDown(anchor, 0, yOff)
            }
        }

        // Update listener to reposition when size changes (e.g. slider toggled)
        optionAutoResize?.setOnClickListener {
            if (!prefDockMode) return@setOnClickListener
            
            prefAutoResize = !prefAutoResize
            saveDockPrefs()
            updateToggleVisuals()
            updateInputViewHeight()
            
            // Recalculate position since height changed
            positionAndShow()
            
            val intent = Intent("DOCK_PREF_CHANGED")
            intent.setPackage(packageName)
            intent.putExtra("auto_resize", prefAutoResize)
            sendBroadcast(intent)
        }

        // Initial Show
        positionAndShow()
    }
    // =================================================================================
    // END BLOCK: showDockPopup
    // =================================================================================

    // =================================================================================
    // FUNCTION: updateInputViewHeight
    // SUMMARY: Adjusts the IME input view height based on Auto Resize setting.
    //          Calculates TOTAL height as percentage of REAL screen height.
    //          SUBTRACTS Navigation Bar height to prevent overlap with Launcher tiles.
    //          (Launcher tiles end at [Screen - Margin]. IME starts at [Screen - Nav - IME_H].
    //           If IME_H = Margin, then IME overlaps tiles by Nav height. 
    //           So we need IME_H = Margin - Nav).
    // =================================================================================
    private fun updateInputViewHeight() {
        if (dockView == null) return
        
        if (prefAutoResize && prefDockMode) {
            val wm = getSystemService(Context.WINDOW_SERVICE) as android.view.WindowManager
            
            // 1. Get Real Screen Height (Physical pixels)
            val metrics = android.util.DisplayMetrics()
            wm.defaultDisplay.getRealMetrics(metrics)
            val screenHeight = metrics.heightPixels
            
            // 2. Get Navigation Bar Height (Insets)
            val windowMetrics = wm.currentWindowMetrics
            val insets = windowMetrics.windowInsets.getInsetsIgnoringVisibility(
                android.view.WindowInsets.Type.navigationBars() or 
                android.view.WindowInsets.Type.displayCutout()
            )
            val navHeight = insets.bottom
            
            // 3. Calculate Margin Height (Desired clear space)
            val marginHeight = (screenHeight * (prefResizeScale / 100f)).toInt()
            
            // 4. Calculate IME Window Height
            // Subtract nav height because IME sits ON TOP of nav bar, while margin is from physical bottom.
            // [FIX] Subtract extra 2px safety buffer to handle rounding errors and ensure
            // the IME window stays strictly below the Launcher's tiling line.
            val correctedHeight = (marginHeight - navHeight - 2).coerceAtLeast(0)
            
            android.util.Log.d(TAG, "updateInputViewHeight: ON. Margin=$marginHeight, Nav=$navHeight -> IME Height=$correctedHeight")
            
            // Set the wrapped view (Transparent Header + Dock Footer)
            setInputView(createInputViewWrapper(correctedHeight))
        } else {

            // Reset to normal - just the toolbar
            android.util.Log.d(TAG, "updateInputViewHeight: OFF. Dock Only.")
            
            // CRITICAL: Must detach from any previous wrapper before re-using
            (dockView?.parent as? android.view.ViewGroup)?.removeView(dockView)
            
            dockView?.setPadding(0, 0, 0, 0)
            dockView?.visibility = View.VISIBLE
            setInputView(dockView)
        }
    }

    
    // =================================================================================
    // FUNCTION: createInputViewWrapper
    // SUMMARY: Creates a wrapper view with specified height, toolbar at bottom.
    //          Uses FrameLayout with overridden onMeasure to strictly enforce height.
    // =================================================================================
    private fun createInputViewWrapper(totalHeight: Int): View {
        val density = resources.displayMetrics.density
        val toolbarHeight = (40 * density).toInt()
        
        // Safety: Ensure total height is at least toolbar height
        val safeTotalHeight = totalHeight.coerceAtLeast(toolbarHeight)
        
        // 1. Create FrameLayout Container with Enforced Height
        // We override onMeasure to guarantee the IME service respects this size
        val container = object : android.widget.FrameLayout(this) {
            override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
                val heightSpec = View.MeasureSpec.makeMeasureSpec(safeTotalHeight, View.MeasureSpec.EXACTLY)
                super.onMeasure(widthMeasureSpec, heightSpec)
            }
        }
        
        // Force layout params
        container.layoutParams = android.view.ViewGroup.LayoutParams(
            android.view.ViewGroup.LayoutParams.MATCH_PARENT,
            safeTotalHeight
        )
        container.setBackgroundColor(android.graphics.Color.TRANSPARENT)

        // 2. Prepare Dock View
        (dockView?.parent as? android.view.ViewGroup)?.removeView(dockView)
        dockView?.setPadding(0, 0, 0, 0)
        dockView?.visibility = View.VISIBLE
        
        // 3. Add Dock to Bottom
        val dockParams = android.widget.FrameLayout.LayoutParams(
            android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
            toolbarHeight
        )
        dockParams.gravity = android.view.Gravity.BOTTOM
        container.addView(dockView, dockParams)
        
        return container
    }
    // =================================================================================
    // END BLOCK: updateInputViewHeight
    // =================================================================================

    // Helper: Send key with meta state
    private fun sendKeyEventWithMeta(ic: InputConnection, keyCode: Int, metaState: Int) {





        val eventTime = SystemClock.uptimeMillis()
        val downEvent = KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, keyCode, 0, metaState, 0, 0, KeyEvent.FLAG_SOFT_KEYBOARD or KeyEvent.FLAG_KEEP_TOUCH_MODE, android.view.InputDevice.SOURCE_KEYBOARD)
        val upEvent = KeyEvent(eventTime, eventTime, KeyEvent.ACTION_UP, keyCode, 0, metaState, 0, 0, KeyEvent.FLAG_SOFT_KEYBOARD or KeyEvent.FLAG_KEEP_TOUCH_MODE, android.view.InputDevice.SOURCE_KEYBOARD)
        ic.sendKeyEvent(downEvent)
        ic.sendKeyEvent(upEvent)
    }

    // [FIX] Force the system to resize the app behind the keyboard
    override fun onComputeInsets(outInsets: InputMethodService.Insets) {
        super.onComputeInsets(outInsets)
        if (isInputViewShown && dockView != null) {
            // contentTopInsets = 0 relative to the input view tells the system that
            // the entire height of our view (including transparent spacer) is non-overlappable.
            // This forces the app to resize (adjustResize) to fit in the remaining space above.
            outInsets.contentTopInsets = 0
            outInsets.visibleTopInsets = 0
            outInsets.touchableInsets = InputMethodService.Insets.TOUCHABLE_INSETS_CONTENT
        }
    }

    // [FIX] Prevent full-screen extraction mode (landscape/small screen)
    // We always want to behave as a docked bar.
    override fun onEvaluateFullscreenMode(): Boolean {
        return false
    }

    // Ensure we keep the connection active
    override fun onEvaluateInputViewShown(): Boolean {
        return true
    }
}
```

## File: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/OverlayService.kt
```kotlin
package com.example.coverscreentester

import android.accessibilityservice.AccessibilityService
import android.app.Notification
import android.media.AudioManager
import android.media.AudioRecordingConfiguration
import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.BroadcastReceiver
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.ServiceConnection
import android.content.pm.ServiceInfo
import androidx.core.content.ContextCompat
import android.graphics.Color
import android.graphics.PixelFormat
import android.graphics.drawable.GradientDrawable
import android.hardware.display.DisplayManager
import android.hardware.input.InputManager
import android.os.Build
import android.os.Handler
import android.os.IBinder
import android.os.Looper
import android.os.Process
import android.os.SystemClock
import android.os.VibrationEffect
import android.os.Vibrator
import android.util.Log
import android.view.Display
import android.view.GestureDetector
import android.view.Gravity
import android.view.InputDevice
import android.view.KeyEvent
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.WindowManager
import android.view.accessibility.AccessibilityNodeInfo
import android.view.accessibility.AccessibilityEvent
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import android.view.VelocityTracker
import kotlin.math.abs
import kotlin.math.hypot
import kotlin.math.max
import kotlin.math.min
import android.os.PowerManager
import java.util.ArrayList
import com.example.coverscreentester.BuildConfig

class OverlayService : AccessibilityService(), DisplayManager.DisplayListener, InputManager.InputDeviceListener {


    private var isAccessibilityReady = false
    private var pendingDisplayId = -1
    // Track last time we injected text to distinguish our events from user touches
    private var lastInjectionTime = 0L


    // === RECEIVER & ACTIONS - START ===
    private val commandReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            val action = intent?.action ?: return
            
            // Helper to match both OLD and NEW package names
            fun matches(cmd: String): Boolean {
                return action.endsWith(cmd)
            }

            if (matches("SOFT_RESTART")) {
                Log.d("OverlayService", "Received SOFT_RESTART")
                performSoftRestart()
            } else if (matches("ENFORCE_ZORDER")) {
                Log.d("OverlayService", "Received ENFORCE_ZORDER")
                enforceZOrder()
            } else if (matches("MOVE_TO_DISPLAY")) {
                val targetId = intent.getIntExtra("displayId", 0)
                Log.d("OverlayService", "Moving to Display: $targetId")
                handler.post {
                    removeOldViews()
                    setupUI(targetId)
                    enforceZOrder()
                }
            } else if (matches("TOGGLE_MIRROR") || matches("TOGGLE_VIRTUAL_MIRROR")) {
                Log.d("OverlayService", "Toggling Mirror Mode")
                handler.post { toggleVirtualMirrorMode() }
            } else if (matches("OPEN_DRAWER")) {
                Log.d("OverlayService", "Opening Drawer")
                handler.post { toggleDrawer() }
            } else if (matches("STOP_SERVICE")) {
                Log.d("OverlayService", "Stopping Service")
                forceExit()
            } else if (matches("SET_INPUT_CAPTURE")) {
                val capture = intent.getBooleanExtra("CAPTURE", false)
                Log.d("OverlayService", "Input Capture Set: $capture")
                keyboardOverlay?.setInputCaptureMode(capture)
} else if (matches("SET_CUSTOM_MOD")) {
                val keyCode = intent.getIntExtra("KEYCODE", 0)
                Log.d("OverlayService", "Custom Mod Key Set: $keyCode")
                prefs.customModKey = keyCode // Save to prefs
                keyboardOverlay?.setCustomModKey(keyCode)
            } else if (matches("SET_NUM_LAYER")) {
                val active = intent.getBooleanExtra("ACTIVE", false)
                keyboardOverlay?.setNumberLayerOverride(active)
            // =================================================================================
            // HANDLER: UPDATE_KEYBINDS
            // SUMMARY: Receives the list of registered keybinds from DroidOS Launcher.
            //          Updates launcherBlockedShortcuts set and syncs to KeyboardOverlay.
            //          Format: ArrayList of "modifier|keyCode" strings
            // =================================================================================
            } else if (matches("UPDATE_KEYBINDS")) {
                val keybinds = intent.getStringArrayListExtra("KEYBINDS")
                Log.d("OverlayService", "Received UPDATE_KEYBINDS: ${keybinds?.size ?: 0} keybinds")
                if (keybinds != null) {
                    launcherBlockedShortcuts.clear()
                    launcherBlockedShortcuts.addAll(keybinds)
                    // Sync to KeyboardOverlay/KeyboardView
                    keyboardOverlay?.setLauncherBlockedShortcuts(launcherBlockedShortcuts)
                    Log.d("OverlayService", "Blocked shortcuts updated: $launcherBlockedShortcuts")
                }
            // =================================================================================
            // END HANDLER: UPDATE_KEYBINDS
            // =================================================================================
            }
        }
    }

    private fun performSoftRestart() {
        // [FIX] HARD RESET (Process Kill)
        // This is the ONLY method that fixes Z-order relative to the Launcher.
        // We rely on the updated scheduleRestart() (Activity Launch) to bring the app back alive.
        handler.post {
            Toast.makeText(this, "Restarting System...", Toast.LENGTH_SHORT).show()
            
            // 1. Schedule the wake-up alarm
            scheduleRestart()
            
            // 2. Kill the process after a short delay
            handler.postDelayed({
                // Always Restart for Soft Restart command (Ignore preference)
                removeOldViews()
                killProcessAndExit()
            }, 500)
        }
    }

    // =================================================================================
    // FUNCTION: requestKeybindsFromLauncher
    // SUMMARY: Sends a broadcast to the DroidOS Launcher requesting the current list
    //          of registered keybinds. The Launcher will respond with UPDATE_KEYBINDS.
    // =================================================================================
    private fun requestKeybindsFromLauncher() {
        val intent = Intent("com.katsuyamaki.DroidOSLauncher.REQUEST_KEYBINDS")
        intent.setPackage("com.katsuyamaki.DroidOSLauncher")
        sendBroadcast(intent)
        Log.d("OverlayService", "Requested keybinds from Launcher")
    }
    // =================================================================================
    // END FUNCTION: requestKeybindsFromLauncher
    // =================================================================================

    fun enforceZOrder() {
        try {
            if (windowManager != null) {
                // LAYER 1: TRACKPAD (Base Layer)
                // Remove and Re-add to ensure it is on top of OTHER apps (like Launcher),
                // but we will stack our own Keyboard on top of this shortly.
                if (trackpadLayout != null && trackpadLayout?.isAttachedToWindow == true) {
                    try {
                        windowManager?.removeView(trackpadLayout)
                        windowManager?.addView(trackpadLayout, trackpadParams)
                    } catch(e: Exception) {
                        try { windowManager?.updateViewLayout(trackpadLayout, trackpadParams) } catch(z: Exception) {}
                    }
                }

                // LAYER 2: KEYBOARD (Middle Layer)
                // [FIX] Explicitly bring Keyboard to front so it sits ON TOP of the Trackpad
                if (keyboardOverlay != null && keyboardOverlay?.isShowing() == true) {
                     keyboardOverlay?.bringToFront()
                }

                // LAYER 3: MENU
                if (menuManager != null) {
                    try { menuManager?.bringToFront() } catch(e: Exception) {}
                }

                // LAYER 4: BUBBLE
                if (bubbleView != null && bubbleView?.isAttachedToWindow == true) {
                    try {
                        windowManager?.removeView(bubbleView)
                        windowManager?.addView(bubbleView, bubbleParams)
                    } catch (e: Exception) {
                         try { windowManager?.updateViewLayout(bubbleView, bubbleParams) } catch(z: Exception) {}
                    }
                }

                // LAYER 5: CURSOR (Visual Layer)
                if (cursorLayout != null && cursorLayout?.isAttachedToWindow == true) {
                    try {
                        windowManager?.removeView(cursorLayout)
                        windowManager?.addView(cursorLayout, cursorParams)
                    } catch (e: Exception) {
                        try { windowManager?.addView(cursorLayout, cursorParams) } catch(z: Exception) {}
                    }
                }

                // LAYER 6: BT MOUSE CAPTURE (Input Interception Layer)
                // [FIX] Must be ABSOLUTE TOP to intercept mouse events before any other window.
                // We forward finger touches down to siblings via forwardTouchToSiblings().
                if (isBtMouseCaptureActive && btMouseCaptureLayout != null && btMouseCaptureLayout?.isAttachedToWindow == true) {
                    try {
                        windowManager?.removeView(btMouseCaptureLayout)
                        windowManager?.addView(btMouseCaptureLayout, btMouseCaptureParams)
                        Log.d(BT_TAG, "Z-Order: BT Capture Overlay moved to TOP")
                    } catch (e: Exception) {
                        Log.e(BT_TAG, "Z-Order: Failed to move BT Capture", e)
                    }
                }
                
                Log.d("OverlayService", "Z-Order Enforced: Trackpad -> Keyboard -> Cursor -> BT Capture")
            }
        } catch (e: Exception) {
            Log.e("OverlayService", "Z-Order failed", e)
        }
    }


    // === RECEIVER & ACTIONS - END ===

    private val TAG = "OverlayService"

    var windowManager: WindowManager? = null
    var displayManager: DisplayManager? = null
    var shellService: IShellService? = null
    private var appWindowManager: WindowManager? = null
    private var isBound = false
    private val handler = Handler(Looper.getMainLooper())

    // Create a single worker queue for all input events to prevent race conditions
    private val inputExecutor = java.util.concurrent.Executors.newSingleThreadExecutor()

    private var lastBlockTime: Long = 0

    // =================================================================================
    // VIRTUAL DISPLAY KEEP-ALIVE SYSTEM
    // SUMMARY: Prevents system from timing out the display when using trackpad on a
    //          remote/virtual display. The overlay consumes touch events so the system
    //          doesn't see "real" user activity. We solve this by:
    //          1. Holding a SCREEN_BRIGHT_WAKE_LOCK when targeting remote display
    //          2. Periodically calling userActivity() via shell during active touch
    // =================================================================================
    private var powerManager: PowerManager? = null
    private var displayWakeLock: PowerManager.WakeLock? = null
    private var lastUserActivityPing: Long = 0
    private val USER_ACTIVITY_PING_INTERVAL_MS = 30_000L // Ping every 30 seconds during active use
    // =================================================================================
    // END BLOCK: VIRTUAL DISPLAY KEEP-ALIVE SYSTEM VARIABLES
    // =================================================================================

    private var bubbleView: View? = null
    private var trackpadLayout: FrameLayout? = null
    private var cursorLayout: FrameLayout? = null
    private var cursorView: ImageView? = null
    
    private lateinit var bubbleParams: WindowManager.LayoutParams
    private lateinit var trackpadParams: WindowManager.LayoutParams
    private lateinit var cursorParams: WindowManager.LayoutParams

    private var menuManager: TrackpadMenuManager? = null
    private var savedKbX = 0
    private var savedKbY = 0
    private var savedKbW = 0
    private var savedKbH = 0
    private var keyboardOverlay: KeyboardOverlay? = null

    var currentDisplayId = 0
    var inputTargetDisplayId = 0
    var isTrackpadVisible = false // Changed: Default OFF
    var isCustomKeyboardVisible = true // Changed: Default ON
    var isScreenOff = false
    private var isPreviewMode = false
    private var previousImeId: String? = null
    
    // --- SMART RESTORE STATE ---
    private var pendingRestoreTrackpad = false
    private var pendingRestoreKeyboard = false
    private var hasPendingRestore = false

    // =================================================================================
    // VIRTUAL MIRROR MODE STATE
    // SUMMARY: Tracks component visibility before entering mirror mode so we can
    //          restore to previous state when exiting. Also stores the display ID
    //          we were targeting before mirror mode was enabled.
    // =================================================================================
    private var preMirrorTrackpadVisible = false
    private var preMirrorKeyboardVisible = false
    private var preMirrorTargetDisplayId = 0
    // =================================================================================
    // END BLOCK: VIRTUAL MIRROR MODE STATE
    // =================================================================================

    private var isVoiceActive = false
    
    
    
    // Heartbeat to keep hardware state alive AND enforce settings
    private val blockingHeartbeat = object : Runnable {
        override fun run() {
            // No-op: Null Keyboard handles blocking natively
        }
    }
    
    class Prefs {
        var cursorSpeed = 2.5f
        var scrollSpeed = 1.0f 
        var prefTapScroll = true 
        var prefVibrate = false
        var prefReverseScroll = true
        var prefAlpha = 200
        var prefBgAlpha = 0
        var prefKeyboardAlpha = 200
        var prefHandleSize = 60 
        var prefVPosLeft = false
        var prefHPosTop = false
        var prefLocked = false
        var prefHandleTouchSize = 80
        var prefScrollTouchSize = 80 
        var prefScrollVisualSize = 4
        var prefCursorSize = 50 
        var prefKeyScale = 69 // Default to 69% to match Reset Position (0.55 ratio)
        var prefUseAltScreenOff = true
        var prefAutomationEnabled = true
        var prefBubbleX = 50
        var prefBubbleY = 300
        var prefAnchored = false 
        var prefBubbleSize = 100        
        var prefBubbleIconIndex = 0     
        var prefBubbleAlpha = 255       
        var prefPersistentService = false 

        var prefBlockSoftKeyboard = false

        // =================================================================================
        // PREDICTION AGGRESSION (Precision vs Shape)
        // 0.3 (Sloppy/Fast) to 2.0 (Neat/Precise). Default 0.8.
        // =================================================================================
        var prefPredictionAggression = 0.8f
    
    // =================================================================================
    // SPACEBAR MOUSE EXTENDED MODE PREFERENCE
    // SUMMARY: When enabled, spacebar mouse mode stays active indefinitely (no 1-second
    //          timeout). Mode only deactivates when user taps outside the keyboard overlay.
    //          This allows continuous cursor control without repeatedly activating.
    // =================================================================================
    var prefSpacebarMouseExtended = false
    // =================================================================================
    // END BLOCK: SPACEBAR MOUSE EXTENDED MODE PREFERENCE
    // =================================================================================
        var prefAlwaysPreferGboard = true  // NEW: Fight Samsung's keyboard takeover
        
        // Defaults set to "none" (System Default)

        var hardkeyVolUpTap = "none"
        var hardkeyVolUpDouble = "none"
        var hardkeyVolUpHold = "none"
        var hardkeyVolDownTap = "none"
        var hardkeyVolDownDouble = "none"
        var hardkeyVolDownHold = "none"
        var hardkeyPowerDouble = "none"
        var doubleTapMs = 300
        var holdDurationMs = 400
        var displayOffMode = "alternate"

        // =================================================================================
        // VIRTUAL MIRROR MODE PREFERENCES
        // SUMMARY: Settings for displaying a mirror keyboard on remote/AR display.
        //          When enabled, touching the physical keyboard shows an orange orientation
        //          trail on both displays. After finger stops for orientDelayMs, normal
        //          keyboard input resumes.
        // =================================================================================
        var prefVirtualMirrorMode = false
        var prefMirrorOrientDelayMs = 1000L  // Default 1 second orientation delay
        
        // Mirror Keyboard Prefs
        var prefMirrorAlpha = 200
        var prefMirrorX = -1      // -1 = auto center
        var prefMirrorY = 0
        var prefMirrorWidth = -1  // -1 = auto
        var prefMirrorHeight = -1 // -1 = auto

        // NEW: Toggle to block system meta shortcuts (e.g. Meta+S -> Messages)
        var prefOverrideSystemShortcuts = true
        var customModKey = 0 // To persist across view rebuilds

        // =================================================================================
        // END BLOCK: VIRTUAL MIRROR MODE PREFERENCES
        // =================================================================================
    }
    val prefs = Prefs()

    // =================================================================================
    // LAUNCHER BLOCKED SHORTCUTS SET
    // SUMMARY: Contains the set of shortcuts registered in the DroidOS Launcher.
    //          Format: "modifier|keyCode" (e.g., "4096|47" for Meta+S)
    //          Only shortcuts in this set should be blocked when overrideSystemShortcuts is true.
    //          Received via UPDATE_KEYBINDS broadcast from Launcher.
    // =================================================================================
    private val launcherBlockedShortcuts = mutableSetOf<String>()
    // =================================================================================
    // END BLOCK: LAUNCHER BLOCKED SHORTCUTS SET
    // =================================================================================

    // =========================
    // KEY INJECTION
    // =========================
    private fun injectKey(keyCode: Int, action: Int = KeyEvent.ACTION_DOWN, metaState: Int = 0) {
        // Dynamic Device ID:
        // Blocking ON: Use 1 (Physical) to maintain "Hardware Keyboard" state.
        // Blocking OFF: Use -1 (Virtual). ID 0 is often ignored by Gboard. -1 is standard software injection.
        val deviceId = if (prefs.prefBlockSoftKeyboard) 1 else -1
        shellService?.injectKey(keyCode, action, metaState, inputTargetDisplayId, deviceId)
    }

    // =========================
    // BLOCKING TRIGGER (Global)
    // =========================

// FILE: Cover-Screen-Trackpad/app/src/main/java/com/example/coverscreentester/OverlayService.kt
// LOC: Around line 1550 (Search for 'fun triggerAggressiveBlocking')

// =================================================================================
// FUNCTION: triggerAggressiveBlocking
// SUMMARY: Enforces Soft Keyboard blocking. ONLY works on Cover Screen (display 1).
//          Does nothing on main screen (0) or virtual displays (2+).
// =================================================================================
    private fun triggerAggressiveBlocking() {
        // GUARD: Only block keyboard on Cover Screen (display 1)
        if (currentDisplayId != 1) {
            android.util.Log.d(TAG, "triggerAggressiveBlocking: Skipping - not on cover screen (display $currentDisplayId)")
            return
        }

        // Rely on standard Android API to suppress keyboard
        if (Build.VERSION.SDK_INT >= 24) {
            try {
                if (softKeyboardController.showMode != AccessibilityService.SHOW_MODE_HIDDEN) {
                    softKeyboardController.showMode = AccessibilityService.SHOW_MODE_HIDDEN
                }
            } catch (e: Exception) {
                // Controller might not be connected yet
            }
        }
    }
// =================================================================================
// END FUNCTION: triggerAggressiveBlocking
// =================================================================================







    // =================================================================================
    // SYNCHRONIZATION: Prevent multiple keyboard restoration threads
    // =================================================================================
    @Volatile private var isKeyboardRestoreInProgress = false
    // =================================================================================
    // END BLOCK: Keyboard restoration synchronization flag
    // =================================================================================
    
    private fun setSoftKeyboardBlocking(enabled: Boolean) {
        if (shellService == null) return
        
        // =================================================================================
        // GUARD: Keyboard blocking ONLY works on Cover Screen (display 1)
        // On main screen (0) or virtual displays (2+), blocking is disabled/skipped.
        // =================================================================================
        if (enabled && currentDisplayId != 1) {
            android.util.Log.w(TAG, "setSoftKeyboardBlocking: Blocking only works on cover screen (display 1), current=$currentDisplayId - skipping")
            return
        }
        // =================================================================================
        
        // GUARD: Prevent concurrent restoration attempts
        if (!enabled && isKeyboardRestoreInProgress) {
            android.util.Log.w(TAG, "setSoftKeyboardBlocking: Already restoring, skipping duplicate call")
            return
        }

        Thread {
            try {
                // 1. Find correct ID for OUR Input Dock
                val allImes = shellService?.runCommand("ime list -a -s") ?: ""
                val myImeId = allImes.lines().firstOrNull { 
                    it.contains(packageName) && (it.contains("DockInputMethodService") || it.contains("NullInputMethodService")) 
                }?.trim()

                if (myImeId.isNullOrEmpty()) {
                    handler.post { showToast("Error: DroidOS Keyboard not found.") }
                    return@Thread
                }


                if (enabled) {
                    // --- BLOCKING ---
                    shellService?.runCommand("ime enable $myImeId")
                    shellService?.runCommand("ime set $myImeId")
                    shellService?.runCommand("settings put secure show_ime_with_hard_keyboard 0")
                    
                    handler.post { showToast("Keyboard Blocked (Cover Screen)") }


                    
                } else {
                    // =================================================================================
                    // UNBLOCKING / KEYBOARD RESTORATION - SAMSUNG ONEUI WORKAROUND
                    // =================================================================================
                    // PROBLEM: Samsung OneUI aggressively forces HoneyBoard (Samsung Keyboard) back
                    //          within ~300ms of ANY ime set command during phone unfold.
                    //          Our commands succeed ("Gboard selected") but Samsung immediately
                    //          overwrites the setting.
                    //
                    // SOLUTION: Temporarily DISABLE Samsung Keyboard, set Gboard, then re-enable.
                    //           Samsung can't force a disabled keyboard as the default.
                    // =================================================================================
                    
                    // Set synchronization flag
                    isKeyboardRestoreInProgress = true
                    
                    android.util.Log.w(TAG, "")
                    android.util.Log.w(TAG, " KEYBOARD RESTORATION - SAMSUNG WORKAROUND               ")
                    android.util.Log.w(TAG, "")
                    
                    try {
                        // STEP 1: Get current state
                        val initialIme = shellService?.runCommand("settings get secure default_input_method")?.trim() ?: ""
                        android.util.Log.w(TAG, " Initial IME: $initialIme")
                        
                        // STEP 2: Get saved preference
                        val sharedPrefs = getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
                        var targetIme = sharedPrefs.getString("user_preferred_ime", null)
                        android.util.Log.w(TAG, " Saved preference: ${targetIme ?: "NULL"}")
                        
                        // =================================================================================
                        // NULLKEYBOARD PREFERENCE CHECK
                        // If user's preference IS NullKeyboard, don't restore away from it
                        // =================================================================================
                        if (targetIme != null && targetIme.contains("NullInputMethodService")) {
                            android.util.Log.w(TAG, " User preference is NullKB - not restoring away from it")
                            isKeyboardRestoreInProgress = false
                            android.util.Log.w(TAG, " KEYBOARD RESTORATION SKIPPED (NullKB is preference)")
                            return@Thread
                        }
                        // =================================================================================
                        // END BLOCK: NULLKEYBOARD PREFERENCE CHECK
                        // =================================================================================
                        
                        // STEP 3: Get enabled IMEs and find Gboard
                        val enabledImes = shellService?.runCommand("ime list -s") ?: ""
                        val gboardId = enabledImes.lines().find { 
                            it.contains("com.google.android.inputmethod.latin") 
                        }?.trim()
                        val samsungId = enabledImes.lines().find { 
                            it.contains("honeyboard") || it.contains("com.sec.android.inputmethod") 
                        }?.trim()
                        
                        android.util.Log.w(TAG, " Gboard ID: ${gboardId ?: "NOT FOUND"}")
                        android.util.Log.w(TAG, " Samsung ID: ${samsungId ?: "NOT FOUND"}")
                        
                        // Prefer Gboard, fallback to saved, then to any non-Samsung
                        if (targetIme.isNullOrEmpty() || targetIme.contains("honeyboard") || targetIme.contains("com.sec")) {
                            targetIme = gboardId
                        }
                        
                        if (targetIme.isNullOrEmpty()) {
                            android.util.Log.e(TAG, " ERROR: No target keyboard found!")
                            handler.post { showToast("No keyboard to restore") }
                            isKeyboardRestoreInProgress = false
                            return@Thread
                        }
                        
                        android.util.Log.w(TAG, " Target IME: $targetIme")
                        
                        // STEP 4: THE SAMSUNG WORKAROUND
                        // Temporarily disable Samsung Keyboard so it CAN'T be forced back
                        if (!samsungId.isNullOrEmpty() && initialIme.contains("honeyboard")) {
                            android.util.Log.w(TAG, " WORKAROUND: Temporarily disabling Samsung Keyboard...")
                            
                            // 4a. Disable Samsung Keyboard
                            val disableResult = shellService?.runCommand("ime disable $samsungId")
                            android.util.Log.w(TAG, "   Disable result: ${disableResult ?: "null"}")
                            
                            // 4b. Small delay for system to process
                            Thread.sleep(100)
                            
                            // 4c. Now set Gboard (Samsung can't override because it's disabled)
                            shellService?.runCommand("ime enable $targetIme")
                            shellService?.runCommand("settings put secure default_input_method $targetIme")
                            val setResult = shellService?.runCommand("ime set $targetIme")
                            android.util.Log.w(TAG, "   Set Gboard result: ${setResult ?: "null"}")
                            
                            // 4d. Wait for it to stick
                            Thread.sleep(500)
                            
                            // 4e. Verify
                            val afterSet = shellService?.runCommand("settings get secure default_input_method")?.trim() ?: ""
                            android.util.Log.w(TAG, "   After set: $afterSet")
                            
                            // 4f. Re-enable Samsung (user might want to use it later)
                            android.util.Log.w(TAG, "   Re-enabling Samsung Keyboard...")
                            shellService?.runCommand("ime enable $samsungId")
                            
                            // 4g. Final verification after re-enable
                            Thread.sleep(300)
                            val finalIme = shellService?.runCommand("settings get secure default_input_method")?.trim() ?: ""
                            android.util.Log.w(TAG, " FINAL IME: $finalIme")
                            
                            val success = finalIme == targetIme || finalIme.contains("google.android.inputmethod.latin")
                            android.util.Log.w(TAG, " SUCCESS: $success")
                            
                            if (success) {
                                handler.post { showToast("Keyboard Restored") }
                            } else {
                                // NUCLEAR OPTION: Keep Samsung disabled longer
                                android.util.Log.w(TAG, " First attempt failed, trying nuclear option...")
                                
                                // Disable Samsung again
                                shellService?.runCommand("ime disable $samsungId")
                                Thread.sleep(200)
                                
                                // Force set again
                                shellService?.runCommand("settings put secure default_input_method $targetIme")
                                shellService?.runCommand("ime set $targetIme")
                                
                                // Keep Samsung disabled for 3 seconds (past Samsung's protection window)
                                Thread.sleep(3000)
                                
                                // Check again
                                val nuclearCheck = shellService?.runCommand("settings get secure default_input_method")?.trim() ?: ""
                                android.util.Log.w(TAG, " After nuclear: $nuclearCheck")
                                
                                // Re-enable Samsung
                                shellService?.runCommand("ime enable $samsungId")
                                
                                // Final check
                                Thread.sleep(500)
                                val nuclearFinal = shellService?.runCommand("settings get secure default_input_method")?.trim() ?: ""
                                android.util.Log.w(TAG, " Nuclear final: $nuclearFinal")
                                
                                if (nuclearFinal.contains("google.android.inputmethod.latin")) {
                                    handler.post { showToast("Keyboard Restored (retry)") }
                                } else {
                                    android.util.Log.e(TAG, " NUCLEAR FAILED")
                                    handler.post { showToast("Keyboard restore failed") }
                                }
                            }
                            
                        } else {
                            // Samsung not active, use simple approach
                            android.util.Log.w(TAG, " Simple restore (Samsung not active)...")
                            shellService?.runCommand("ime enable $targetIme")
                            shellService?.runCommand("settings put secure default_input_method $targetIme")
                            shellService?.runCommand("ime set $targetIme")
                            
                            Thread.sleep(300)
                            val finalIme = shellService?.runCommand("settings get secure default_input_method")?.trim() ?: ""
                            android.util.Log.w(TAG, " FINAL IME: $finalIme")
                            
                            val success = finalIme == targetIme
                            if (success) {
                                handler.post { showToast("Keyboard Restored") }
                            } else {
                                handler.post { showToast("Keyboard restore failed") }
                            }
                        }
                        
                    } catch (e: Exception) {
                        android.util.Log.e(TAG, " EXCEPTION: ${e.message}", e)
                        handler.post { showToast("Restore error: ${e.message}") }
                    }
                    
                    // Clear synchronization flag
                    isKeyboardRestoreInProgress = false
                    android.util.Log.w(TAG, " KEYBOARD RESTORATION COMPLETE")
                    // =================================================================================
                    // END BLOCK: KEYBOARD RESTORATION - SAMSUNG WORKAROUND
                    // =================================================================================
                }
            } catch (e: Exception) {
                handler.post { showToast("Error: ${e.message}") }
            }
        }.start()
    }








    // =================================================================================
    // KEYBOARD RESTORATION HELPERS
    // =================================================================================
    private var lastMainCheck = 0L
    private var lastCoverCheck = 0L

    // =================================================================================
    // FUNCTION: ensureSystemKeyboardRestored
    // SUMMARY: Called when on Main Screen with blocking ENABLED. Restores user's
    //          preferred keyboard FROM NullKeyboard. But if NullKeyboard IS the user's
    //          saved preference (blocking OFF scenario), we don't restore away from it.
    // =================================================================================
    private fun ensureSystemKeyboardRestored() {
        // Throttle: Check max once every 2 seconds
        if (System.currentTimeMillis() - lastMainCheck < 2000) return
        lastMainCheck = System.currentTimeMillis()

        Thread {
            try {
                // Check if Null Keyboard is currently active
                val current = shellService?.runCommand("settings get secure default_input_method") ?: ""
                if (current.contains(packageName) && current.contains("NullInputMethodService")) {
                    
                    // NEW: Check if Input Dock is the user's PREFERRED keyboard
                    val savedPref = getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
                        .getString("user_preferred_ime", null)
                    
                    if (savedPref != null && (savedPref.contains("DockInputMethodService") || savedPref.contains("NullInputMethodService"))) {
                        // User wants Dock - don't restore away from it
                        android.util.Log.d(TAG, "ensureSystemKeyboardRestored: Dock is user preference, keeping it")
                        return@Thread
                    }

                    
                    android.util.Log.i(TAG, "Main Screen Detected: Restoring System Keyboard...")
                    handler.post { setSoftKeyboardBlocking(false) }
                }
            } catch(e: Exception) {}
        }.start()
    }
    // =================================================================================
    // END BLOCK: ensureSystemKeyboardRestored
    // =================================================================================



    private fun ensureKeyboardBlocked() {
        // =================================================================================
        // GUARD: Only enforce blocking on Cover Screen (display 1)
        // =================================================================================
        if (currentDisplayId != 1) return
        
        // Throttle: Check max once every 2 seconds
        if (System.currentTimeMillis() - lastCoverCheck < 2000) return
        lastCoverCheck = System.currentTimeMillis()

        Thread {
            try {
                // Check if Null Keyboard is NOT active
                val current = shellService?.runCommand("settings get secure default_input_method") ?: ""
                if (!current.contains("NullInputMethodService") && !current.contains("DockInputMethodService")) {
                    android.util.Log.i(TAG, "Cover Screen (D1): Enforcing DroidOS Keyboard...")
                    handler.post { setSoftKeyboardBlocking(true) }
                }
            } catch(e: Exception) {}
        }.start()
    }



    // =================================================================================
    // FUNCTION: ensureCoverKeyboardEnforced (GBOARD GUARDIAN)
    // SUMMARY: When DroidOS blocking is OFF, ensure user's preferred keyboard stays active.
    //          This fights Samsung's forced keyboard takeover.
    //          FIXED: If NullKeyboard is currently active, do NOT try to change it.
    //          The user may have intentionally set NullKeyboard as their default.
    // =================================================================================
    private fun ensureCoverKeyboardEnforced() {
        // Throttle: Check max once every 2 seconds to save battery
        if (System.currentTimeMillis() - lastCoverCheck < 2000) return
        lastCoverCheck = System.currentTimeMillis()

        Thread {
            try {
                // 1. Check what is currently active
                val current = shellService?.runCommand("settings get secure default_input_method")?.trim() ?: ""
                
                // 2. If Dock is active, DO NOT interfere
                // User may have intentionally set it as their default keyboard
                if (current.contains("DockInputMethodService") || current.contains("NullInputMethodService")) {
                    android.util.Log.d(TAG, "ensureCoverKeyboardEnforced: Dock active, not interfering")
                    return@Thread
                }
                
                // 3. Get User's Preferred Keyboard
                val sharedPrefs = getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
                val targetIme = sharedPrefs.getString("user_preferred_ime", null) ?: return@Thread
                
                // 4. If target is Dock, don't fight - it should already be handled
                if (targetIme.contains("DockInputMethodService") || targetIme.contains("NullInputMethodService")) {
                    return@Thread
                }

                
                // 5. If current matches target, nothing to do
                if (current == targetIme) {
                    return@Thread
                }
                
                // 6. Only fight if Samsung took over (not if user switched to something else)
                val isSamsung = current.contains("honeyboard") || current.contains("com.sec.android.inputmethod")
                if (isSamsung) {
                    android.util.Log.i(TAG, "ensureCoverKeyboardEnforced: Samsung detected, forcing $targetIme...")
                    handler.post { setSoftKeyboardBlocking(false) }
                }
            } catch(e: Exception) {}
        }.start()
    }
    // =================================================================================
    // END BLOCK: ensureCoverKeyboardEnforced
    // =================================================================================

    // =================================================================================
    // FUNCTION: onAccessibilityEvent
    // SUMMARY: Monitors system events to manage Keyboard Blocking and Mode Switching.
    // UPDATED: Now explicitly UNBLOCKS the keyboard when Main Screen (0) is active.
    // =================================================================================
    override fun onAccessibilityEvent(event: AccessibilityEvent?) {
        if (event == null) return
        
        // [EFFICIENCY] IMMEDIATE FILTER
        // Block high-frequency noise immediately
        if (event.eventType == AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED ||
            event.eventType == AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED || 
            event.eventType == AccessibilityEvent.TYPE_VIEW_SCROLLED) {
            return
        }
        
        // Log.v(TAG, "onAccessibilityEvent: ${event.eventType} pkg=${event.packageName}")

        // [MODIFIED] MAIN SCREEN GUARD REMOVED
        // We now allow blocking logic to run on the Main Screen if configured.


        // [FIX 2] Standard Multi-Display Filter
        // Ignore events from displays we aren't managing (unless it was Main Screen handled above)
        if (event.displayId != currentDisplayId) {
            return
        }

        val eventPkg = event.packageName?.toString() ?: ""

        // [FIX 3] Anti-Loop (Ignore Self)
        if (eventPkg == packageName) return

        // [FIX 4] Allow Voice Input
        if (eventPkg.contains("google.android.googlequicksearchbox") ||
            eventPkg.contains("com.google.android.voicesearch") ||
            eventPkg.contains("com.google.android.tts")) {

            if (prefs.prefBlockSoftKeyboard && shellService != null) {
                 Thread { try { shellService?.runCommand("settings put secure show_ime_with_hard_keyboard 1") } catch(e: Exception){} }.start()
            }
            return
        }
        
        // [FIX] External Cursor Movement Detection
        // If selection changes or user clicks text in the target app, reset swipe history.
        if (event.eventType == AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED || 
            event.eventType == AccessibilityEvent.TYPE_VIEW_CLICKED) {
            
            val timeSinceInjection = System.currentTimeMillis() - lastInjectionTime
            if (timeSinceInjection > 500) {
                keyboardOverlay?.resetSwipeHistory()
            }
        }

        // [FIX 5] Throttle & Execute Blocking (ONLY on Cover Screen - display 1)
        if (event.eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED ||
            event.eventType == AccessibilityEvent.TYPE_VIEW_FOCUSED ||
            event.eventType == AccessibilityEvent.TYPE_WINDOWS_CHANGED) {

            // GUARD: Only run blocking logic on Cover Screen (display 1)
            if (currentDisplayId == 1 && prefs.prefBlockSoftKeyboard && !isVoiceActive) {
                 // CASE A: Cover Screen + Blocking Enabled -> Force Null Keyboard
                 ensureKeyboardBlocked()

                 val currentTime = System.currentTimeMillis()
                 if (currentTime - lastBlockTime > 500) {
                     lastBlockTime = currentTime
                     triggerAggressiveBlocking()
                 }
            } else if (currentDisplayId != 1) {
                 // CASE B: Main/Virtual Display -> Ensure keyboard is NOT blocked
                 if (Build.VERSION.SDK_INT >= 24) {
                     try {
                         if (softKeyboardController.showMode != AccessibilityService.SHOW_MODE_AUTO) {
                             softKeyboardController.showMode = AccessibilityService.SHOW_MODE_AUTO
                         }
                     } catch(e: Exception) {}
                 }
            }
        }


    }

// =================================================================================
// END FUNCTION: onAccessibilityEvent
// =================================================================================


    // =========================
    // STANDARD OVERRIDES
    // =========================
    private var uiScreenWidth = 1080
    private var uiScreenHeight = 2640
    private var targetScreenWidth = 1920
    private var targetScreenHeight = 1080
    private var cursorX = 300f
    private var cursorY = 300f
    private var rotationAngle = 0
    private var lastTouchX = 0f
    private var lastTouchY = 0f
    private var initialTouchX = 0f
    private var initialTouchY = 0f
    private var isTouchDragging = false
    private var isLeftKeyHeld = false
    private var isRightKeyHeld = false
    private var isVScrolling = false
    private var isHScrolling = false
    private var dragDownTime: Long = 0L
    private var hasSentTouchDown = false
    private var hasSentMouseDown = false
    private var activeFingerDeviceId = -1
    private var ignoreTouchSequence = false
    private var isDebugMode = false
    private var isKeyboardMode = false
    private var savedWindowX = 0
    private var savedWindowY = 0
    private var currentBorderColor = 0xFFFFFFFF.toInt()
    private var scrollAccumulatorX = 0f
    private var scrollAccumulatorY = 0f

    private var touchDownTime: Long = 0L
    private var touchDownX: Float = 0f
    private var touchDownY: Float = 0f
    private var isReleaseDebouncing = false
    private val releaseDebounceRunnable = Runnable { isReleaseDebouncing = false }
    
    private val TAP_TIMEOUT_MS = 300L
    private val TAP_SLOP_PX = 15f
    private val RELEASE_DEBOUNCE_MS = 50L

    private var scrollZoneThickness = 80
    private val handleContainers = ArrayList<FrameLayout>()
    private val handleVisuals = ArrayList<View>()
    private var vScrollContainer: FrameLayout? = null
    private var hScrollContainer: FrameLayout? = null
    private var vScrollVisual: View? = null
    private var hScrollVisual: View? = null
    private var debugTextView: TextView? = null

    private var remoteWindowManager: WindowManager? = null
    private var remoteCursorLayout: FrameLayout? = null
    private var remoteCursorView: ImageView? = null
    private lateinit var remoteCursorParams: WindowManager.LayoutParams

    // =================================================================================
    // BT MOUSE CAPTURE OVERLAY VARIABLES
    // SUMMARY: Full-screen transparent overlay that captures all Bluetooth mouse input
    //          when targeting a virtual display. Prevents BT mouse from interacting
    //          with physical screen content and enables proper coordinate scaling.
    // =================================================================================
    private var btMouseCaptureLayout: FrameLayout? = null
    private var btMouseCaptureParams: WindowManager.LayoutParams? = null
    private var isBtMouseCaptureActive = false
    private var lastBtMouseX = 0f
    private var lastBtMouseY = 0f
    private var isBtMouseDragging = false
    private val BT_TAG = "BT_MOUSE_CAPTURE"
    // =================================================================================
    // END BLOCK: BT MOUSE CAPTURE OVERLAY VARIABLES
    // =================================================================================

    // =================================================================================
    // VIRTUAL MIRROR MODE VARIABLES
    // =================================================================================
    private var mirrorWindowManager: WindowManager? = null
    private var mirrorKeyboardContainer: FrameLayout? = null
    private var mirrorKeyboardView: KeyboardView? = null
    private var mirrorTrailView: SwipeTrailView? = null
    private var mirrorKeyboardParams: WindowManager.LayoutParams? = null

    // Dimensions for coordinate scaling between physical and mirror keyboards
    private var physicalKbWidth = 0f
    private var physicalKbHeight = 0f
    private var mirrorKbWidth = 0f
    private var mirrorKbHeight = 0f

    private var isInOrientationMode = false
    private var isMirrorDragActive = false
    private var isHoveringBackspace = false // [FIX] Add this variable
    private var draggedPredictionIndex = -1 // [FIX] Add this missing variable
    private var lastOrientX = 0f
    private var lastOrientY = 0f
    private val MOVEMENT_THRESHOLD = 15f  // Pixels - ignore movement smaller than this
    private var orientationModeHandler = Handler(Looper.getMainLooper())
    private var lastOrientationTouchTime = 0L

    // =================================================================================
    // MIRROR MODE KEY REPEAT VARIABLES
    // SUMMARY: Variables for repeating backspace/arrow keys when held during orange
    //          trail orientation mode. Only active in mirror mode, doesn't affect
    //          normal blue trail swipe typing.
    // =================================================================================
    private val mirrorRepeatHandler = Handler(Looper.getMainLooper())
    private var mirrorRepeatKey: String? = null
    private var isMirrorRepeating = false
    private val MIRROR_REPEAT_INITIAL_DELAY = 400L
    private val MIRROR_REPEAT_INTERVAL = 50L
    
    // Keys that can repeat in mirror orientation mode (backspace + arrows)
    private val mirrorRepeatableKeys = setOf("BKSP", "", "", "", "", "", "", "", "", "")
    

    private val mirrorRepeatRunnable = object : Runnable {
        override fun run() {
            mirrorRepeatKey?.let { key ->
                // FIXED: Removed '&& isInOrientationMode' check.
                // This allows repeat to work in Blue Mode (where isInOrientationMode is false).
                if (isMirrorRepeating) {
                    Log.d(TAG, "Mirror repeat: $key")
                    keyboardOverlay?.triggerKeyPress(key)
                    mirrorRepeatHandler.postDelayed(this, MIRROR_REPEAT_INTERVAL)
                }
            }
        }
    }

    // =================================================================================
    // END BLOCK: MIRROR MODE KEY REPEAT VARIABLES
    // =================================================================================    // =================================================================================
    // RUNNABLE: orientationModeTimeout
    // SUMMARY: Fires when finger has been still for delay period.
    //          Switches from orange trail to blue trail.
    //          Initializes swipe tracking so path collection starts NOW.
    // =================================================================================




    private val orientationModeTimeout = Runnable {
        // DYNAMIC HEIGHT CALCULATION
        val currentHeight = if (physicalKbHeight > 0) physicalKbHeight else 400f
        
        // ADJUSTMENT: Set to 19% (0.19f)
        // 0.23f blocked the top row. 0.17f caused ghost words. 0.19f is the sweet spot.
        val stripHeight = currentHeight * 0.12f

        // Check if finger is currently holding on the Prediction Bar
        if (lastOrientY < stripHeight) {

             // START DRAG MODE (Blue Trail)
             isInOrientationMode = false
             keyboardOverlay?.setOrientationMode(false)
             mirrorTrailView?.clear()
             keyboardOverlay?.clearOrientationTrail()
             
             isMirrorDragActive = true
             
             // Calculate index
             val width = if (physicalKbWidth > 0) physicalKbWidth else 1080f
             val slotWidth = width / 3f
             draggedPredictionIndex = (lastOrientX / slotWidth).toInt().coerceIn(0, 2)

             // START BLUE TRAIL IMMEDIATELY
             mirrorTrailView?.setTrailColor(0xFF4488FF.toInt())
             mirrorTrailView?.addPoint(lastOrientX, lastOrientY)
             
             val now = SystemClock.uptimeMillis()
             val scaleX = if (physicalKbWidth > 0) mirrorKbWidth / physicalKbWidth else 1f
             val scaleY = if (physicalKbHeight > 0) mirrorKbHeight / physicalKbHeight else 1f
             val mx = lastOrientX * scaleX
             val my = lastOrientY * scaleY
             
             val event = MotionEvent.obtain(now, now, MotionEvent.ACTION_DOWN, mx, my, 0)
             mirrorKeyboardView?.dispatchTouchEvent(event)
             event.recycle()
             
             return@Runnable
        }

        // CASE B: Holding on Keys -> START BLUE TRAIL
        isInOrientationMode = false
        mirrorTrailView?.clear()
        keyboardOverlay?.clearOrientationTrail()
        keyboardOverlay?.setOrientationMode(false)
        mirrorTrailView?.setTrailColor(0xFF4488FF.toInt()) 
        keyboardOverlay?.startSwipeFromCurrentPosition(lastOrientX, lastOrientY)

        val scaleX = if (physicalKbWidth > 0) mirrorKbWidth / physicalKbWidth else 1f
        val scaleY = if (physicalKbHeight > 0) mirrorKbHeight / physicalKbHeight else 1f
        mirrorTrailView?.addPoint(lastOrientX * scaleX, lastOrientY * scaleY)
        mirrorKeyboardView?.alpha = 0.7f

        // Immediate Repeat Check
        val currentKey = keyboardOverlay?.getKeyAtPosition(lastOrientX, lastOrientY)
        if (currentKey != null && mirrorRepeatableKeys.contains(currentKey)) {
            mirrorRepeatKey = currentKey
            isMirrorRepeating = true
            keyboardOverlay?.triggerKeyPress(currentKey)
            mirrorRepeatHandler.postDelayed(mirrorRepeatRunnable, MIRROR_REPEAT_INTERVAL)
        }
    }



    // =================================================================================
    // END BLOCK: orientationModeTimeout
    // =================================================================================

    // =================================================================================
    // MIRROR FADE OUT HANDLER
    // SUMMARY: Fades the mirror keyboard to fully transparent after inactivity.
    // =================================================================================
    private val mirrorFadeHandler = Handler(Looper.getMainLooper())
    private val mirrorFadeRunnable = Runnable {
        mirrorKeyboardView?.animate()?.alpha(0f)?.setDuration(300)?.start()
        mirrorKeyboardContainer?.animate()?.alpha(0f)?.setDuration(300)?.start()
    }
    // =================================================================================
    // END BLOCK: MIRROR FADE OUT HANDLER
    // =================================================================================
    // =================================================================================
    // END BLOCK: VIRTUAL MIRROR MODE VARIABLES
    // =================================================================================

    private val longPressRunnable = Runnable { startTouchDrag() }
    private val clearHighlightsRunnable = Runnable { updateBorderColor(currentBorderColor); updateLayoutSizes() }
    
    private var isKeyDragging = false
    private var activeDragButton = MotionEvent.BUTTON_PRIMARY
    
    private var lastVolUpTime: Long = 0L
    private var lastVolDownTime: Long = 0L
    // HARDKEY STATE TRACKING
    private var volUpTapCount = 0
    private var volDownTapCount = 0
    private var volUpHoldTriggered = false
    private var volDownHoldTriggered = false
    private var volUpDragActive = false
    private var volDownDragActive = false
    private var lastManualSwitchTime: Long = 0L

    private val volUpHoldRunnable = Runnable {
        volUpHoldTriggered = true
        executeHardkeyAction(prefs.hardkeyVolUpHold, KeyEvent.ACTION_DOWN)
    }

    private val volDownHoldRunnable = Runnable {
        volDownHoldTriggered = true
        executeHardkeyAction(prefs.hardkeyVolDownHold, KeyEvent.ACTION_DOWN)
    }

    private val volUpDoubleTapRunnable = Runnable {
        // [FIX] Check count to determine action
        // If count > 2, user is spamming keys (Panic?), so don't fire normal actions
        if (volUpTapCount == 1) {
            executeHardkeyAction(prefs.hardkeyVolUpTap, KeyEvent.ACTION_UP)
        } else if (volUpTapCount == 2) {
            executeHardkeyAction(prefs.hardkeyVolUpDouble, KeyEvent.ACTION_UP)
        }
        volUpTapCount = 0
    }

    private val volDownDoubleTapRunnable = Runnable {
        if (volDownTapCount == 1) {
            executeHardkeyAction(prefs.hardkeyVolDownTap, KeyEvent.ACTION_UP)
        }
        volDownTapCount = 0
    }

    // =================================================================================
    // SECTION: BroadcastReceiver & Window Focus Logic
    // SUMMARY: Updates VOICE_TYPE_TRIGGERED.
    //          REMOVED the logic that restored 'setOverlayFocusable(true)'.
    //          The overlay must remain NOT_FOCUSABLE so Termux retains input focus.
    // =================================================================================
    // =================================================================================
    // SECTION: BroadcastReceiver (Voice Trigger)
    // SUMMARY: Turns the indicator GREEN when Voice is triggered.
    //          Sets isVoiceActive = true immediately.
    // =================================================================================
    // =================================================================================
    // INTER-APP COMMAND RECEIVER
    // SUMMARY: BroadcastReceiver for ADB commands and inter-app communication.
    //          Allows DroidOS Launcher to control Trackpad without killing permissions.
    //          Commands can be sent via ADB: adb shell am broadcast -a <ACTION>
    // =================================================================================
    private val switchReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            val action = intent?.action ?: return
            
            // Helper to match both old (example) and new (katsuyamaki) package actions
            fun matches(suffix: String): Boolean = action.endsWith(suffix)

            when {
                // Internal Actions (Exact Match)
                action == "SWITCH_DISPLAY" -> switchDisplay()
                action == "CYCLE_INPUT_TARGET" -> cycleInputTarget()
                action == "RESET_CURSOR" -> resetCursorCenter()
                action == "TOGGLE_DEBUG" -> toggleDebugMode()
                action == "FORCE_KEYBOARD" || action == "TOGGLE_CUSTOM_KEYBOARD" -> {
                    val forceShow = intent.getBooleanExtra("FORCE_SHOW", false)
                    val forceHide = intent.getBooleanExtra("FORCE_HIDE", false)
                    
                    if (forceHide) {
                        // Force hide from Dock IME auto-sync
                        if (isCustomKeyboardVisible) {
                            keyboardOverlay?.hide()
                            isCustomKeyboardVisible = false
                        }
                    } else if (forceShow) {
                        // FORCE RESET LOGIC:
                        if (keyboardOverlay == null) initCustomKeyboard()
                        keyboardOverlay?.hide()
                        keyboardOverlay?.show()
                        isCustomKeyboardVisible = true
                        enforceZOrder()
                    } else {
                        toggleCustomKeyboard()
                    }
                }
                
                action == "DOCK_PREF_CHANGED" -> {
                    // Handle preference changes from Dock IME popup
                    if (intent.hasExtra("dock_mode")) {
                        val dockMode = intent.getBooleanExtra("dock_mode", false)
                        if (dockMode) {
                            applyDockMode()
                        } else {
                            // Could restore previous position here
                            showToast("Dock mode disabled")
                        }
                    }
                }
                
                action == "APPLY_DOCK_MODE" -> {
                    if (intent.getBooleanExtra("enabled", false)) {
                        applyDockMode()
                    }
                }


                action == "OPEN_MENU" -> { menuManager?.show(); enforceZOrder() }
                action == "SET_TRACKPAD_VISIBILITY" -> {

                    val visible = intent.getBooleanExtra("VISIBLE", true)
                    val menuDisplayId = intent.getIntExtra("MENU_DISPLAY_ID", -1)
                    if (visible) setTrackpadVisibility(true) 
                    else { if (menuDisplayId == -1 || menuDisplayId == currentDisplayId) setTrackpadVisibility(false) }
                }
                action == "SET_PREVIEW_MODE" -> setPreviewMode(intent.getBooleanExtra("PREVIEW_MODE", false))
                // Just UI update (sent by triggerVoiceTyping)
                action == "VOICE_TYPE_TRIGGERED" -> {
                    isVoiceActive = true
                    keyboardOverlay?.setVoiceActive(true)
                    setOverlayFocusable(false)
                    handler.postDelayed({ attemptRefocusInput() }, 300)
                }
                // Full Action Trigger (sent by Dock)
                action == "REQUEST_VOICE_INPUT" -> {
                    handler.post { Toast.makeText(context, "Voice Requested...", Toast.LENGTH_SHORT).show() }
                    triggerVoiceTyping()
                }
                action == Intent.ACTION_SCREEN_ON -> {
                    // Only trigger blocking on Cover Screen (display 1) when enabled
                    if (currentDisplayId == 1 && prefs.prefBlockSoftKeyboard) {
                        triggerAggressiveBlocking()
                    }
                }



                // Universal ADB/External Commands (Suffix Match)
                matches("SOFT_RESTART") -> {
                    Log.d(TAG, "Received SOFT_RESTART command")
                    val targetDisplayId = intent.getIntExtra("DISPLAY_ID", currentDisplayId)
                    handler.post {
                        removeOldViews()
                        handler.postDelayed({
                            setupUI(targetDisplayId)
                            enforceZOrder()
                            showToast("Trackpad Soft Restarted")
                        }, 200)
                    }
                }
                matches("MOVE_TO_VIRTUAL") -> {
                    Log.d(TAG, "Received MOVE_TO_VIRTUAL command")
                    val virtualDisplayId = intent.getIntExtra("DISPLAY_ID", 2)
                    handler.post { moveToVirtualDisplayAndEnableMirror(virtualDisplayId) }
                }
                matches("RETURN_TO_PHYSICAL") -> {
                    Log.d(TAG, "Received RETURN_TO_PHYSICAL command")
                    val physicalDisplayId = intent.getIntExtra("DISPLAY_ID", 0)
                    handler.post { returnToPhysicalDisplay(physicalDisplayId) }
                }
                matches("ENFORCE_ZORDER") -> {
                    Log.d(TAG, "Received ENFORCE_ZORDER command")
                    handler.post { enforceZOrder() }
                }
                matches("TOGGLE_VIRTUAL_MIRROR") -> {
                    Log.d(TAG, "Received TOGGLE_VIRTUAL_MIRROR command")
                    handler.post { toggleVirtualMirrorMode() }
                }
                matches("GET_STATUS") -> {
                    Log.d(TAG, "Received GET_STATUS command")
                    showToast("D:$currentDisplayId T:$inputTargetDisplayId M:${if(prefs.prefVirtualMirrorMode) "ON" else "OFF"}")
                }
            }
        }
    }

    // Helper to dynamically update window flags
    private fun setOverlayFocusable(focusable: Boolean) {
        try {
            keyboardOverlay?.setFocusable(focusable)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
    
    // NEW FUNCTION: Finds the focused input field and performs a click
    private fun attemptRefocusInput() {
        try {
            // Requires canRetrieveWindowContent="true" in accessibility xml
            val root = rootInActiveWindow ?: return
            
            // Find the node that currently has input focus
            val focus = root.findFocus(android.view.accessibility.AccessibilityNodeInfo.FOCUS_INPUT)
            
            if (focus != null) {
                // Simulate a tap on the text box to refresh the InputConnection
                focus.performAction(android.view.accessibility.AccessibilityNodeInfo.ACTION_CLICK)
                focus.recycle()
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
    // =================================================================================
    // END BLOCK: BroadcastReceiver & Window Focus Logic
    // =================================================================================

    // =================================================================================
    // FUNCTION: checkAndDismissVoice
    // SUMMARY:  Dismisses Voice Input.
    //           FIX 1: Uses performGlobalAction(GLOBAL_ACTION_BACK) for reliable closing.
    //           FIX 2: Adds a small delay to ensure the action registers.
    // =================================================================================
    // =================================================================================
    // FUNCTION: checkAndDismissVoice
    // SUMMARY:  Called when user touches Trackpad/Keyboard.
    //           Turns the indicator OFF (Red) and Resets Flag.
    //           Injects BACK key to close Google Voice.
    // =================================================================================
    private fun checkAndDismissVoice() {
        if (isVoiceActive) {
            isVoiceActive = false 
            
            // IMMEDIATE UI UPDATE: Turn Mic Off
            keyboardOverlay?.setVoiceActive(false)
            
            // Stop monitoring
            micCheckHandler.removeCallbacks(micCheckRunnable)
            
            // Standard Dismissal Logic (Back Button)
            Thread {
                try {
                    val success = performGlobalAction(AccessibilityService.GLOBAL_ACTION_BACK)
                    if (!success) {
                        injectKey(KeyEvent.KEYCODE_BACK, KeyEvent.ACTION_DOWN)
                        Thread.sleep(50)
                        injectKey(KeyEvent.KEYCODE_BACK, KeyEvent.ACTION_UP)
                    }
                    // Only re-enable blocking on cover screen
                    if (currentDisplayId == 1 && prefs.prefBlockSoftKeyboard) {
                        triggerAggressiveBlocking()
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }.start()
        }
    }

    // --- Voice Logic & Mic Check Loop ---


    private val micCheckHandler = Handler(Looper.getMainLooper())
    
    private val micCheckRunnable = object : Runnable {
        override fun run() {
            try {
                val audioManager = getSystemService(Context.AUDIO_SERVICE) as AudioManager
                
                var isMicOn = false
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                    if (audioManager.activeRecordingConfigurations.isNotEmpty()) {
                        isMicOn = true
                    }
                }
                
                if (isMicOn) {
                    // Still recording, check again in 1 second
                    micCheckHandler.postDelayed(this, 1000)
                } else {
                    // Mic stopped, turn off the green light
                    isVoiceActive = false
                    keyboardOverlay?.setVoiceActive(false)
                }
            } catch (e: Exception) {
                isVoiceActive = false
                keyboardOverlay?.setVoiceActive(false)
            }
        }
    }

    private fun triggerVoiceTyping() {
        if (shellService == null) return

        // 1. UI: Turn Button Green Immediately
        isVoiceActive = true
        keyboardOverlay?.setVoiceActive(true)
        setOverlayFocusable(false) // Ensure focus is passable
        
        // 2. Start Monitoring Loop
        // Delay 3 seconds to allow the Voice IME to open and start recording
        micCheckHandler.removeCallbacks(micCheckRunnable)
        micCheckHandler.postDelayed(micCheckRunnable, 3000)

        // 3. Perform IME Switch via Shell
        Thread {
            try {
                // Fetch IME list and find Google Voice Typing
                val output = shellService?.runCommand("ime list -a -s") ?: ""
                val voiceIme = output.lines().find { it.contains("google", true) && it.contains("voice", true) } 
                    ?: output.lines().find { it.contains("voice", true) }
                
                if (voiceIme != null) {
                    shellService?.runCommand("ime set $voiceIme")
                    // Try to refocus input
                    handler.postDelayed({ attemptRefocusInput() }, 500)
                } else {
                    Log.w(TAG, "Voice IME not found")
                    handler.post { 
                        isVoiceActive = false
                        keyboardOverlay?.setVoiceActive(false)
                        showToast("Voice IME not found")
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Voice Switch Failed", e)
                handler.post { 
                    isVoiceActive = false
                    keyboardOverlay?.setVoiceActive(false)
                }
            }
        }.start()
    }

    companion object {
        private const val TAG = "OverlayService"
        private const val BASE_SWIPE_DISTANCE = 200f
    }
    
    fun vibrate() { 
        if (!prefs.prefVibrate) return
        val v = getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
        if (Build.VERSION.SDK_INT >= 26) v.vibrate(VibrationEffect.createOneShot(50, VibrationEffect.DEFAULT_AMPLITUDE)) 
        else @Suppress("DEPRECATION") v.vibrate(50) 
    }

    private val userServiceConnection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, binder: IBinder?) {
            shellService = IShellService.Stub.asInterface(binder)
            isBound = true
            updateBubbleStatus()
            showToast("Shizuku Connected") 
            initCustomKeyboard()
            
            // CRITICAL FIX: Only apply blocking on Cover Screen (display 1) when enabled
            if (currentDisplayId == 1 && prefs.prefBlockSoftKeyboard) {
                triggerAggressiveBlocking()
                handler.post(blockingHeartbeat)
            }

// Request Custom Modifier Key from Launcher
            val syncIntent = Intent("com.katsuyamaki.DroidOSLauncher.REQUEST_CUSTOM_MOD_SYNC")
            syncIntent.setPackage("com.katsuyamaki.DroidOSLauncher")
            sendBroadcast(syncIntent)
        }
        override fun onServiceDisconnected(name: ComponentName?) {
            shellService = null
            isBound = false
            updateBubbleStatus()
        }
    }

    override fun onCreate() {
        super.onCreate()

        // Register BOTH new and old prefixes to support all scripts/buttons
        val commandFilter = IntentFilter().apply {
            val cmds = listOf("SOFT_RESTART", "ENFORCE_ZORDER", "MOVE_TO_DISPLAY", "TOGGLE_MIRROR", "TOGGLE_VIRTUAL_MIRROR", "OPEN_DRAWER", "STOP_SERVICE", "SET_INPUT_CAPTURE", "SET_CUSTOM_MOD", "UPDATE_KEYBINDS", "SET_NUM_LAYER")
            val prefixes = listOf("com.katsuyamaki.DroidOSTrackpadKeyboard.", "com.example.coverscreentester.")

            for (p in prefixes) {
                for (c in cmds) {
                    addAction("$p$c")
                }
            }
        }
        // Export receiver so ADB and other apps can send these commands
        if (Build.VERSION.SDK_INT >= 33) {
            registerReceiver(commandReceiver, commandFilter, Context.RECEIVER_EXPORTED)
        } else {
            registerReceiver(commandReceiver, commandFilter)
        }

        // =================================================================================
        // REQUEST KEYBINDS FROM LAUNCHER ON STARTUP
        // SUMMARY: Ask the Launcher to broadcast its registered keybinds so we know
        //          which shortcuts to block. This ensures sync on Trackpad startup.
        // =================================================================================
        requestKeybindsFromLauncher()
        // =================================================================================
        // END BLOCK: REQUEST KEYBINDS FROM LAUNCHER ON STARTUP
        // =================================================================================

        try { displayManager = getSystemService(Context.DISPLAY_SERVICE) as DisplayManager; displayManager?.registerDisplayListener(this, handler) } catch (e: Exception) {}
        try { val im = getSystemService(Context.INPUT_SERVICE) as InputManager; im.registerInputDeviceListener(this, handler) } catch (e: Exception) {}
        // =================================================================================
        // VIRTUAL DISPLAY KEEP-ALIVE: Initialize PowerManager
        // =================================================================================
        powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
        // =================================================================================
        // END BLOCK: VIRTUAL DISPLAY KEEP-ALIVE PowerManager Init
        // =================================================================================


// =================================================================================
        // CONTENT OBSERVER: Watch for Default Keyboard Changes  
        // SUMMARY: Detects when Samsung forces its keyboard and fights back IMMEDIATELY.
        //          Samsung OneUI forces HoneyBoard when text fields get focus on Main Screen.
        //          We detect this and instantly switch back to Gboard.
        // =================================================================================
        contentResolver.registerContentObserver(
            android.provider.Settings.Secure.getUriFor("default_input_method"),
            false,
            object : android.database.ContentObserver(handler) {
                private var lastObservedIme: String = ""
                private var lastFightTime: Long = 0
                
                override fun onChange(selfChange: Boolean) {
                    val current = android.provider.Settings.Secure.getString(contentResolver, "default_input_method") ?: ""
                    
                    android.util.Log.d(TAG, "IME Observer: '$lastObservedIme' -> '$current' (display=$currentDisplayId)")
                    
                    // =================================================================================
                    // SKIP EMPTY ONLY - Allow NullKeyboard through so it can be saved as preference
                    // =================================================================================
                    if (current.isEmpty()) {
                        lastObservedIme = current
                        return
                    }
                    
                    val isDock = current.contains("DockInputMethodService") || current.contains("NullInputMethodService")
                    val isSamsung = current.contains("honeyboard") || current.contains("com.sec.android.inputmethod")
                    val wasGboard = lastObservedIme.contains("com.google.android.inputmethod.latin")
                    val wasDock = lastObservedIme.contains("DockInputMethodService") || lastObservedIme.contains("NullInputMethodService")
                    val isOnMainScreen = currentDisplayId == 0

                    // =================================================================================
                    // END BLOCK: SKIP EMPTY ONLY
                    // =================================================================================
                    
                    // =================================================================================
                    // SAMSUNG TAKEOVER DETECTION
                    // If Samsung just took over FROM Gboard while on Main Screen, fight back NOW!
                    // Skip if we came from Dock (handled separately below)
                    // =================================================================================
                    if (isSamsung && wasGboard && isOnMainScreen && !wasDock) {

                        val now = System.currentTimeMillis()
                        // Throttle: Don't fight more than once per second
                        if (now - lastFightTime > 1000) {
                            lastFightTime = now
                            android.util.Log.w(TAG, "IME Observer: SAMSUNG TAKEOVER DETECTED! Fighting back...")
                            
                            // Fight IMMEDIATELY in a new thread
                            Thread {
                                try {
                                    val gboardId = "com.google.android.inputmethod.latin/com.android.inputmethod.latin.LatinIME"
                                    val samsungId = current
                                    
                                    // NUCLEAR OPTION: Keep Samsung disabled for longer
                                    android.util.Log.w(TAG, " IMMEDIATE SAMSUNG FIGHT ")
                                    
                                    // 1. Disable Samsung
                                    shellService?.runCommand("ime disable $samsungId")
                                    android.util.Log.w(TAG, " Samsung disabled")
                                    
                                    // 2. Force Gboard
                                    shellService?.runCommand("settings put secure default_input_method $gboardId")
                                    shellService?.runCommand("ime set $gboardId")
                                    android.util.Log.w(TAG, " Gboard set")
                                    
                                    // 3. Wait LONGER before re-enabling (5 seconds)
                                    Thread.sleep(5000)
                                    
                                    // 4. Re-enable Samsung
                                    shellService?.runCommand("ime enable $samsungId")
                                    android.util.Log.w(TAG, " Samsung re-enabled")
                                    
                                    // 5. Verify
                                    val finalIme = shellService?.runCommand("settings get secure default_input_method")?.trim() ?: ""
                                    val success = finalIme.contains("google.android.inputmethod.latin")
                                    android.util.Log.w(TAG, " Final: $finalIme")
                                    android.util.Log.w(TAG, " Success: $success")
                                    
                                    if (!success) {
                                        // Try one more time
                                        android.util.Log.w(TAG, " RETRY FIGHT ")
                                        shellService?.runCommand("ime disable $samsungId")
                                        Thread.sleep(500)
                                        shellService?.runCommand("settings put secure default_input_method $gboardId")
                                        shellService?.runCommand("ime set $gboardId")
                                        Thread.sleep(3000)
                                        shellService?.runCommand("ime enable $samsungId")
                                        
                                        val retryFinal = shellService?.runCommand("settings get secure default_input_method")?.trim() ?: ""
                                        android.util.Log.w(TAG, " Retry final: $retryFinal")
                                    }
                                    
                                } catch (e: Exception) {
                                    android.util.Log.e(TAG, "Samsung fight error: ${e.message}")
                                }
                            }.start()
                        }
                    }
                    // =================================================================================
                    // END BLOCK: SAMSUNG TAKEOVER DETECTION
                    // =================================================================================
                    
                    // =================================================================================
                    // SAMSUNG TAKEOVER FROM DOCK
                    // If Samsung took over from Dock, restore Dock (not Gboard)
                    // Only when blocking is OFF (user intentionally wants Dock)
                    // =================================================================================
                    if (isSamsung && wasDock && !prefs.prefBlockSoftKeyboard) {

                        val now = System.currentTimeMillis()
                        if (now - lastFightTime > 1000) {
                            lastFightTime = now
                            android.util.Log.w(TAG, "IME Observer: Samsung took over from NullKB! Restoring NullKB...")
                            
                            Thread {
                                try {
                                    // Try Dock ID first, fallback is handled if we set it as enabled
                                    val dockId = "$packageName/com.example.coverscreentester.DockInputMethodService"
                                    val samsungId = current

                                    
                                    android.util.Log.w(TAG, " NULLKB RESTORATION ")
                                    
                                    // 1. Disable Samsung
                                    shellService?.runCommand("ime disable $samsungId")
                                    android.util.Log.w(TAG, " Samsung disabled")
                                    
                                    // 2. Enable and set Dock
                                    shellService?.runCommand("ime enable $dockId")
                                    shellService?.runCommand("settings put secure default_input_method $dockId")
                                    shellService?.runCommand("ime set $dockId")
                                    android.util.Log.w(TAG, " Dock set")

                                    
                                    // 3. Wait for stability (past Samsung protection window)
                                    Thread.sleep(3000)
                                    
                                    // 4. Re-enable Samsung
                                    shellService?.runCommand("ime enable $samsungId")
                                    android.util.Log.w(TAG, " Samsung re-enabled")
                                    
                                    // 5. Verify
                                    Thread.sleep(500)
                                    val finalIme = shellService?.runCommand("settings get secure default_input_method")?.trim() ?: ""
                                    val success = finalIme.contains("DockInputMethodService")
                                    android.util.Log.w(TAG, " Final: $finalIme")

                                    android.util.Log.w(TAG, " Success: $success")
                                    
                                } catch (e: Exception) {
                                    android.util.Log.e(TAG, "NullKB restore error: ${e.message}")
                                }
                            }.start()
                        }
                    }
                    // =================================================================================
                    // END BLOCK: SAMSUNG TAKEOVER FROM NULLKEYBOARD
                    // =================================================================================
                    
                    // =================================================================================
                    // SAVE PREFERENCE LOGIC
                    // Save user's keyboard choice. Allow NullKeyboard when blocking is OFF.
                    //          Skip Samsung (auto-fallback). Skip if not on main screen.
                    // =================================================================================
                    val shouldSave = when {
                        isSamsung -> {
                            android.util.Log.d(TAG, "IME Observer: SKIPPING Samsung save")
                            false
                        }
                        isDock && prefs.prefBlockSoftKeyboard -> {
                            // Blocking is ON - Dock was set by our blocking, not user choice
                            android.util.Log.d(TAG, "IME Observer: SKIPPING Dock save (blocking ON)")
                            false
                        }
                        isDock && !prefs.prefBlockSoftKeyboard -> {
                            // Blocking is OFF - User intentionally selected Dock
                            android.util.Log.i(TAG, "IME Observer: SAVING Dock as user preference (blocking OFF)")
                            true
                        }
                        !isOnMainScreen -> {
                            android.util.Log.d(TAG, "IME Observer: SKIPPING save (not on main screen)")
                            false
                        }
                        else -> true
                    }
                    // =================================================================================
                    // END BLOCK: SAVE PREFERENCE LOGIC
                    // =================================================================================
                    
                    if (shouldSave) {
                        getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
                            .edit()
                            .putString("user_preferred_ime", current)
                            .apply()
                            
                        android.util.Log.i(TAG, "IME Observer: SAVED preference: $current")
                        
                        val name = when {
                            current.contains("google.android.inputmethod.latin") -> "Gboard"
                            current.contains("DockInputMethodService") -> "DroidOS Dock"
                            current.contains("NullInputMethodService") -> "DroidOS Dock"
                            current.contains("honeyboard") -> "Samsung"

                            current.contains("juloo.keyboard2") -> "Unexpected KB"
                            else -> "Custom Keyboard"
                        }
                        handler.post { showToast("Saved: $name") }
                        handler.post { menuManager?.refresh() }
                    }
                    
                    lastObservedIme = current
                }
            }
        )

        // =================================================================================
        // END BLOCK: CONTENT OBSERVER for Default Keyboard Changes
        // =================================================================================
        
        loadPrefs()
        val filter = IntentFilter().apply { 
            // Internal short commands
            addAction("SWITCH_DISPLAY")

                        addAction("CYCLE_INPUT_TARGET")
                        addAction("RESET_CURSOR")
                        addAction("TOGGLE_DEBUG")
                        addAction("FORCE_KEYBOARD")
                        addAction("TOGGLE_CUSTOM_KEYBOARD")
                        addAction("DOCK_PREF_CHANGED")
                        addAction("APPLY_DOCK_MODE")
                        addAction("SET_TRACKPAD_VISIBILITY")
                        addAction("SET_PREVIEW_MODE") 
                        addAction("OPEN_MENU")
                        addAction("VOICE_TYPE_TRIGGERED")
                        addAction("REQUEST_VOICE_INPUT")
                        addAction(Intent.ACTION_SCREEN_ON)

                        // External commands (Old and New Prefixes)
                        val actions = listOf(
                            "SOFT_RESTART", "MOVE_TO_VIRTUAL", "RETURN_TO_PHYSICAL",
                            "ENFORCE_ZORDER", "TOGGLE_VIRTUAL_MIRROR", "GET_STATUS"
                        )
                        val prefixes = listOf(
                            "com.katsuyamaki.DroidOSTrackpadKeyboard.",
                            "com.example.coverscreentester."
                        )
                        for (prefix in prefixes) {
                            for (act in actions) {
                                addAction("$prefix$act")
                            }
                        }
                    }
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                        // For Android 13 (TIRAMISU) and above, receivers must explicitly specify exported state
                        ContextCompat.registerReceiver(this, switchReceiver, filter, Context.RECEIVER_EXPORTED)
                    } else {
                        ContextCompat.registerReceiver(this, switchReceiver, filter, ContextCompat.RECEIVER_NOT_EXPORTED)
                    }
                    
                    if (Build.VERSION.SDK_INT >= 24) {
                        try { softKeyboardController.showMode = AccessibilityService.SHOW_MODE_AUTO } catch(e: Exception){}        }
    }



    // This is the Accessibility Service entry point
// =================================================================================
    // FUNCTION: onServiceConnected
    // SUMMARY: AccessibilityService entry point - called when user enables service.
    //          Initializes managers, loads dictionary, registers receivers, and builds UI.
    // =================================================================================
    // =================================================================================
    // FUNCTION: handleGlobalTouch
    // SUMMARY: Called on any touch event that passes through. Checks if spacebar mouse
    //          extended mode is active and if touch is outside keyboard bounds.
    //          If so, exits extended mode.
    // NOTE: This is called from the root trackpad touch handler or accessibility event.
    // =================================================================================
    private fun handleSpacebarExtendedModeCheck(x: Float, y: Float, action: Int) {
        if (!prefs.prefSpacebarMouseExtended) return
        if (action != MotionEvent.ACTION_DOWN) return
        
        val kbView = keyboardOverlay?.getKeyboardView() ?: return
        if (!kbView.isInSpacebarMouseMode()) return
        
        // Check if touch is within keyboard bounds
        val kbBounds = keyboardOverlay?.getKeyboardBounds()
        if (kbBounds == null) {
            // Can't determine bounds, don't exit
            return
        }
        
        val isInsideKeyboard = x >= kbBounds.left && x <= kbBounds.right &&
                               y >= kbBounds.top && y <= kbBounds.bottom
        
        if (!isInsideKeyboard) {
            android.util.Log.d("SpaceTrackpad", "Tap outside keyboard detected - exiting extended mode")
            kbView.exitSpacebarMouseMode()
        }
    }
    // =================================================================================
    // END BLOCK: handleSpacebarExtendedModeCheck
    // =================================================================================

    override fun onServiceConnected() {
        super.onServiceConnected()
        Log.d(TAG, "Accessibility Service Connected")
        isAccessibilityReady = true

        // =================================================================================
        // CRITICAL: Initialize PredictionEngine Dictionary
        // SUMMARY: Load the dictionary at service start. Without this, swipe typing fails
        //          because decodeSwipe() has no words to match against.
        // =================================================================================
        PredictionEngine.instance.loadDictionary(this)
        // =================================================================================
        // END BLOCK: Initialize PredictionEngine Dictionary
        // =================================================================================

        // Initialize Managers
        windowManager = getSystemService(WINDOW_SERVICE) as WindowManager
        displayManager = getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
        
        // [FIX] Correct variable names for OverlayService:
        // Use 'this' (because OverlayService implements DisplayListener)
        // Use 'handler' (not uiHandler)
        displayManager?.registerDisplayListener(this, handler)

        // Register receivers
        val filter = IntentFilter().apply {
            addAction("com.katsuyamaki.DroidOSLauncher.OPEN_DRAWER")
            addAction("com.katsuyamaki.DroidOSLauncher.UPDATE_ICON")
            addAction("com.katsuyamaki.DroidOSLauncher.CYCLE_DISPLAY")
            addAction(Intent.ACTION_SCREEN_ON)
            addAction(Intent.ACTION_SCREEN_OFF)
        }
        if (Build.VERSION.SDK_INT >= 33) registerReceiver(commandReceiver, filter, Context.RECEIVER_EXPORTED) else registerReceiver(commandReceiver, filter)

        // [FIX] Removed incompatible Shizuku listeners that belong to Launcher
        
        // [FIX] USE RETRY LOGIC HERE
        checkAndBindShizuku()

        // Load preferences
        loadPrefs() 
        
        // [FIX] READ TARGET DISPLAY (Fixes "Wrong Display" on Race Condition)
        val globalTarget = try {
            android.provider.Settings.Global.getInt(contentResolver, "droidos_target_display", -1)
        } catch (e: Exception) { -1 }

        val finalTarget = if (globalTarget != -1) globalTarget else currentDisplayId
        
        Log.i(TAG, "Startup: Launching UI on Display $finalTarget (Global: $globalTarget)")
        
        // =================================================================================
        // ONE-TIME FIX: Clear stale Samsung preference if Gboard is available
        // SUMMARY: Previous bug caused Samsung to be saved as preferred IME.
        //          This checks on startup and fixes if Gboard is available.
        // =================================================================================
        try {
            val prefs = getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
            val savedIme = prefs.getString("user_preferred_ime", null)
            if (savedIme != null && (savedIme.contains("honeyboard") || savedIme.contains("com.sec"))) {
                // Check if Gboard is enabled
                Thread {
                    try {
                        val enabledImes = shellService?.runCommand("ime list -s") ?: ""
                        val gboard = enabledImes.lines().find { 
                            it.contains("com.google.android.inputmethod.latin") 
                        }
                        if (gboard != null) {
                            android.util.Log.w(TAG, "STARTUP FIX: Replacing stale Samsung preference with Gboard")
                            prefs.edit().putString("user_preferred_ime", gboard.trim()).apply()
                        }
                    } catch (e: Exception) {}
                }.start()
            }
        } catch (e: Exception) {}
        // =================================================================================
        // END BLOCK: ONE-TIME FIX for stale Samsung preference
        // =================================================================================
        
        // Build UI
        setupUI(finalTarget)
        
        // [FIX] Ensure bubble icon status is updated
        updateBubbleStatus()

        // Clear pending states
        pendingDisplayId = -1

        showToast("Trackpad Ready")
    }




   override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        try { createNotification() } catch(e: Exception){ e.printStackTrace() }
        
        // === DEBUG LOGGING START ===
        if (intent != null) {
            val dId = intent.getIntExtra("displayId", -999)
            val action = intent.action
            val force = intent.getBooleanExtra("force_start", false)
            Log.w(TAG, ">>> SERVICE STARTED | Action: $action | DisplayID: $dId | Force: $force <<<")
            
            if (dId != -999) {
                handler.post { Toast.makeText(this, "Service Started on D:$dId", Toast.LENGTH_SHORT).show() }
            }
        } else {
            Log.e(TAG, ">>> SERVICE STARTED | INTENT IS NULL <<<")
        }
        // === DEBUG LOGGING END ===

        try {
            checkAndBindShizuku()

            // [FIX] Combined Startup Logic
            if (intent != null) {
                val dId = intent.getIntExtra("displayId", -1)
                
                if (dId != -1) {
                    if (isAccessibilityReady) {
                        // Safe to launch immediately
                        Log.d(TAG, "onStartCommand: Ready -> Setup UI Display $dId")
                        setupUI(dId)
                    } else {
                        // Too early! Queue it for onServiceConnected
                        Log.d(TAG, "onStartCommand: Not Ready -> Queueing Display $dId")
                        pendingDisplayId = dId
                    }
                    return START_STICKY
                }
            }

            // --- Original Logic for other intents/conditions ---
            // If no explicit displayId was passed, or if the AccessibilityService is not yet ready
            // for the initial setup, we fall back to the existing logic.
            val action = intent?.action
            fun matches(suffix: String): Boolean = action?.endsWith(suffix) == true
            
            // Handle commands robustly (keeping original intent handling)
            if (action != null) {
                when {
                    // Standard Actions
                    action == "SWITCH_DISPLAY" -> switchDisplay()
                    action == "RESET_POSITION" -> {
                        val target = intent.getStringExtra("TARGET") ?: "TRACKPAD"
                        if (target == "KEYBOARD") keyboardOverlay?.resetPosition() else resetTrackpadPosition()
                    }
                    action == "ROTATE" -> {
                        val target = intent.getStringExtra("TARGET") ?: "TRACKPAD"
                        if (target == "KEYBOARD") keyboardOverlay?.cycleRotation() else performRotation()
                    }
                    action == "SAVE_LAYOUT" -> saveLayout()
                    action == "LOAD_LAYOUT" -> loadLayout()
                    action == "DELETE_PROFILE" -> deleteCurrentProfile()
                    action == "MANUAL_ADJUST" -> handleManualAdjust(intent)
                    action == "RELOAD_PREFS" -> {
                        loadPrefs()
                        updateBorderColor(currentBorderColor)
                        updateLayoutSizes()
                        updateScrollPosition()
                        updateCursorSize()
                        keyboardOverlay?.updateAlpha(prefs.prefKeyboardAlpha)
                        if (isCustomKeyboardVisible) { toggleCustomKeyboard(); toggleCustomKeyboard() }
                    }
                    action == "PREVIEW_UPDATE" -> handlePreview(intent)
                    action == "CYCLE_INPUT_TARGET" -> cycleInputTarget()
                    action == "RESET_CURSOR" -> resetCursorCenter()
                    action == "TOGGLE_DEBUG" -> toggleDebugMode()
                    action == "FORCE_KEYBOARD" || action == "TOGGLE_CUSTOM_KEYBOARD" -> toggleCustomKeyboard()
                    action == "OPEN_MENU" -> menuManager?.show()
                    
                    // ADB / Launcher Commands (Suffix Matching)
                    matches("SOFT_RESTART") -> {
                        Log.d(TAG, "onStartCommand: SOFT_RESTART -> Delegating")
                        performSoftRestart()
                    }
                    matches("MOVE_TO_VIRTUAL") -> {
                        val vid = intent.getIntExtra("DISPLAY_ID", 2)
                        handler.post { moveToVirtualDisplayAndEnableMirror(vid) }
                    }
                    matches("RETURN_TO_PHYSICAL") -> {
                        val pid = intent.getIntExtra("DISPLAY_ID", 0)
                        handler.post { returnToPhysicalDisplay(pid) }
                    }
                    matches("ENFORCE_ZORDER") -> handler.post { enforceZOrder() }
                    matches("TOGGLE_VIRTUAL_MIRROR") -> handler.post { toggleVirtualMirrorMode() }
                    matches("GET_STATUS") -> showToast("Status: D=$currentDisplayId M=${prefs.prefVirtualMirrorMode}")
                }
            }

            if (intent?.hasExtra("DISPLAY_ID") == true) {
                val targetId = intent.getIntExtra("DISPLAY_ID", Display.DEFAULT_DISPLAY)
                val force = intent.getBooleanExtra("FORCE_MOVE", false)
                if (targetId >= 0 && (targetId != currentDisplayId || force)) {
                    forceMoveToDisplay(targetId)
                }
            } else if (windowManager == null) {
                setupUI(Display.DEFAULT_DISPLAY)
            }
            
            // [CRITICAL] Ensure UI is created if missing
            if (windowManager == null || bubbleView == null) {
                setupUI(Display.DEFAULT_DISPLAY)
            }

        } catch (e: Exception) {
            Log.e(TAG, "CRASH during onStartCommand", e)
            // Retry setup safely
            try { setupUI(Display.DEFAULT_DISPLAY) } catch(e2: Exception) {}
        }
        return START_STICKY
    }

    override fun onInterrupt() {}

    // Use dispatchKeyEvent to catch BOTH Down and Up events in one place
    override fun onKeyEvent(event: KeyEvent): Boolean {
        val isVolKey = event.keyCode == KeyEvent.KEYCODE_VOLUME_UP || event.keyCode == KeyEvent.KEYCODE_VOLUME_DOWN
        
        if (isPreviewMode || (!isTrackpadVisible && !isVolKey)) {
            return super.onKeyEvent(event)
        }
        
        val action = event.action
        val keyCode = event.keyCode
        
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
            // [FIX] Allow panic detection even if "none" is selected
            // We check logic inside to allow pass-through if count < 5 and action is none
            val isConfigured = (prefs.hardkeyVolUpTap != "none" || prefs.hardkeyVolUpHold != "none")

            when (action) {
                KeyEvent.ACTION_DOWN -> {
                    if (!isLeftKeyHeld) {
                        isLeftKeyHeld = true
                        volUpHoldTriggered = false
                        if (isConfigured) handler.postDelayed(volUpHoldRunnable, prefs.holdDurationMs.toLong())
                    }
                }
                KeyEvent.ACTION_UP -> {
                    isLeftKeyHeld = false
                    handler.removeCallbacks(volUpHoldRunnable)

                    if (volUpHoldTriggered) {
                        // RELEASE the hold action
                        if (isConfigured) executeHardkeyAction(prefs.hardkeyVolUpHold, KeyEvent.ACTION_UP)
                        volUpTapCount = 0
                    } else {
                        val timeSinceLastTap = System.currentTimeMillis() - lastVolUpTime
                        lastVolUpTime = System.currentTimeMillis()

                        // [SAFETY] PANIC LOGIC: 5 Rapid Taps (< 400ms gap)
                        if (timeSinceLastTap < 400) {
                            volUpTapCount++
                        } else {
                            volUpTapCount = 1
                        }

                        // Remove pending double-tap action while we count up
                        handler.removeCallbacks(volUpDoubleTapRunnable)

                        if (volUpTapCount >= 5) {
                            // !!! PANIC TRIGGERED !!!
                            volUpTapCount = 0
                            performEmergencyReset()
                            return true // Always consume panic
                        } else if (volUpTapCount == 2) {
                            // Schedule Double Tap (cancellable if user keeps tapping for panic)
                            if (isConfigured) handler.postDelayed(volUpDoubleTapRunnable, prefs.doubleTapMs.toLong())
                        } else if (volUpTapCount == 1) {
                            // Schedule Single Tap
                            if (isConfigured) handler.postDelayed(volUpDoubleTapRunnable, prefs.doubleTapMs.toLong())
                        }
                    }
                }
            }

            // If configured, consume event. If not, only consume if we are mid-panic-sequence (count > 0)
            // This allows normal Volume Up to work if "none" is selected, until you tap fast enough to trigger panic logic
            return isConfigured || volUpTapCount > 0
        }

        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
            if (prefs.hardkeyVolDownTap == "none" && prefs.hardkeyVolDownHold == "none") return super.onKeyEvent(event)
            
            when (action) {
                KeyEvent.ACTION_DOWN -> {
                    if (!isRightKeyHeld) {
                        isRightKeyHeld = true
                        volDownHoldTriggered = false
                        handler.postDelayed(volDownHoldRunnable, prefs.holdDurationMs.toLong())
                    }
                }
                KeyEvent.ACTION_UP -> {
                    isRightKeyHeld = false
                    handler.removeCallbacks(volDownHoldRunnable)
                    if (volDownHoldTriggered) {
                        // RELEASE the hold action
                        executeHardkeyAction(prefs.hardkeyVolDownHold, KeyEvent.ACTION_UP)
                    } else {
                        val timeSinceLastTap = System.currentTimeMillis() - lastVolDownTime
                        lastVolDownTime = System.currentTimeMillis()
                        if (timeSinceLastTap < prefs.doubleTapMs && volDownTapCount == 1) {
                            handler.removeCallbacks(volDownDoubleTapRunnable)
                            volDownTapCount = 0
                            executeHardkeyAction(prefs.hardkeyVolDownDouble, KeyEvent.ACTION_UP)
                        } else {
                            volDownTapCount = 1
                            handler.removeCallbacks(volDownDoubleTapRunnable)
                            handler.postDelayed(volDownDoubleTapRunnable, prefs.doubleTapMs.toLong())
                        }
                    }
                }
            }
            return true
        }
        return super.onKeyEvent(event)
    }

    private fun removeOldViews() {
        Log.i(BT_TAG, "removeOldViews() called - Attempting to clean up all overlays")
        
        val viewsToRemove = listOf(trackpadLayout, bubbleView, cursorLayout)
        for (view in viewsToRemove) {
            if (view != null && view.parent != null && windowManager != null) {
                try {
                    windowManager?.removeViewImmediate(view)
                    android.util.Log.d("OverlayService", "Successfully removed view: ${view.javaClass.simpleName}")
                } catch (e: Exception) {
                    android.util.Log.e("OverlayService", "Failed to remove view immediate", e)
                }
            }
        }
        // Clean up keyboard and menu
        try {
            keyboardOverlay?.hide()
            keyboardOverlay = null
            menuManager?.hide()
            menuManager = null
        } catch (e: Exception) {
            android.util.Log.e("OverlayService", "Failed to cleanup keyboard/menu", e)
        }
        // Clean up BT mouse capture overlay
        removeBtMouseCaptureOverlay()
        // Nullify references to ensure setup functions create fresh instances
        trackpadLayout = null
        bubbleView = null
        cursorLayout = null
        cursorView = null
    }

    private fun setupUI(displayId: Int) {
        android.util.Log.d("OverlayService", "setupUI starting for Display $displayId")

        // 1. Force complete removal of all views using the current WindowManager
        removeOldViews()

        val display = displayManager?.getDisplay(displayId)
        if (display == null) {
            showToast("Error: Display $displayId not found")
            return
        }

        try {
            // 2. Create a new context strictly for the target physical display
            val displayContext = createDisplayContext(display)
            val accessContext = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                 displayContext.createWindowContext(WindowManager.LayoutParams.TYPE_ACCESSIBILITY_OVERLAY, null)
            } else displayContext

            // 3. RE-BIND WindowManager and Inflater to the new display context
            windowManager = accessContext.getSystemService(Context.WINDOW_SERVICE) as WindowManager
            appWindowManager = windowManager

            currentDisplayId = displayId
            inputTargetDisplayId = displayId

            updateUiMetrics()

            // 4. Rebuild the UI components
            setupTrackpad(accessContext)
            if (shellService != null) initCustomKeyboard()
            menuManager = TrackpadMenuManager(displayContext, windowManager!!, this)
            setupBubble(accessContext)
            setupCursor(accessContext)


            enforceZOrder()
            showToast("Trackpad active on Display $displayId")

            // =================================================================================
            // KEYBOARD BLOCKING/RESTORATION LOGIC FOR DISPLAY SWITCH
            // SUMMARY: On Main Screen (0), ensure showMode is AUTO so keyboards can appear.
            //          On Cover Screen (1+), apply blocking if enabled.
            //          Samsung takeover is handled by the Content Observer, not here.
            // =================================================================================
            // android.util.Log.w(TAG, "")
            // android.util.Log.w(TAG, " KEYBOARD LOGIC START - setupUI($displayId)              ")
            // android.util.Log.w(TAG, "")
            
            val preCurrentIme = try {
                android.provider.Settings.Secure.getString(contentResolver, "default_input_method") ?: "null"
            } catch (e: Exception) { "error: ${e.message}" }
            val preShowMode = if (Build.VERSION.SDK_INT >= 24) {
                try { softKeyboardController.showMode.toString() } catch (e: Exception) { "error" }
            } else { "N/A (API < 24)" }
            
            /*
            android.util.Log.w(TAG, " PRE-STATE:")
            android.util.Log.w(TAG, "   displayId: $displayId")
            android.util.Log.w(TAG, "   currentDisplayId: $currentDisplayId")
            android.util.Log.w(TAG, "   prefBlockSoftKeyboard: ${prefs.prefBlockSoftKeyboard}")
            android.util.Log.w(TAG, "   current IME: $preCurrentIme")
            android.util.Log.w(TAG, "   showMode: $preShowMode")
            */

            // =================================================================================
            // KEYBOARD BLOCKING: ONLY on Cover Screen (display 1)
            // Main screen (0) and virtual displays (2+) should NEVER block keyboard
            // =================================================================================
            if (displayId == 1) {
                // COVER SCREEN - Apply blocking if enabled
                if (prefs.prefBlockSoftKeyboard) {
                    android.util.Log.d(TAG, "setupUI: Cover screen (D1) - enabling keyboard blocking")
                    triggerAggressiveBlocking()
                }
            } else {
                // MAIN SCREEN (0) or VIRTUAL DISPLAY (2+) - Never block, ensure AUTO mode
                android.util.Log.d(TAG, "setupUI: Display $displayId - ensuring keyboard NOT blocked")
                if (Build.VERSION.SDK_INT >= 24) {
                    try { softKeyboardController.showMode = AccessibilityService.SHOW_MODE_AUTO } catch (e: Exception) {}
                }
            }
            // =================================================================================
            // END BLOCK: KEYBOARD BLOCKING LOGIC
            // =================================================================================
            
            // android.util.Log.w(TAG, " KEYBOARD LOGIC END")
            // =================================================================================
            // END BLOCK: KEYBOARD BLOCKING/RESTORATION LOGIC FOR DISPLAY SWITCH
            // =================================================================================

            android.util.Log.d("OverlayService", "setupUI completed successfully on Display $displayId")


        } catch (e: Exception) {
            Log.e(TAG, "Failed to setup UI on display $displayId", e)
            showToast("Failed to launch on display $displayId")
        }
    }

    private fun setupBubble(context: Context) {
        bubbleView = LayoutInflater.from(context).inflate(R.layout.layout_trackpad_bubble, null)
        bubbleParams = WindowManager.LayoutParams(
            WindowManager.LayoutParams.WRAP_CONTENT,
            WindowManager.LayoutParams.WRAP_CONTENT,
            WindowManager.LayoutParams.TYPE_ACCESSIBILITY_OVERLAY,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or 
            WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or 
            WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,
            PixelFormat.TRANSLUCENT
        )
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
             bubbleParams.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES
        }
        bubbleParams.gravity = Gravity.TOP or Gravity.START
        bubbleParams.x = prefs.prefBubbleX
        bubbleParams.y = prefs.prefBubbleY
        
        var initialX = 0; var initialY = 0; var initialTouchX = 0f; var initialTouchY = 0f; var isDrag = false
        var isLongPressHandled = false
        var velocityTracker: VelocityTracker? = null
        val bubbleLongPressRunnable = Runnable {
            if (!isDrag) {
                vibrate()
                menuManager?.toggle()
                isLongPressHandled = true
                handler.post { enforceZOrder() }
            }
        }

        bubbleView?.setOnTouchListener { _, event ->
            if (velocityTracker == null) velocityTracker = VelocityTracker.obtain()
            velocityTracker?.addMovement(event)

            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    initialX = bubbleParams.x; initialY = bubbleParams.y
                    initialTouchX = event.rawX; initialTouchY = event.rawY
                    isDrag = false
                    isLongPressHandled = false
                    handler.postDelayed(bubbleLongPressRunnable, 600)
                    true
                }
                MotionEvent.ACTION_MOVE -> {
                    if (abs(event.rawX - initialTouchX) > 10 || abs(event.rawY - initialTouchY) > 10) {
                        isDrag = true
                        handler.removeCallbacks(bubbleLongPressRunnable)
                        bubbleParams.x = initialX + (event.rawX - initialTouchX).toInt()
                        bubbleParams.y = initialY + (event.rawY - initialTouchY).toInt()
                        windowManager?.updateViewLayout(bubbleView, bubbleParams)
                    }
                    true
                }
                MotionEvent.ACTION_UP -> {
                    handler.removeCallbacks(bubbleLongPressRunnable)
                    velocityTracker?.computeCurrentVelocity(1000)
                    val vX = velocityTracker?.xVelocity ?: 0f
                    val vY = velocityTracker?.yVelocity ?: 0f
                    val totalVel = kotlin.math.hypot(vX.toDouble(), vY.toDouble())

                    // [SAFETY] FLING RESET: Easier threshold (1500) + Full Recovery
                    if (isDrag && totalVel > 1500) {
                        showToast("Force Closing Trackpad...")

                        // 1. Force Screen ON & Unblock Keyboard
                        isScreenOff = false
                        Thread {
                            try { shellService?.setBrightness(128) } catch (e: Exception) {}
                            try { shellService?.setScreenOff(0, false) } catch (e: Exception) {}
                        }.start()
                        setSoftKeyboardBlocking(false)
                        if (Build.VERSION.SDK_INT >= 24) {
                            try { softKeyboardController.showMode = AccessibilityService.SHOW_MODE_AUTO } catch(e: Exception){}
                        }

                        // 2. Kill Process
                        forceExit() // This handles cleanup and kill

                        velocityTracker?.recycle()
                        velocityTracker = null
                        return@setOnTouchListener true
                    }

                    if (!isDrag && !isLongPressHandled) {
                        handleBubbleTap()
                    } else if (isDrag) {
                        prefs.prefBubbleX = bubbleParams.x
                        prefs.prefBubbleY = bubbleParams.y
                        savePrefs()
                    }
                    velocityTracker?.recycle()
                    velocityTracker = null
                    handler.post { enforceZOrder() }
                    true
                }
                MotionEvent.ACTION_CANCEL -> {
                    handler.removeCallbacks(bubbleLongPressRunnable)
                    velocityTracker?.recycle()
                    velocityTracker = null
                    false
                }
                else -> false
            }
        }
        windowManager?.addView(bubbleView, bubbleParams); updateBubbleStatus()
        applyBubbleAppearance()
    }
    
    private fun setupTrackpad(context: Context) {
        trackpadLayout = FrameLayout(context)
        val bg = GradientDrawable(); bg.cornerRadius = 30f; bg.setColor(Color.TRANSPARENT); trackpadLayout?.background = bg
        val handleColor = 0x15FFFFFF.toInt(); handleContainers.clear(); handleVisuals.clear()
        addHandle(context, Gravity.TOP or Gravity.RIGHT, handleColor) { _, e -> moveWindow(e) }
        addHandle(context, Gravity.BOTTOM or Gravity.RIGHT, handleColor) { _, e -> resizeWindow(e) }
        addHandle(context, Gravity.TOP or Gravity.LEFT, handleColor) { _, e -> keyboardHandle(e) }
        addHandle(context, Gravity.BOTTOM or Gravity.LEFT, handleColor) { _, e -> openMenuHandle(e) }
        addScrollBars(context)
        debugTextView = TextView(context); debugTextView?.text = "DEBUG"; debugTextView?.setTextColor(Color.YELLOW); debugTextView?.setBackgroundColor(0xAA000000.toInt()); debugTextView?.textSize = 9f; debugTextView?.visibility = View.GONE; val debugParams = FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT); debugParams.gravity = Gravity.CENTER; trackpadLayout?.addView(debugTextView, debugParams)
        
        trackpadParams = WindowManager.LayoutParams(
            400, 300, 
            WindowManager.LayoutParams.TYPE_ACCESSIBILITY_OVERLAY, 
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or 
            WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL or 
            WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS or 
            WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH, 
            PixelFormat.TRANSLUCENT
        )
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
             trackpadParams.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES
        }

        trackpadParams.gravity = Gravity.TOP or Gravity.LEFT; loadLayout()
        val gestureDetector = GestureDetector(context, object : GestureDetector.SimpleOnGestureListener() { 
            override fun onSingleTapConfirmed(e: MotionEvent): Boolean { return false }
        })
        
        // =================================================================================
        // TRACKPAD TOUCH LISTENER
        // SUMMARY: Handles all touch events on the trackpad area. Filters for finger-only
        //          input, passes to gesture detector, and calls handleTrackpadTouch for
        //          cursor movement. Also checks for spacebar extended mode exit.
        // =================================================================================
        trackpadLayout?.setOnTouchListener { _, event ->
            val devId = event.deviceId
            val tool = event.getToolType(0)
            
            // Only accept finger touches (not mouse, stylus, etc.)
            if (tool != MotionEvent.TOOL_TYPE_FINGER) return@setOnTouchListener false
            
            // Track active finger to prevent ghost touches
            when (event.actionMasked) {
                MotionEvent.ACTION_DOWN -> activeFingerDeviceId = devId
                MotionEvent.ACTION_MOVE, MotionEvent.ACTION_UP -> {
                    if (activeFingerDeviceId > 0 && devId != activeFingerDeviceId) {
                        return@setOnTouchListener false
                    }
                }
            }
            
            // Check for spacebar mouse extended mode exit (on tap outside keyboard)
            handleSpacebarExtendedModeCheck(event.rawX, event.rawY, event.action)
            
            // Pass to gesture detector for tap detection
            gestureDetector.onTouchEvent(event)
            
            // CRITICAL: Handle trackpad touch for cursor movement
            handleTrackpadTouch(event)
            
            true
        }
        // =================================================================================
        // END BLOCK: TRACKPAD TOUCH LISTENER
        // =================================================================================
        trackpadLayout?.visibility = if (isTrackpadVisible) View.VISIBLE else View.GONE
        windowManager?.addView(trackpadLayout, trackpadParams)
        updateBorderColor(currentBorderColor)
    }
    
    private fun setupCursor(context: Context) {
        cursorLayout = FrameLayout(context); cursorView = ImageView(context); cursorView?.setImageResource(R.drawable.ic_cursor); val size = if (prefs.prefCursorSize > 0) prefs.prefCursorSize else 50; cursorLayout?.addView(cursorView, FrameLayout.LayoutParams(size, size))
        cursorParams = WindowManager.LayoutParams(
            WindowManager.LayoutParams.WRAP_CONTENT, 
            WindowManager.LayoutParams.WRAP_CONTENT, 
            WindowManager.LayoutParams.TYPE_ACCESSIBILITY_OVERLAY, 
            WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or 
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or 
            WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or 
            WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,
            PixelFormat.TRANSLUCENT
        )
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
             cursorParams.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES
        }
        cursorParams.gravity = Gravity.TOP or Gravity.LEFT; cursorParams.x = uiScreenWidth / 2; cursorParams.y = uiScreenHeight / 2; windowManager?.addView(cursorLayout, cursorParams)
    }

    fun toggleTrackpad() { 
        isTrackpadVisible = !isTrackpadVisible
        
        // Toggle Visibility
        trackpadLayout?.visibility = if (isTrackpadVisible) View.VISIBLE else View.GONE
        
        // Update Border if showing
        if (isTrackpadVisible) {
            updateBorderColor(currentBorderColor) 
        }
        
        // PREVIOUSLY: else if (isCustomKeyboardVisible) toggleCustomKeyboard(...)
        // We removed that line so the keyboard stays open.
    }
    
    // NEW FUNCTION: Toggles the visibility of the trackpad menu drawer
    private fun toggleDrawer() {
        menuManager?.toggle()
        enforceZOrder() // Ensure drawer is on top
    }
    
    private fun handleBubbleTap() {
        val anythingVisible = isTrackpadVisible || isCustomKeyboardVisible
        if (anythingVisible) {
            performSmartHide()
        } else {
            performSmartRestore()
        }
    }
    
    private fun executeHardkeyAction(actionId: String, keyEventAction: Int = KeyEvent.ACTION_UP) {
        val isUp = (keyEventAction == KeyEvent.ACTION_UP)
        when (actionId) {
            "none" -> { }
            "left_click" -> {
                if (keyEventAction == KeyEvent.ACTION_DOWN) {
                    if (!volUpDragActive) { volUpDragActive = true; startKeyDrag(MotionEvent.BUTTON_PRIMARY) }
                } else {
                    if (volUpDragActive) { volUpDragActive = false; stopKeyDrag(MotionEvent.BUTTON_PRIMARY) } 
                    else performClick(false)
                }
            }
            "right_click" -> {
                 if (keyEventAction == KeyEvent.ACTION_DOWN) {
                    if (!volDownDragActive) { volDownDragActive = true; startKeyDrag(MotionEvent.BUTTON_SECONDARY) }
                } else {
                    if (volDownDragActive) { volDownDragActive = false; stopKeyDrag(MotionEvent.BUTTON_SECONDARY) } 
                    else performClick(true)
                }
            }
            "action_back" -> if (isUp) Thread { try { injectKey(KeyEvent.KEYCODE_BACK, KeyEvent.ACTION_DOWN); Thread.sleep(20); injectKey(KeyEvent.KEYCODE_BACK, KeyEvent.ACTION_UP) } catch(e: Exception){} }.start()
            "action_home" -> if (isUp) Thread { try { injectKey(KeyEvent.KEYCODE_HOME, KeyEvent.ACTION_DOWN); Thread.sleep(20); injectKey(KeyEvent.KEYCODE_HOME, KeyEvent.ACTION_UP) } catch(e: Exception){} }.start()
            "action_forward" -> if (isUp) Thread { try { injectKey(KeyEvent.KEYCODE_FORWARD, KeyEvent.ACTION_DOWN); Thread.sleep(20); injectKey(KeyEvent.KEYCODE_FORWARD, KeyEvent.ACTION_UP) } catch(e: Exception){} }.start()
            "action_vol_up" -> if (isUp) Thread { try { injectKey(KeyEvent.KEYCODE_VOLUME_UP, KeyEvent.ACTION_DOWN); Thread.sleep(20); injectKey(KeyEvent.KEYCODE_VOLUME_UP, KeyEvent.ACTION_UP) } catch(e: Exception){} }.start()
            "action_vol_down" -> if (isUp) Thread { try { injectKey(KeyEvent.KEYCODE_VOLUME_DOWN, KeyEvent.ACTION_DOWN); Thread.sleep(20); injectKey(KeyEvent.KEYCODE_VOLUME_DOWN, KeyEvent.ACTION_UP) } catch(e: Exception){} }.start()
            "scroll_up" -> if (isUp) performSwipe(0f, -(BASE_SWIPE_DISTANCE * prefs.scrollSpeed))
            "scroll_down" -> if (isUp) performSwipe(0f, BASE_SWIPE_DISTANCE * prefs.scrollSpeed)
            "display_toggle" -> if (isUp) {
                if (prefs.displayOffMode == "standard") {
                    isScreenOff = !isScreenOff
                    Thread { try { if (isScreenOff) shellService?.setScreenOff(0, true) else shellService?.setScreenOff(0, false) } catch (e: Exception) {} }.start()
                    showToast("Display ${if(isScreenOff) "Off" else "On"} (Std)")
                } else {
                    isScreenOff = !isScreenOff
                    Thread { try { if (isScreenOff) shellService?.setBrightness(-1) else shellService?.setBrightness(128) } catch (e: Exception) {} }.start()
                    showToast("Display ${if(isScreenOff) "Off" else "On"} (Alt)")
                }
            }
            "display_toggle_alt" -> if (isUp) {
                isScreenOff = !isScreenOff
                Thread { try { if (isScreenOff) shellService?.setBrightness(-1) else shellService?.setBrightness(128) } catch (e: Exception) {} }.start()
                showToast("Display ${if(isScreenOff) "Off" else "On"} (Alt)")
            }
            "display_toggle_std" -> if (isUp) {
                isScreenOff = !isScreenOff
                Thread { try { if (isScreenOff) shellService?.setScreenOff(0, true) else shellService?.setScreenOff(0, false) } catch (e: Exception) {} }.start()
                showToast("Display ${if(isScreenOff) "Off" else "On"} (Std)")
            }
            "alt_position" -> if (isUp) toggleKeyboardMode()
            "toggle_keyboard" -> if (isUp) toggleCustomKeyboard()
            "toggle_trackpad" -> if (isUp) toggleTrackpad()
            "open_menu" -> if (isUp) menuManager?.toggle()
            "reset_cursor" -> if (isUp) resetCursorCenter()
            "display_wake" -> if (isUp && isScreenOff) { isScreenOff = false; Thread { try { shellService?.setBrightness(128); shellService?.setScreenOff(0, false) } catch (e: Exception) {} }.start(); showToast("Display Woken") }
            
            // "Launcher Bubble" Keybind Action - Force Toggle/Swap
            "toggle_bubble" -> if (isUp) {
                // Simply toggle between 0 and 1. 
                // If we are on 1, go to 0. If on 0, go to 1.
                // This guarantees movement if the user presses it.
                val targetId = if (currentDisplayId == 0) 1 else 0
                
                try {
                    showToast("Force Switch to $targetId")
                    setupUI(targetId)
                    resetBubblePosition()
                    menuManager?.show()
                    enforceZOrder()
                } catch (e: Exception) {
                    showToast("Error: ${e.message}")
                }
            }
        }
    }

    fun toggleKeyboardMode() { vibrate(); if (!isKeyboardMode) { isKeyboardMode = true; savedWindowX = trackpadParams.x; savedWindowY = trackpadParams.y; trackpadParams.x = uiScreenWidth - trackpadParams.width; trackpadParams.y = 0; windowManager?.updateViewLayout(trackpadLayout, trackpadParams); updateBorderColor(0xFFFF0000.toInt()) } else { isKeyboardMode = false; trackpadParams.x = savedWindowX; trackpadParams.y = savedWindowY; windowManager?.updateViewLayout(trackpadLayout, trackpadParams); updateBorderColor(currentBorderColor) } }
    
    // [SAFETY] Emergency Reset (Panic Button)
    // Triggered by tapping Volume Up 5 times rapidly
    private fun performEmergencyReset() {
        // Long Vibration Pattern (SOS-ish)
        val v = getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
        if (Build.VERSION.SDK_INT >= 26) {
            v.vibrate(VibrationEffect.createWaveform(longArrayOf(0, 100, 100, 100, 100, 500), -1))
        } else {
            @Suppress("DEPRECATION") v.vibrate(500)
        }

        showToast("!!! EMERGENCY RESET TRIGGERED !!!")
        Log.w(TAG, "EMERGENCY RESET TRIGGERED BY HARDWARE KEYS")

        // 1. Force Screen ON
        isScreenOff = false
        Thread {
            try { shellService?.setBrightness(128) } catch (e: Exception) {}
            try { shellService?.setScreenOff(0, false) } catch (e: Exception) {}
        }.start()

        // 2. Unblock Keyboard (Force Gboard/System default)
        setSoftKeyboardBlocking(false)
        if (Build.VERSION.SDK_INT >= 24) {
            try { softKeyboardController.showMode = AccessibilityService.SHOW_MODE_AUTO } catch(e: Exception){}
        }

        // 3. Reset Overlays
        resetTrackpadPosition()
        keyboardOverlay?.resetPosition()
        resetBubblePosition()

        // 4. Disable Virtual Modes
        if (prefs.prefVirtualMirrorMode) {
            toggleVirtualMirrorMode() // This turns it OFF
        }

        // 5. Release Locks (handled by system on exit)
    }

    // [FIX] Public so MenuManager can call it
    fun toggleDebugMode() {
        isDebugMode = !isDebugMode
        if (isDebugMode) { 
            showToast("Debug ON")
            updateBorderColor(0xFFFFFF00.toInt())
            debugTextView?.visibility = View.VISIBLE 
        } else { 
            showToast("Debug OFF")
            if (inputTargetDisplayId != currentDisplayId) updateBorderColor(0xFFFF00FF.toInt()) else updateBorderColor(0x55FFFFFF.toInt())
            debugTextView?.visibility = View.GONE 
        } 
    }

    fun updateBubbleStatus() { val dot = bubbleView?.findViewById<ImageView>(R.id.status_dot); if (shellService != null) dot?.visibility = View.GONE else dot?.visibility = View.VISIBLE }

    private val bubbleIcons = arrayOf(R.mipmap.ic_trackpad_adaptive, R.drawable.ic_cursor, R.drawable.ic_tab_main, R.drawable.ic_tab_keyboard, android.R.drawable.ic_menu_compass, android.R.drawable.ic_menu_myplaces)
    
    fun updateBubbleSize(sizePercent: Int) { prefs.prefBubbleSize = sizePercent.coerceIn(50, 200); applyBubbleAppearance(); savePrefs() }
    fun updateBubbleIcon(index: Int) { prefs.prefBubbleIconIndex = index.coerceIn(0, bubbleIcons.size - 1); applyBubbleAppearance(); savePrefs() }
    fun cycleBubbleIcon() { updateBubbleIcon((prefs.prefBubbleIconIndex + 1) % bubbleIcons.size) }
    fun updateBubbleAlpha(alpha: Int) { prefs.prefBubbleAlpha = alpha.coerceIn(50, 255); applyBubbleAppearance(); savePrefs() }
    
    private fun applyBubbleAppearance() {
        if (bubbleView == null) return
        val scale = prefs.prefBubbleSize / 100f
        val density = resources.displayMetrics.density
        bubbleParams.width = (60 * scale * density).toInt()
        bubbleParams.height = (60 * scale * density).toInt()
        try { windowManager?.updateViewLayout(bubbleView, bubbleParams) } catch (e: Exception) {}
        val iconView = bubbleView?.findViewById<ImageView>(R.id.bubble_icon)
        iconView?.let {
            val iconParams = it.layoutParams as? FrameLayout.LayoutParams
            iconParams?.gravity = Gravity.CENTER
            iconParams?.width = (40 * scale * density).toInt()
            iconParams?.height = (40 * scale * density).toInt()
            it.layoutParams = iconParams
            it.setImageResource(bubbleIcons.getOrElse(prefs.prefBubbleIconIndex) { bubbleIcons[0] })
            it.alpha = prefs.prefBubbleAlpha / 255f
        }
        bubbleView?.alpha = prefs.prefBubbleAlpha / 255f
    }

    fun forceMoveToCurrentDisplay() { setupUI(currentDisplayId) }
    fun forceMoveToDisplay(displayId: Int) { if (displayId == currentDisplayId) return; setupUI(displayId) }
    fun hideApp() { menuManager?.hide(); if (isTrackpadVisible) toggleTrackpad() }


    // =================================================================================
    // INTER-APP COMMUNICATION HELPER FUNCTIONS
    // SUMMARY: Functions to support commands from DroidOS Launcher or ADB.
    //          These enable coordinated display switching and z-order management.
    // =================================================================================
    
    /**
     * Moves overlay to virtual display and enables Virtual Mirror Mode.
     * Called by MOVE_TO_VIRTUAL broadcast from Launcher or ADB.
     */
    private fun moveToVirtualDisplayAndEnableMirror(virtualDisplayId: Int) {
        try {
            Log.d(TAG, "Moving to virtual display $virtualDisplayId and enabling mirror mode")
            
            // Store current state for potential return
            preMirrorTrackpadVisible = isTrackpadVisible
            preMirrorKeyboardVisible = isCustomKeyboardVisible
            preMirrorTargetDisplayId = inputTargetDisplayId
            
            // Move UI to virtual display
            setupUI(virtualDisplayId)
            
            // Enable Virtual Mirror Mode
            if (!prefs.prefVirtualMirrorMode) {
                prefs.prefVirtualMirrorMode = true
                savePrefs()
            }
            
            // Set input target to virtual display
            inputTargetDisplayId = virtualDisplayId
            updateTargetMetrics(virtualDisplayId)
            
            // Show trackpad and keyboard
            if (!isTrackpadVisible) toggleTrackpad()
            if (!isCustomKeyboardVisible) toggleCustomKeyboard()
            
            // Create mirror keyboard on virtual display
            createMirrorKeyboard(virtualDisplayId)
            createRemoteCursor(virtualDisplayId)
            
            // Update visual indicators
            updateBorderColor(0xFFFF00FF.toInt()) // Purple for remote mode
            updateWakeLockState()
            
            showToast("Virtual Display Mode Active")
            
        } catch (e: Exception) {
            Log.e(TAG, "Failed to move to virtual display", e)
            showToast("Error: ${e.message}")
        }
    }
    
    /**
     * Returns overlay to physical display and disables Virtual Mirror Mode.
     * Called by RETURN_TO_PHYSICAL broadcast from Launcher or ADB.
     */
    private fun returnToPhysicalDisplay(physicalDisplayId: Int) {
        try {
            Log.d(TAG, "Returning to physical display $physicalDisplayId")
            
            // Disable Virtual Mirror Mode
            if (prefs.prefVirtualMirrorMode) {
                prefs.prefVirtualMirrorMode = false
                savePrefs()
            }
            
            // Remove remote cursor and mirror keyboard
            removeRemoteCursor()
            removeMirrorKeyboard()
            
            // Move UI to physical display
            setupUI(physicalDisplayId)
            
            // Reset input target to local
            inputTargetDisplayId = physicalDisplayId
            cursorX = uiScreenWidth / 2f
            cursorY = uiScreenHeight / 2f
            cursorParams.x = cursorX.toInt()
            cursorParams.y = cursorY.toInt()
            try { windowManager?.updateViewLayout(cursorLayout, cursorParams) } catch(e: Exception){}
            cursorView?.visibility = View.VISIBLE
            
            // Update visual indicators
            updateBorderColor(0x55FFFFFF.toInt()) // Default for local mode
            releaseDisplayWakeLock()
            
            showToast("Returned to Physical Display")
            
        } catch (e: Exception) {
            Log.e(TAG, "Failed to return to physical display", e)
            showToast("Error: ${e.message}")
        }
    }
    // =================================================================================
    // END BLOCK: INTER-APP COMMUNICATION HELPER FUNCTIONS
    // =================================================================================

    


    // =================================================================================
    // PROFILE KEY GENERATION
    // SUMMARY: Generates a unique key based on Resolution + Mirror Mode State.
    //          Allows separate profiles for "Standard" and "Mirror" modes.
    // =================================================================================
    fun getProfileKey(): String {
        val mode = if (prefs.prefVirtualMirrorMode) "MIRROR" else "STD"
        return "P_${uiScreenWidth}_${uiScreenHeight}_$mode"
    }

    fun getSavedProfileList(): List<String> {

        val p = getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
        val allKeys = p.all.keys
        val profiles = java.util.HashSet<String>()
        
        // Regex matches: X_P_{width}_{height}_{suffix}
        // Group 1: Width
        // Group 2: Height
        // Group 3: Optional Suffix (MIRROR or STD)
        val regex = Regex("X_P_(\\d+)_(\\d+)(?:_([A-Z]+))?")
        
        for (key in allKeys) { 
            // We only care about X position keys to identify a profile exists
            if (!key.startsWith("X_P_")) continue

            val match = regex.matchEntire(key)
            if (match != null) {
                val w = match.groupValues[1]
                val h = match.groupValues[2]
                val suffix = match.groupValues.getOrNull(3) // Can be null, STD, or MIRROR
                
                var displayLabel = "$w x $h"
                
                // If it is a Mirror Profile, append VM
                if (suffix == "MIRROR") {
                    displayLabel += " VM"
                }
                
                profiles.add(displayLabel)
            }
        }
        return profiles.sorted()
    }








    private fun scheduleRestart() {
        try {
            // Keep the Smart Display Logic (it's safe to keep)
            var restartDisplayId = currentDisplayId
            try {
                val d0 = displayManager?.getDisplay(0)
                if (d0 != null && d0.state == Display.STATE_OFF) {
                     val d1 = displayManager?.getDisplay(1)
                     if (d1 != null && d1.state == Display.STATE_ON) {
                         restartDisplayId = 1
                     }
                }
            } catch(e: Exception) {}

            Log.i(TAG, ">>> SCHEDULING RESTART (SERVICE) | Display: $restartDisplayId <<<")
            
            // [FIX] Target the SERVICE directly, not the Activity.
            // This bypasses the "Background Activity Start" restriction that was blocking the restart.
            val restartIntent = Intent(applicationContext, OverlayService::class.java)
            restartIntent.putExtra("displayId", restartDisplayId)
            restartIntent.putExtra("force_start", true)
            restartIntent.putExtra("IS_RESTART", true)
            
            val flags = if (Build.VERSION.SDK_INT >= 23) 
                android.app.PendingIntent.FLAG_ONE_SHOT or android.app.PendingIntent.FLAG_IMMUTABLE or android.app.PendingIntent.FLAG_UPDATE_CURRENT
            else 
                android.app.PendingIntent.FLAG_ONE_SHOT or android.app.PendingIntent.FLAG_UPDATE_CURRENT

            // [FIX] Use getForegroundService (or getService) instead of getActivity
            val pendingIntent = if (Build.VERSION.SDK_INT >= 26) {
                android.app.PendingIntent.getForegroundService(applicationContext, 1, restartIntent, flags)
            } else {
                android.app.PendingIntent.getService(applicationContext, 1, restartIntent, flags)
            }
            
            val alarmManager = getSystemService(Context.ALARM_SERVICE) as android.app.AlarmManager
            val triggerTime = System.currentTimeMillis() + 800

            try {
                if (Build.VERSION.SDK_INT >= 23) {
                     alarmManager.setExactAndAllowWhileIdle(android.app.AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent)
                } else {
                     alarmManager.setExact(android.app.AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent)
                }
            } catch (e: SecurityException) {
                Log.w(TAG, "Exact Alarm permission missing, using standard alarm")
                alarmManager.set(android.app.AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to schedule restart", e)
        }
    }







    override fun onTaskRemoved(rootIntent: Intent?) {
        super.onTaskRemoved(rootIntent)
        // [Fixed] If Keep Alive is ON, schedule restart BEFORE system kills us.
        // Many ROMs force-kill services on swipe, so we must register the alarm now.
        if (prefs.prefPersistentService) {
            scheduleRestart()
            // We do NOT call forceExit() here; we let the system decide if it wants to kill us.
            // If it does kill us, the alarm brings us back.
        } else {
            forceExit()
        }
    }

    fun forceExit() {
        Log.i(TAG, "forceExit called. Persistent: ${prefs.prefPersistentService}")
        try {
            removeOldViews()
            
            if (prefs.prefPersistentService) {
                // KEEP ALIVE ON: Schedule restart and kill process (Auto-Restart)
                scheduleRestart()
                killProcessAndExit()
            } else {
                // KEEP ALIVE OFF: Disable service completely (Terminate)
                // This stops the service and prevents auto-restart by the system
                if (Build.VERSION.SDK_INT >= 24) {
                    disableSelf()
                } else {
                    stopSelf()
                }
                // Optional: Kill process to ensure clean slate
                handler.postDelayed({ 
                    Process.killProcess(Process.myPid()) 
                    System.exit(0)
                }, 100)
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    // Helper for Soft Restart and Keep-Alive kills
    private fun killProcessAndExit() {
        stopSelf()
        try { Thread.sleep(200) } catch(e: Exception){}
        Process.killProcess(Process.myPid())
        System.exit(0)
    }
    // =================================================================================
    // FUNCTION: syncMirrorWithPhysicalKeyboard
    // SUMMARY: Updates mirror keyboard dimensions to match physical keyboard.
    //          Called when physical keyboard is resized/moved.
    // =================================================================================
    fun syncMirrorWithPhysicalKeyboard() {
        if (!prefs.prefVirtualMirrorMode || mirrorKeyboardView == null) return
        
        // Update coordinate scaling variables
        physicalKbWidth = keyboardOverlay?.getViewWidth()?.toFloat() ?: 600f
        physicalKbHeight = keyboardOverlay?.getViewHeight()?.toFloat() ?: 400f
        
        Log.d(TAG, "Mirror sync: Physical KB now ${physicalKbWidth}x${physicalKbHeight}")
        
        // If mirror has custom size, keep it. Otherwise, could auto-scale here.
        // For now, just update the scaling ratios used for touch coordinate mapping.
    }
    // =================================================================================
    // END BLOCK: syncMirrorWithPhysicalKeyboard
    // =================================================================================
    
    fun manualAdjust(isKeyboard: Boolean, isResize: Boolean, dx: Int, dy: Int) { 
        if (isKeyboard) { 
            if (isResize) keyboardOverlay?.resizeWindow(dx, dy) else keyboardOverlay?.moveWindow(dx, dy)
            // Sync mirror keyboard with physical keyboard changes
            syncMirrorWithPhysicalKeyboard()
        } 
        else { 
            if (trackpadLayout == null) return
            if (isResize) { trackpadParams.width = max(200, trackpadParams.width + dx); trackpadParams.height = max(200, trackpadParams.height + dy) } 
            { trackpadParams.x += dx; trackpadParams.y += dy }
            try { windowManager?.updateViewLayout(trackpadLayout, trackpadParams) } catch (e: Exception) {}; saveLayout() 
        } 
    }
    
    private fun parseBoolean(value: Any): Boolean { return when(value) { is Boolean -> value; is Int -> value == 1; is String -> value == "1" || value.equals("true", ignoreCase = true); else -> false } }
    
    fun updatePref(key: String, value: Any) { 
        when(key) { 
            "cursor_speed" -> prefs.cursorSpeed = (value as? Float) ?: 2.5f
            "scroll_speed" -> prefs.scrollSpeed = (value as? Float) ?: 1.0f
            "tap_scroll" -> prefs.prefTapScroll = parseBoolean(value)
            "vibrate" -> prefs.prefVibrate = parseBoolean(value)
            "reverse_scroll" -> prefs.prefReverseScroll = parseBoolean(value)
            "alpha" -> { prefs.prefAlpha = value as Int; updateBorderColor(currentBorderColor) }
            "bg_alpha" -> { prefs.prefBgAlpha = value as Int; updateBorderColor(currentBorderColor) }
            "handle_size" -> { prefs.prefHandleSize = value as Int; updateHandleSize() }
            "scroll_size" -> { prefs.prefScrollTouchSize = value as Int; updateScrollSize() }
            "scroll_visual" -> { prefs.prefScrollVisualSize = value as Int; updateScrollSize() }
            "cursor_size" -> { prefs.prefCursorSize = value as Int; updateCursorSize() }
"anchored" -> { prefs.prefAnchored = parseBoolean(value); keyboardOverlay?.setAnchored(prefs.prefAnchored) }            "automation_enabled" -> prefs.prefAutomationEnabled = parseBoolean(value)
            "bubble_size" -> updateBubbleSize(value as Int)
            "bubble_icon" -> cycleBubbleIcon()
            "bubble_alpha" -> updateBubbleAlpha(value as Int)
            "persistent_service" -> prefs.prefPersistentService = parseBoolean(value)
            "block_soft_kb" -> { 
                prefs.prefBlockSoftKeyboard = parseBoolean(value)
                // Only activate blocking if on cover screen (display 1)
                if (currentDisplayId == 1) {
                    setSoftKeyboardBlocking(prefs.prefBlockSoftKeyboard)
                } else if (prefs.prefBlockSoftKeyboard) {
                    showToast("KB Blocker saved - will activate on cover screen")
                }
            }
            "prediction_aggression" -> { 
                prefs.prefPredictionAggression = (value as? Float) ?: 0.8f
                // Apply immediately to Engine
                PredictionEngine.instance.speedThreshold = prefs.prefPredictionAggression
            }
            // =================================================================================
            // SPACEBAR MOUSE EXTENDED MODE UPDATE
            // =================================================================================
            "spacebar_mouse_extended" -> { 
                prefs.prefSpacebarMouseExtended = parseBoolean(value)
                keyboardOverlay?.getKeyboardView()?.setSpacebarExtendedMode(prefs.prefSpacebarMouseExtended)
                savePrefs()
            }
            // =================================================================================
            // END BLOCK: SPACEBAR MOUSE EXTENDED MODE UPDATE
            // =================================================================================
            "keyboard_alpha" -> { prefs.prefKeyboardAlpha = value as Int; keyboardOverlay?.updateAlpha(prefs.prefKeyboardAlpha) }

            "hardkey_vol_up_tap" -> prefs.hardkeyVolUpTap = value as String
            "hardkey_vol_up_double" -> prefs.hardkeyVolUpDouble = value as String
            "hardkey_vol_up_hold" -> prefs.hardkeyVolUpHold = value as String
            "hardkey_vol_down_tap" -> prefs.hardkeyVolDownTap = value as String
            "hardkey_vol_down_double" -> prefs.hardkeyVolDownDouble = value as String
            "hardkey_vol_down_hold" -> prefs.hardkeyVolDownHold = value as String
            "double_tap_ms" -> prefs.doubleTapMs = value as Int
            "hold_duration_ms" -> prefs.holdDurationMs = value as Int
            "mirror_alpha" -> {
                val v = value as Int
                prefs.prefMirrorAlpha = v
                // Apply to BOTH container and keyboard view
                val alpha = v / 255f
                mirrorKeyboardContainer?.alpha = alpha
                mirrorKeyboardView?.alpha = alpha
            }
            "mirror_orient_delay" -> {
                prefs.prefMirrorOrientDelayMs = value as Long
            }
            // =================================================================================
            // VIRTUAL MIRROR MODE UPDATE HANDLERS
            // =================================================================================
            "virtual_mirror_mode" -> {
                prefs.prefVirtualMirrorMode = parseBoolean(value)
                updateVirtualMirrorMode()
            }
            "mirror_orient_delay_ms" -> prefs.prefMirrorOrientDelayMs = (value as? Long) ?: 1000L
            // =================================================================================
            // END BLOCK: VIRTUAL MIRROR MODE UPDATE HANDLERS
            // =================================================================================
            "override_system_shortcuts" -> {
                prefs.prefOverrideSystemShortcuts = parseBoolean(value)
                keyboardOverlay?.setOverrideSystemShortcuts(prefs.prefOverrideSystemShortcuts)
                // Sync launcher blocked shortcuts to keyboard
                keyboardOverlay?.setLauncherBlockedShortcuts(launcherBlockedShortcuts)
            }
        }
        savePrefs() 
    }
    
// =================================================================================
    // FUNCTION: applyDockMode
    // SUMMARY: Snaps the overlay keyboard to the bottom of the screen, full width.
    //          Used when "Dock KB to Bottom" is enabled in Dock IME popup.
    // =================================================================================
    private fun applyDockMode() {
        if (keyboardOverlay == null) initCustomKeyboard()
        if (!isCustomKeyboardVisible) {
            keyboardOverlay?.show()
            isCustomKeyboardVisible = true
        }
        
        val density = resources.displayMetrics.density
        val screenWidth = uiScreenWidth
        val screenHeight = uiScreenHeight
        
        // Get current keyboard height or use default
        val kbHeight = keyboardOverlay?.getViewHeight() ?: ((275f * (prefs.prefKeyScale / 100f) * density).toInt())
        
        // Position at bottom, full width (100%)
        val targetW = screenWidth
        val targetY = screenHeight - kbHeight
        
        keyboardOverlay?.setWindowBounds(0, targetY, targetW, kbHeight)
        
        // Save keyboard height for Dock IME auto-resize feature
        saveKeyboardHeightForDock(kbHeight)
        
        android.util.Log.d(TAG, "applyDockMode: x=0, y=$targetY, w=$targetW, h=$kbHeight")
        showToast("Keyboard docked to bottom")
    }
    
    // =================================================================================
    // FUNCTION: saveKeyboardHeightForDock
    // SUMMARY: Saves the current keyboard height so Dock IME can use it for auto-resize.
    // =================================================================================
    private fun saveKeyboardHeightForDock(height: Int) {
        val key = "keyboard_height_d${currentDisplayId}"
        getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE).edit()
            .putInt(key, height)
            .apply()
        android.util.Log.d(TAG, "Saved keyboard height: $height for display $currentDisplayId")
    }
    // =================================================================================
    // END BLOCK: applyDockMode
    // =================================================================================

    fun applyLayoutPreset(type: Int) {


        if (type == 0) { loadLayout(); showToast("Freeform Profile Loaded"); return }
        val h = uiScreenHeight; val w = uiScreenWidth; val density = resources.displayMetrics.density
        val targetW = (w * 0.96f).toInt(); val marginX = (w - targetW) / 2
        // Added 20dp buffer to preset height calculation
        val kbHeight = ((275f * (prefs.prefKeyScale / 100f) * density) + (20 * density)).toInt().coerceAtMost((h * 0.6f).toInt())
        val tpHeight = h - kbHeight
        if (keyboardOverlay == null) initCustomKeyboard()
        if (!isCustomKeyboardVisible) toggleCustomKeyboard(suppressAutomation = true)
        if (!isTrackpadVisible) toggleTrackpad()
        prefs.prefScrollTouchSize = 80; prefs.prefScrollVisualSize = 8
        when(type) {
            1 -> { keyboardOverlay?.setWindowBounds(marginX, 0, targetW, kbHeight); trackpadParams.width = targetW; trackpadParams.height = tpHeight; trackpadParams.x = marginX; trackpadParams.y = kbHeight }
            2 -> { trackpadParams.width = targetW; trackpadParams.height = tpHeight; trackpadParams.x = marginX; trackpadParams.y = 0; keyboardOverlay?.setWindowBounds(marginX, tpHeight, targetW, kbHeight) }
        }
        try { windowManager?.updateViewLayout(trackpadLayout, trackpadParams) } catch(e: Exception){}
        updateScrollSize(); updateScrollPosition(); updateHandleSize(); updateLayoutSizes(); savePrefs(); showToast("Preset Applied")
    }
    
    fun resetBubblePosition() { bubbleParams.x = 50; bubbleParams.y = uiScreenHeight / 2; try { windowManager?.updateViewLayout(bubbleView, bubbleParams) } catch(e: Exception){}; prefs.prefBubbleX = bubbleParams.x; prefs.prefBubbleY = bubbleParams.y; savePrefs(); showToast("Bubble Reset") }

    private fun loadPrefs() { 
        val p = getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
        prefs.cursorSpeed = p.getFloat("cursor_speed", 2.5f)
        prefs.scrollSpeed = p.getFloat("scroll_speed", 0.6f) // CHANGED: Default 0.6f (Slider 6)
        prefs.prefTapScroll = p.getBoolean("tap_scroll", true)
        prefs.prefVibrate = p.getBoolean("vibrate", true)
        prefs.prefReverseScroll = p.getBoolean("reverse_scroll", false) // CHANGED: Default false
        prefs.prefAlpha = p.getInt("alpha", 50) // CHANGED: Default 50
        prefs.prefBgAlpha = p.getInt("bg_alpha", 220) // CHANGED: Default 220
        prefs.prefKeyboardAlpha = p.getInt("keyboard_alpha", 255) // CHANGED: Default 255
        prefs.prefHandleSize = p.getInt("handle_size", 14) // CHANGED: Default 14
        prefs.prefVPosLeft = p.getBoolean("v_pos_left", false)
        prefs.prefHPosTop = p.getBoolean("h_pos_top", false)
        prefs.prefAnchored = p.getBoolean("anchored", false)
        prefs.prefHandleTouchSize = p.getInt("handle_touch_size", 80)
        prefs.prefScrollTouchSize = p.getInt("scroll_touch_size", 80)
        prefs.prefScrollVisualSize = p.getInt("scroll_visual_size", 4)
                prefs.prefCursorSize = p.getInt("cursor_size", 50)
                prefs.prefKeyScale = p.getInt("keyboard_key_scale", 69) // Default 69 to match resetPosition
                prefs.prefUseAltScreenOff = p.getBoolean("use_alt_screen_off", true)
                prefs.prefAutomationEnabled = p.getBoolean("automation_enabled", false) 
                prefs.prefBubbleX = p.getInt("bubble_x", 50)
                prefs.prefBubbleY = p.getInt("bubble_y", 300)
                prefs.prefBubbleSize = p.getInt("bubble_size", 100)
                prefs.prefBubbleIconIndex = p.getInt("bubble_icon_index", 0)
                prefs.prefBubbleAlpha = p.getInt("bubble_alpha", 255)
                prefs.prefPersistentService = p.getBoolean("persistent_service", false)
                prefs.prefBlockSoftKeyboard = p.getBoolean("block_soft_kb", false)
                
                prefs.prefPredictionAggression = p.getFloat("prediction_aggression", 0.8f)
                // Apply to Engine on startup
                PredictionEngine.instance.speedThreshold = prefs.prefPredictionAggression

                // =================================================================================
                // SPACEBAR MOUSE EXTENDED MODE LOAD
                // =================================================================================
                prefs.prefSpacebarMouseExtended = p.getBoolean("spacebar_mouse_extended", false)
                // =================================================================================
                // END BLOCK: SPACEBAR MOUSE EXTENDED MODE LOAD
                // =================================================================================
                // Hardkey Defaults: Set to "none"
                prefs.hardkeyVolUpTap = p.getString("hardkey_vol_up_tap", "none") ?: "none"
                prefs.hardkeyVolUpDouble = p.getString("hardkey_vol_up_double", "none") ?: "none"
                prefs.hardkeyVolUpHold = p.getString("hardkey_vol_up_hold", "none") ?: "none"
                prefs.hardkeyVolDownTap = p.getString("hardkey_vol_down_tap", "none") ?: "none"
                prefs.hardkeyVolDownDouble = p.getString("hardkey_vol_down_double", "none") ?: "none"
                prefs.hardkeyVolDownHold = p.getString("hardkey_vol_down_hold", "none") ?: "none"
        prefs.hardkeyPowerDouble = p.getString("hardkey_power_double", "none") ?: "none"
        
        prefs.doubleTapMs = p.getInt("double_tap_ms", 300)
        prefs.holdDurationMs = p.getInt("hold_duration_ms", 400)

        // =================================================================================
        // VIRTUAL MIRROR MODE LOAD
        // =================================================================================
        // [Fixed] Always FORCE OFF on app restart/reload. Do not load saved state.
        prefs.prefVirtualMirrorMode = false

        prefs.prefOverrideSystemShortcuts = p.getBoolean("override_system_shortcuts", true)
        prefs.customModKey = p.getInt("custom_mod_key", 0)
        prefs.prefMirrorOrientDelayMs = p.getLong("mirror_orient_delay_ms", 1000L)

        // Load Mirror Keyboard Prefs
        prefs.prefMirrorAlpha = p.getInt("mirror_alpha", 200)
        prefs.prefMirrorX = p.getInt("mirror_x", -1)
        prefs.prefMirrorY = p.getInt("mirror_y", 0)
        prefs.prefMirrorWidth = p.getInt("mirror_width", -1)
        prefs.prefMirrorHeight = p.getInt("mirror_height", -1)
        // Note: No height pref, it's wrap_content
        // =================================================================================
        // END BLOCK: VIRTUAL MIRROR MODE LOAD
        // =================================================================================
    }
    


    fun saveLayout() {
        // 1. FETCH LIVE VALUES FROM PHYSICAL KEYBOARD
        val currentKbX = keyboardOverlay?.getViewX() ?: savedKbX
        val currentKbY = keyboardOverlay?.getViewY() ?: savedKbY
        val currentKbW = keyboardOverlay?.getViewWidth() ?: savedKbW
        val currentKbH = keyboardOverlay?.getViewHeight() ?: savedKbH
        
        // Fetch live scale
        val liveScale = keyboardOverlay?.getScale() ?: (prefs.prefKeyScale / 100f)
        prefs.prefKeyScale = (liveScale * 100).toInt()

        savedKbX = currentKbX; savedKbY = currentKbY; savedKbW = currentKbW; savedKbH = currentKbH

        // 2. SAVE TO SHARED PREFS (Using Mode-Specific Key)
        val p = getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE).edit()
        val key = getProfileKey() // Returns ..._STD or ..._MIRROR
        
        // Save Trackpad Window
        p.putInt("X_$key", trackpadParams.x)
        p.putInt("Y_$key", trackpadParams.y)
        p.putInt("W_$key", trackpadParams.width)
        p.putInt("H_$key", trackpadParams.height)

        // Save Settings String (Standard Settings)
        val settingsStr = StringBuilder()
        settingsStr.append("${prefs.cursorSpeed};${prefs.scrollSpeed};${if(prefs.prefTapScroll) 1 else 0};${if(prefs.prefReverseScroll) 1 else 0};${prefs.prefAlpha};${prefs.prefBgAlpha};${prefs.prefKeyboardAlpha};${prefs.prefHandleSize};${prefs.prefHandleTouchSize};${prefs.prefScrollTouchSize};${prefs.prefScrollVisualSize};${prefs.prefCursorSize};${prefs.prefKeyScale};${if(prefs.prefAutomationEnabled) 1 else 0};${if(prefs.prefAnchored) 1 else 0};${prefs.prefBubbleSize};${prefs.prefBubbleAlpha};${prefs.prefBubbleIconIndex};${prefs.prefBubbleX};${prefs.prefBubbleY};${prefs.hardkeyVolUpTap};${prefs.hardkeyVolUpDouble};${prefs.hardkeyVolUpHold};${prefs.hardkeyVolDownTap};${prefs.hardkeyVolDownDouble};${prefs.hardkeyVolDownHold};${prefs.hardkeyPowerDouble};")
        
        // New Settings (Vibrate, Position)
        settingsStr.append("${if(prefs.prefVibrate) 1 else 0};${if(prefs.prefVPosLeft) 1 else 0};${if(prefs.prefHPosTop) 1 else 0};")
        
        // Prediction Aggression
        settingsStr.append("${prefs.prefPredictionAggression};")

        // Physical Keyboard Bounds
        settingsStr.append("$currentKbX;$currentKbY;$currentKbW;$currentKbH")

        p.putString("SETTINGS_$key", settingsStr.toString())

        // [FIX] SAVE MIRROR KEYBOARD PARAMS (If in Mirror Mode)
        if (prefs.prefVirtualMirrorMode) {
            // Get live values from window params if available, otherwise use prefs
            val mX = mirrorKeyboardParams?.x ?: prefs.prefMirrorX
            val mY = mirrorKeyboardParams?.y ?: prefs.prefMirrorY
            val mW = mirrorKeyboardParams?.width ?: prefs.prefMirrorWidth
            val mH = mirrorKeyboardParams?.height ?: prefs.prefMirrorHeight
            val mAlpha = prefs.prefMirrorAlpha

            p.putInt("MIRROR_X_$key", mX)
            p.putInt("MIRROR_Y_$key", mY)
            p.putInt("MIRROR_W_$key", mW)
            p.putInt("MIRROR_H_$key", mH)
            p.putInt("MIRROR_ALPHA_$key", mAlpha)
        }

        p.apply()
        showToast("Layout Saved (${if(prefs.prefVirtualMirrorMode) "Mirror" else "Std"})")
    }


    private fun savePrefs() { 
        val e = getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE).edit()
        
        e.putFloat("cursor_speed", prefs.cursorSpeed)
        e.putFloat("scroll_speed", prefs.scrollSpeed)
        e.putBoolean("tap_scroll", prefs.prefTapScroll)
        e.putBoolean("vibrate", prefs.prefVibrate)
        e.putBoolean("reverse_scroll", prefs.prefReverseScroll)
        e.putInt("alpha", prefs.prefAlpha)
        e.putInt("bg_alpha", prefs.prefBgAlpha)
        e.putInt("keyboard_alpha", prefs.prefKeyboardAlpha)
        e.putInt("handle_size", prefs.prefHandleSize)
        e.putBoolean("v_pos_left", prefs.prefVPosLeft)
        e.putBoolean("h_pos_top", prefs.prefHPosTop)
        e.putBoolean("anchored", prefs.prefAnchored)
        e.putInt("handle_touch_size", prefs.prefHandleTouchSize)
        e.putInt("scroll_touch_size", prefs.prefScrollTouchSize)
        e.putInt("scroll_visual_size", prefs.prefScrollVisualSize)
        e.putInt("cursor_size", prefs.prefCursorSize)
        e.putInt("keyboard_key_scale", prefs.prefKeyScale)
        e.putBoolean("use_alt_screen_off", prefs.prefUseAltScreenOff)
        e.putBoolean("automation_enabled", prefs.prefAutomationEnabled)
        e.putInt("bubble_x", prefs.prefBubbleX)
        e.putInt("bubble_y", prefs.prefBubbleY)
        e.putInt("bubble_size", prefs.prefBubbleSize)
        e.putInt("bubble_icon_index", prefs.prefBubbleIconIndex)
        e.putInt("bubble_alpha", prefs.prefBubbleAlpha)
        
        e.putBoolean("persistent_service", prefs.prefPersistentService)
        e.putBoolean("block_soft_kb", prefs.prefBlockSoftKeyboard)
        e.putFloat("prediction_aggression", prefs.prefPredictionAggression)

        // =================================================================================
        // SPACEBAR MOUSE EXTENDED MODE SAVE
        // =================================================================================
        e.putBoolean("spacebar_mouse_extended", prefs.prefSpacebarMouseExtended)
        // =================================================================================
        // END BLOCK: SPACEBAR MOUSE EXTENDED MODE SAVE
        // =================================================================================
        
        e.putString("hardkey_vol_up_tap", prefs.hardkeyVolUpTap)
        e.putString("hardkey_vol_up_double", prefs.hardkeyVolUpDouble)
        e.putString("hardkey_vol_up_hold", prefs.hardkeyVolUpHold)
        e.putString("hardkey_vol_down_tap", prefs.hardkeyVolDownTap)
        e.putString("hardkey_vol_down_double", prefs.hardkeyVolDownDouble)
        e.putString("hardkey_vol_down_hold", prefs.hardkeyVolDownHold)
        e.putString("hardkey_power_double", prefs.hardkeyPowerDouble)
        
        e.putInt("double_tap_ms", prefs.doubleTapMs)
        e.putInt("hold_duration_ms", prefs.holdDurationMs)

        // =================================================================================
        // VIRTUAL MIRROR MODE SAVE
        // =================================================================================
        e.putBoolean("virtual_mirror_mode", prefs.prefVirtualMirrorMode)
        e.putLong("mirror_orient_delay_ms", prefs.prefMirrorOrientDelayMs)

        e.putBoolean("override_system_shortcuts", prefs.prefOverrideSystemShortcuts)
        e.putInt("custom_mod_key", prefs.customModKey)

        // Save Mirror Keyboard Prefs
        e.putInt("mirror_alpha", prefs.prefMirrorAlpha)
        e.putInt("mirror_x", prefs.prefMirrorX)
        e.putInt("mirror_y", prefs.prefMirrorY)
        e.putInt("mirror_width", prefs.prefMirrorWidth)
        e.putInt("mirror_height", prefs.prefMirrorHeight)
        // =================================================================================
        // END BLOCK: VIRTUAL MIRROR MODE SAVE
        // =================================================================================

        e.apply() 
    }

    private fun bindShizuku() { try { val c = ComponentName(packageName, ShellUserService::class.java.name); ShizukuBinder.bind(c, userServiceConnection, BuildConfig.DEBUG, BuildConfig.VERSION_CODE) } catch (e: Exception) { e.printStackTrace() } }

    // Helper to retry binding if connection is dead/null




    private fun checkAndBindShizuku() {
        // 1. If already bound and alive, do nothing
        if (shellService != null && shellService!!.asBinder().isBinderAlive) {
            return
        }

        // 2. If dead but not null, clear it
        if (shellService != null && !shellService!!.asBinder().isBinderAlive) {
            isBound = false
            shellService = null
        }

        Log.d(TAG, "Binding Shizuku: Attempt 1 (Immediate)")
        // Use existing safe bind method
        bindShizuku() 
        
        // 3. Retry after 2.5 seconds (The Critical Fix)
        // We use 'handler' here (not uiHandler)
        handler.postDelayed({
            if (shellService == null) {
                Log.w(TAG, "Binding Shizuku: Attempt 2 (Delayed 2.5s)")
                bindShizuku()
            }
        }, 2500)
    }





    private fun createNotification() { 
        try {
            val channel = NotificationChannel("overlay_service", "Trackpad", NotificationManager.IMPORTANCE_LOW)
            (getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager).createNotificationChannel(channel)
            val notif = Notification.Builder(this, "overlay_service").setContentTitle("Trackpad Active").setSmallIcon(R.drawable.ic_cursor).build()
            try { if (Build.VERSION.SDK_INT >= 34) startForeground(1, notif, ServiceInfo.FOREGROUND_SERVICE_TYPE_SPECIAL_USE) else startForeground(1, notif) } catch(e: Exception) { startForeground(1, notif) }
        } catch(e: Exception) { e.printStackTrace() }
    }



    private fun initCustomKeyboard() { 
        if (appWindowManager == null || shellService == null) return
        
        keyboardOverlay = KeyboardOverlay(
            this, 
            appWindowManager!!, 
            shellService, 
            inputTargetDisplayId, 
            { toggleScreen() }, 
            { toggleScreenMode() }, 
            { toggleCustomKeyboard() }
        )
        
        // Wire up Trackpad Callbacks
        keyboardOverlay?.onCursorMove = { dx, dy, isDragging -> handleExternalMouseMove(dx, dy, isDragging) }
        keyboardOverlay?.onCursorClick = { isRight -> handleExternalMouseClick(isRight) }

        // Wire Touch Primitives
        keyboardOverlay?.onTouchDown = { handleExternalTouchDown() }
        keyboardOverlay?.onTouchUp = { handleExternalTouchUp() }
        keyboardOverlay?.onTouchTap = { handleExternalTouchTap() }

        // =================================================================================
        // ARROW KEYS SWIPE CALLBACK - SPACEBAR MOUSE MODE
        // SUMMARY: When arrow keys pressed in spacebar mouse mode, perform swipe.
        //          dx/dy are -1, 0, or 1. Uses BASE_SWIPE_DISTANCE * scrollSpeed.
        // =================================================================================
        keyboardOverlay?.onArrowSwipe = { dx, dy ->
            val distance = BASE_SWIPE_DISTANCE * prefs.scrollSpeed
            performSwipe(dx * distance, dy * distance)
        }

        // =================================================================================
        // MOUSE SCROLL CALLBACK
        // SUMMARY: Forward mouse wheel events from keyboard overlay to target display
        // =================================================================================
        keyboardOverlay?.onMouseScroll = { h, v ->
            // Scale scroll speed (e.g. 10x for reasonable scroll amount)
            injectScroll(h * 10f, v * 10f)
        }
        // =================================================================================
        // END BLOCK: ARROW KEYS SWIPE CALLBACK
        // =================================================================================

        // =================================================================================
        // VIRTUAL MIRROR TOUCH CALLBACK
        // SUMMARY: Wire up the mirror touch callback to forward touch events from the
        //          physical keyboard to the mirror keyboard on the remote display.
        //          Returns true if the touch should be consumed (orientation mode active).
        // =================================================================================
        keyboardOverlay?.onMirrorTouch = { x, y, action ->
            onMirrorKeyboardTouch(x, y, action)
        }
        // =================================================================================
        // END BLOCK: VIRTUAL MIRROR TOUCH CALLBACK
        // =================================================================================

        // Wire up layer change callback for mirror keyboard sync
        keyboardOverlay?.onLayerChanged = { state ->
            syncMirrorKeyboardLayer(state)
        }

        // =================================================================================
        // MIRROR SUGGESTIONS SYNC CALLBACK
        // SUMMARY: When suggestions change on physical keyboard, sync to mirror keyboard.
        //          This keeps the prediction bar in sync on both displays.
        // =================================================================================
        keyboardOverlay?.onSuggestionsChanged = { suggestions ->
            mirrorKeyboardView?.setSuggestions(suggestions)
        }
        // =================================================================================
        // END BLOCK: MIRROR SUGGESTIONS SYNC CALLBACK
        // =================================================================================

        // =================================================================================
        // PHYSICAL KEYBOARD SIZE/POSITION CHANGE CALLBACK
        // SUMMARY: When physical keyboard is moved/resized, sync mirror keyboard.
        // =================================================================================
        keyboardOverlay?.onSizeChanged = {
            syncMirrorWithPhysicalKeyboard()
        }
        // =================================================================================
        // END BLOCK: PHYSICAL KEYBOARD SIZE/POSITION CHANGE CALLBACK
        // =================================================================================

        // FIX: Restore Saved Layout (fixes reset/aspect ratio issue)
        if (savedKbW > 0 && savedKbH > 0) {
            keyboardOverlay?.updatePosition(savedKbX, savedKbY)
            keyboardOverlay?.updateSize(savedKbW, savedKbH)
        } else {
            // [Fixed] Default Size: Calculate height based on scale + 20dp buffer
            val density = resources.displayMetrics.density
            // Add 20dp padding so the scale fits comfortably without clipping
            val buffer = 20 * density
            val defaultH = ((275f * (prefs.prefKeyScale / 100f) * density) + buffer).toInt()
            
            keyboardOverlay?.updatePosition(0, uiScreenHeight - defaultH)
            keyboardOverlay?.updateSize(uiScreenWidth, defaultH)
        }

        // [REMOVED] Do not force scale here. 
        // KeyboardOverlay loads the fresh "keyboard_key_scale" from disk automatically.
        // Forcing 'prefs.prefKeyScale' here causes bugs because 'prefs' might be stale.
        // =================================================================================
        // SPACEBAR MOUSE EXTENDED MODE INITIALIZATION
        // =================================================================================
        keyboardOverlay?.getKeyboardView()?.setSpacebarExtendedMode(prefs.prefSpacebarMouseExtended)
        // =================================================================================
        // END BLOCK: SPACEBAR MOUSE EXTENDED MODE INITIALIZATION
        // =================================================================================

        // Set override system shortcuts preference
        keyboardOverlay?.setOverrideSystemShortcuts(prefs.prefOverrideSystemShortcuts)

        // Sync launcher blocked shortcuts to keyboard
        keyboardOverlay?.setLauncherBlockedShortcuts(launcherBlockedShortcuts)

        // Re-apply saved custom mod key
        keyboardOverlay?.setCustomModKey(prefs.customModKey)

        // Force initial visibility based on flag
        if (isCustomKeyboardVisible) {
            keyboardOverlay?.show()
        }
    }




    fun toggleCustomKeyboard(suppressAutomation: Boolean = false) {
        if (keyboardOverlay == null) initCustomKeyboard()
        
        val isNowVisible = if (keyboardOverlay?.isShowing() == true) { 
            keyboardOverlay?.hide()
            false 
        } else { 
            keyboardOverlay?.show()
            // [REMOVED] Stale scale enforcement. 
            // The show() method already loads the correct saved scale from disk.
            true 
        }
        
        isCustomKeyboardVisible = isNowVisible
        enforceZOrder()
        
        if (prefs.prefAutomationEnabled && !suppressAutomation) { 
            if (isNowVisible) turnScreenOn() else turnScreenOff() 
        }
    }

    private fun turnScreenOn() { isScreenOff = false; Thread { try { shellService?.setBrightness(128); shellService?.setScreenOff(0, false) } catch(e: Exception) {} }.start(); showToast("Screen On") }
    private fun turnScreenOff() { isScreenOff = true; Thread { try { if (prefs.prefUseAltScreenOff) shellService?.setBrightness(-1) else shellService?.setScreenOff(0, true) } catch(e: Exception) {} }.start(); showToast("Screen Off (${if(prefs.prefUseAltScreenOff) "Alt" else "Std"})") }
    private fun toggleScreenMode() { prefs.prefUseAltScreenOff = !prefs.prefUseAltScreenOff; savePrefs(); showToast("Mode: ${if(prefs.prefUseAltScreenOff) "Alternate" else "Standard"}") }
    private fun toggleScreen() { if (isScreenOff) turnScreenOn() else turnScreenOff() }
    
    private fun updateUiMetrics() { val display = displayManager?.getDisplay(currentDisplayId) ?: return; val metrics = android.util.DisplayMetrics(); display.getRealMetrics(metrics); uiScreenWidth = metrics.widthPixels; uiScreenHeight = metrics.heightPixels }
    private fun createTrackpadDisplayContext(display: Display): Context { return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) createDisplayContext(display).createWindowContext(WindowManager.LayoutParams.TYPE_ACCESSIBILITY_OVERLAY, null) else createDisplayContext(display) }
    private fun addHandle(context: Context, gravity: Int, color: Int, onTouch: (View, MotionEvent) -> Boolean) { val container = FrameLayout(context); val p = FrameLayout.LayoutParams(prefs.prefHandleTouchSize, prefs.prefHandleTouchSize); p.gravity = gravity; val visual = View(context); val bg = GradientDrawable(); bg.setColor(color); bg.cornerRadius = 15f; visual.background = bg; val vp = FrameLayout.LayoutParams(prefs.prefHandleSize, prefs.prefHandleSize); vp.gravity = Gravity.CENTER; container.addView(visual, vp); handleContainers.add(container); handleVisuals.add(visual); trackpadLayout?.addView(container, p); container.setOnTouchListener { v, e -> onTouch(v, e) } }
    
    private fun addScrollBars(context: Context) {
        val margin = prefs.prefHandleTouchSize + 10
        vScrollContainer = FrameLayout(context)
        val vp = FrameLayout.LayoutParams(prefs.prefScrollTouchSize, FrameLayout.LayoutParams.MATCH_PARENT); vp.gravity = if (prefs.prefVPosLeft) Gravity.LEFT else Gravity.RIGHT; vp.setMargins(0, margin, 0, margin)
        trackpadLayout?.addView(vScrollContainer, vp)
        vScrollVisual = View(context); vScrollVisual?.setBackgroundColor(0x30FFFFFF.toInt())
        vScrollContainer?.addView(vScrollVisual, FrameLayout.LayoutParams(prefs.prefScrollVisualSize, FrameLayout.LayoutParams.MATCH_PARENT, Gravity.CENTER))
        vScrollContainer?.setOnTouchListener { _, event -> handleVScrollTouch(event); true }
        
        hScrollContainer = FrameLayout(context)
        val hp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, prefs.prefScrollTouchSize); hp.gravity = if (prefs.prefHPosTop) Gravity.TOP else Gravity.BOTTOM; hp.setMargins(margin, 0, margin, 0)
        trackpadLayout?.addView(hScrollContainer, hp)
        hScrollVisual = View(context); hScrollVisual?.setBackgroundColor(0x30FFFFFF.toInt())
        hScrollContainer?.addView(hScrollVisual, FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, prefs.prefScrollVisualSize, Gravity.CENTER))
        hScrollContainer?.setOnTouchListener { _, event -> handleHScrollTouch(event); true }
    }

    private fun handleVScrollTouch(event: MotionEvent) {
        when (event.actionMasked) {
            MotionEvent.ACTION_DOWN -> { isVScrolling = true; lastTouchY = event.y; scrollAccumulatorY = 0f; vScrollVisual?.setBackgroundColor(0x80FFFFFF.toInt()); if (prefs.prefTapScroll) { val h = vScrollContainer?.height ?: return; val dist = BASE_SWIPE_DISTANCE * prefs.scrollSpeed; performSwipe(0f, if (event.y < h/2) (if (prefs.prefReverseScroll) -dist else dist) else (if (prefs.prefReverseScroll) dist else -dist)) } }
            MotionEvent.ACTION_MOVE -> { if (isVScrolling && !prefs.prefTapScroll) { val dy = event.y - lastTouchY; scrollAccumulatorY += dy * prefs.scrollSpeed; if (abs(scrollAccumulatorY) > 30f) { performSwipe(0f, if (prefs.prefReverseScroll) -scrollAccumulatorY * 2 else scrollAccumulatorY * 2); scrollAccumulatorY = 0f }; lastTouchY = event.y } }
            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> { isVScrolling = false; scrollAccumulatorY = 0f; vScrollVisual?.setBackgroundColor(0x30FFFFFF.toInt()) }
        }
    }
    
    private fun handleHScrollTouch(event: MotionEvent) {
        when (event.actionMasked) {
            MotionEvent.ACTION_DOWN -> { isHScrolling = true; lastTouchX = event.x; scrollAccumulatorX = 0f; hScrollVisual?.setBackgroundColor(0x80FFFFFF.toInt()); if (prefs.prefTapScroll) { val w = hScrollContainer?.width ?: return; val dist = BASE_SWIPE_DISTANCE * prefs.scrollSpeed; performSwipe(if (event.x < w/2) (if (prefs.prefReverseScroll) -dist else dist) else (if (prefs.prefReverseScroll) dist else -dist), 0f) } }
            MotionEvent.ACTION_MOVE -> { if (isHScrolling && !prefs.prefTapScroll) { val dx = event.x - lastTouchX; scrollAccumulatorX += dx * prefs.scrollSpeed; if (abs(scrollAccumulatorX) > 30f) { performSwipe(if (prefs.prefReverseScroll) -scrollAccumulatorX * 2 else scrollAccumulatorX * 2, 0f); scrollAccumulatorX = 0f }; lastTouchX = event.x } }
            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> { isHScrolling = false; scrollAccumulatorX = 0f; hScrollVisual?.setBackgroundColor(0x30FFFFFF.toInt()) }
        }
    }

    private fun updateScrollPosition() { val margin = prefs.prefHandleTouchSize + 10; vScrollContainer?.let { c -> val p = c.layoutParams as FrameLayout.LayoutParams; p.gravity = if (prefs.prefVPosLeft) Gravity.LEFT else Gravity.RIGHT; p.setMargins(0, margin, 0, margin); c.layoutParams = p }; hScrollContainer?.let { c -> val p = c.layoutParams as FrameLayout.LayoutParams; p.gravity = if (prefs.prefHPosTop) Gravity.TOP else Gravity.BOTTOM; p.setMargins(margin, 0, margin, 0); c.layoutParams = p } }
    private fun updateHandleSize() { for (v in handleVisuals) { val p = v.layoutParams; p.width = prefs.prefHandleSize; p.height = prefs.prefHandleSize; v.layoutParams = p } }
    private fun updateScrollSize() {
        prefs.prefScrollTouchSize = prefs.prefScrollTouchSize.coerceIn(40, 180); prefs.prefScrollVisualSize = prefs.prefScrollVisualSize.coerceIn(4, 20); scrollZoneThickness = prefs.prefScrollTouchSize
        vScrollContainer?.let { it.layoutParams.width = prefs.prefScrollTouchSize; it.requestLayout() }; vScrollVisual?.let { it.layoutParams.width = prefs.prefScrollVisualSize; it.requestLayout() }
        hScrollContainer?.let { it.layoutParams.height = prefs.prefScrollTouchSize; it.requestLayout() }; hScrollVisual?.let { it.layoutParams.height = prefs.prefScrollVisualSize; it.requestLayout() }
    }
    private fun updateLayoutSizes() { for (c in handleContainers) { val p = c.layoutParams; p.width = prefs.prefHandleTouchSize; p.height = prefs.prefHandleTouchSize; c.layoutParams = p } }
    private fun updateCursorSize() { val size = if (prefs.prefCursorSize > 0) prefs.prefCursorSize else 50; cursorView?.layoutParams?.let { it.width = size; it.height = size; cursorView?.layoutParams = it } }
    private fun updateBorderColor(strokeColor: Int) { currentBorderColor = strokeColor; val bg = trackpadLayout?.background as? GradientDrawable ?: return; bg.setColor((prefs.prefBgAlpha shl 24) or 0x000000); bg.setStroke(4, (prefs.prefAlpha shl 24) or 0xFFFFFF); trackpadLayout?.invalidate() }
    
    private fun performSwipe(dx: Float, dy: Float) {
        Thread {
            val dId = if (inputTargetDisplayId != -1) inputTargetDisplayId else (cursorLayout?.display?.displayId ?: Display.DEFAULT_DISPLAY)
            val now = SystemClock.uptimeMillis(); val startX = cursorX; val startY = cursorY; val endX = startX + dx; val endY = startY + dy
            try { shellService?.injectMouse(MotionEvent.ACTION_DOWN, startX, startY, dId, InputDevice.SOURCE_TOUCHSCREEN, MotionEvent.BUTTON_PRIMARY, now) } catch(e: Exception) {}
            for (i in 1..5) { val t = i / 5f; try { shellService?.injectMouse(MotionEvent.ACTION_MOVE, startX + (dx*t), startY + (dy*t), dId, InputDevice.SOURCE_TOUCHSCREEN, MotionEvent.BUTTON_PRIMARY, now + (i*10)); Thread.sleep(10) } catch(e: Exception) {} }
            try { shellService?.injectMouse(MotionEvent.ACTION_UP, endX, endY, dId, InputDevice.SOURCE_TOUCHSCREEN, MotionEvent.BUTTON_PRIMARY, now + 100) } catch(e: Exception) {}
        }.start()
    }

    private fun handleTrackpadTouch(event: MotionEvent) {
        val viewWidth = trackpadLayout?.width ?: 0; val viewHeight = trackpadLayout?.height ?: 0; if (viewWidth == 0 || viewHeight == 0) return
        if (isReleaseDebouncing && event.actionMasked != MotionEvent.ACTION_DOWN) return
        
        when (event.actionMasked) {
            MotionEvent.ACTION_DOWN -> {
                // NEW: dismiss Voice if active
                checkAndDismissVoice()

                handler.removeCallbacks(releaseDebounceRunnable); isReleaseDebouncing = false
                touchDownTime = SystemClock.uptimeMillis(); touchDownX = event.x; touchDownY = event.y; lastTouchX = event.x; lastTouchY = event.y; isTouchDragging = false
                val actualZoneV = min(scrollZoneThickness, (viewWidth * 0.15f).toInt()); val actualZoneH = min(scrollZoneThickness, (viewHeight * 0.15f).toInt())
                if ((prefs.prefVPosLeft && event.x < actualZoneV) || (!prefs.prefVPosLeft && event.x > viewWidth - actualZoneV) || (prefs.prefHPosTop && event.y < actualZoneH) || (!prefs.prefHPosTop && event.y > viewHeight - actualZoneH)) { ignoreTouchSequence = true; return }
                handler.postDelayed(longPressRunnable, 400)
            }
            MotionEvent.ACTION_MOVE -> {
                if (ignoreTouchSequence) return
                // VIRTUAL DISPLAY KEEP-ALIVE: Ping user activity during active touch on remote display
                if (inputTargetDisplayId != currentDisplayId) pingUserActivity()
                if (kotlin.math.sqrt((event.x - touchDownX) * (event.x - touchDownX) + (event.y - touchDownY) * (event.y - touchDownY)) > TAP_SLOP_PX) handler.removeCallbacks(longPressRunnable)
                val dx = (event.x - lastTouchX) * prefs.cursorSpeed; val dy = (event.y - lastTouchY) * prefs.cursorSpeed
                val safeW = if (inputTargetDisplayId != currentDisplayId) targetScreenWidth.toFloat() else uiScreenWidth.toFloat()
                val safeH = if (inputTargetDisplayId != currentDisplayId) targetScreenHeight.toFloat() else uiScreenHeight.toFloat()
                var fDx = dx; var fDy = dy
                when (rotationAngle) { 90 -> { fDx = -dy; fDy = dx }; 180 -> { fDx = -dx; fDy = -dy }; 270 -> { fDx = dy; fDy = -dx } }
                cursorX = (cursorX + fDx).coerceIn(0f, safeW); cursorY = (cursorY + fDy).coerceIn(0f, safeH)
                if (inputTargetDisplayId == currentDisplayId) { cursorParams.x = cursorX.toInt(); cursorParams.y = cursorY.toInt(); try { windowManager?.updateViewLayout(cursorLayout, cursorParams) } catch(e: Exception) {} } 
                else { remoteCursorParams.x = cursorX.toInt(); remoteCursorParams.y = cursorY.toInt(); try { remoteWindowManager?.updateViewLayout(remoteCursorLayout, remoteCursorParams) } catch(e: Exception) {} }
                if (isTouchDragging || isKeyDragging) injectAction(MotionEvent.ACTION_MOVE, InputDevice.SOURCE_TOUCHSCREEN, activeDragButton, SystemClock.uptimeMillis()) else injectAction(MotionEvent.ACTION_MOVE, InputDevice.SOURCE_MOUSE, 0, SystemClock.uptimeMillis())
                lastTouchX = event.x; lastTouchY = event.y
            }
            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                handler.removeCallbacks(longPressRunnable)
                if (!ignoreTouchSequence) {
                    if (isTouchDragging) { injectAction(MotionEvent.ACTION_UP, InputDevice.SOURCE_TOUCHSCREEN, activeDragButton, SystemClock.uptimeMillis()); isTouchDragging = false }
                    else if (!isKeyDragging && SystemClock.uptimeMillis() - touchDownTime < TAP_TIMEOUT_MS && kotlin.math.sqrt((event.x - touchDownX) * (event.x - touchDownX) + (event.y - touchDownY) * (event.y - touchDownY)) < TAP_SLOP_PX) performClick(false)
                }
                isReleaseDebouncing = true; handler.postDelayed(releaseDebounceRunnable, RELEASE_DEBOUNCE_MS)
                if (!isKeyDragging) { isVScrolling = false; isHScrolling = false; updateBorderColor(currentBorderColor) }
                ignoreTouchSequence = false
            }
        }
    }

    // --- SMART VISIBILITY LOGIC ---
    fun performSmartHide() {
        pendingRestoreTrackpad = isTrackpadVisible
        pendingRestoreKeyboard = isCustomKeyboardVisible
        hasPendingRestore = true
        
        // Hide components (Automation logic inside toggleCustomKeyboard will handle screen off if enabled)
        if (isCustomKeyboardVisible) toggleCustomKeyboard()
        if (isTrackpadVisible) toggleTrackpad()
        
        handler.post { Toast.makeText(this, "Hidden (Tap Bubble to Restore)", Toast.LENGTH_SHORT).show() }
    }

    fun performSmartRestore() {
        if (!hasPendingRestore) {
            // Fallback: Just show Trackpad if no state saved
            if (!isTrackpadVisible) toggleTrackpad()
            return
        }
        
        if (pendingRestoreTrackpad && !isTrackpadVisible) toggleTrackpad()
        if (pendingRestoreKeyboard && !isCustomKeyboardVisible) toggleCustomKeyboard()
        
        hasPendingRestore = false
    }

    private fun moveWindow(event: MotionEvent): Boolean { if (prefs.prefAnchored) return true; if (event.action == MotionEvent.ACTION_MOVE) { trackpadParams.x += (event.rawX - lastTouchX).toInt(); trackpadParams.y += (event.rawY - lastTouchY).toInt(); windowManager?.updateViewLayout(trackpadLayout, trackpadParams) }; lastTouchX = event.rawX; lastTouchY = event.rawY; return true }
    private fun resizeWindow(event: MotionEvent): Boolean { if (prefs.prefAnchored) return true; if (event.action == MotionEvent.ACTION_MOVE) { trackpadParams.width += (event.rawX - lastTouchX).toInt(); trackpadParams.height += (event.rawY - lastTouchY).toInt(); windowManager?.updateViewLayout(trackpadLayout, trackpadParams) }; lastTouchX = event.rawX; lastTouchY = event.rawY; return true }
    private fun keyboardHandle(event: MotionEvent): Boolean { 
        if (event.action == MotionEvent.ACTION_UP) {
            // Reverted: Just toggle keyboard visibility
            toggleCustomKeyboard()
        } 
        return true 
    }
    private fun openMenuHandle(event: MotionEvent): Boolean { if (event.action == MotionEvent.ACTION_DOWN) menuManager?.toggle(); return true }
    // [EFFICIENCY] Use Executor instead of spawning new Threads for every event
    private fun injectAction(action: Int, source: Int, button: Int, time: Long) {
        if (shellService == null) return
        inputExecutor.execute {
            // Log.d("EFFICIENCY_TEST", "Worker Thread ID: ${Thread.currentThread().id}")
            try { shellService?.injectMouse(action, cursorX, cursorY, inputTargetDisplayId, source, button, time) } catch(e: Exception){}
        }
    }

    fun injectScroll(hScroll: Float, vScroll: Float) {
        if (shellService == null) return
        inputExecutor.execute {
            try { shellService?.injectScroll(cursorX, cursorY, vScroll / 10f, hScroll / 10f, inputTargetDisplayId) } catch(e: Exception){}
        }
    }

    // Helper to allow external components (like Keyboard) to control the cursor
    // Added 'isDragging' to switch between Hover (Mouse) and Drag (Touch)
// =================================================================================
    // SPACEBAR MOUSE CURSOR MOVEMENT HANDLER (with BT Mouse Display Sync)
    // SUMMARY: Handles cursor movement from the spacebar trackpad feature AND
    //          Bluetooth mouse input. Updates cursor position and visual, then
    //          injects hover/drag events.
    //
    //          BLUETOOTH MOUSE DISPLAY SYNC: When targeting a virtual display,
    //          uses 'input -d <displayId> mouse move' command to physically move
    //          the system cursor to the target display. This syncs the Android
    //          system cursor with DroidOS's software cursor.
    //
    //          CRITICAL: Skips hover injection when cursor is over keyboard bounds
    //          to prevent feedback loop that causes lag/freezing.
    // =================================================================================

    private var lastMouseMoveTime = 0L

    fun handleExternalMouseMove(dx: Float, dy: Float, isDragging: Boolean) {
        // [EFFICIENCY] Throttle input to ~120Hz (8ms)
        // This prevents flooding the binder transaction buffer
        val now = SystemClock.uptimeMillis()
        if (now - lastMouseMoveTime < 8) return
        lastMouseMoveTime = now

        // Log.d(BT_TAG, "handleExternalMouseMove: dx=$dx, dy=$dy, isDragging=$isDragging")
        // Log.d(BT_TAG, " inputTargetDisplayId=$inputTargetDisplayId, currentDisplayId=$currentDisplayId")
        // Log.d(BT_TAG, " cursorX=$cursorX, cursorY=$cursorY (before update)")

        // Calculate safe bounds based on target display
        val safeW = if (inputTargetDisplayId != currentDisplayId) targetScreenWidth.toFloat() else uiScreenWidth.toFloat()
        val safeH = if (inputTargetDisplayId != currentDisplayId) targetScreenHeight.toFloat() else uiScreenHeight.toFloat()

        // Update software cursor position
        cursorX = (cursorX + dx).coerceIn(0f, safeW)
        cursorY = (cursorY + dy).coerceIn(0f, safeH)

        // Update Visuals (Redraw the cursor icon overlay)
        if (inputTargetDisplayId == currentDisplayId) {
            cursorParams.x = cursorX.toInt()
            cursorParams.y = cursorY.toInt()
            try { windowManager?.updateViewLayout(cursorLayout, cursorParams) } catch (e: Exception) {}
        } else {
            remoteCursorParams.x = cursorX.toInt()
            remoteCursorParams.y = cursorY.toInt()
            try { remoteWindowManager?.updateViewLayout(remoteCursorLayout, remoteCursorParams) } catch (e: Exception) {}
        }

        // =======================================================================
        // BLUETOOTH MOUSE DISPLAY SYNC
        // When targeting a virtual/remote display, move the system mouse cursor
        // to the target display using shell command. This ensures the BT mouse
        // cursor follows our software cursor to the virtual display.
        // =======================================================================
        if (inputTargetDisplayId != currentDisplayId && shellService != null) {
            val dxInt = dx.toInt()
            val dyInt = dy.toInt()
            if (dxInt != 0 || dyInt != 0) {
                Thread {
                    try {
                        // Move system cursor to target display using relative movement
                        shellService?.runCommand("input -d $inputTargetDisplayId mouse move $dxInt $dyInt")
                    } catch (e: Exception) {
                        Log.e("OverlayService", "BT mouse display sync failed", e)
                    }
                }.start()
            }
        }
        // =======================================================================
        // END BLOCK: BLUETOOTH MOUSE DISPLAY SYNC
        // =======================================================================

        // [ANTI-FEEDBACK-LOOP FIX]
        // Check if cursor is over the keyboard - if so, skip hover injection
        // This prevents the injected mouse events from creating a feedback loop
        // where the keyboard receives the hover, processes it, and triggers more events
        val isOverKeyboard = isCursorOverKeyboard()

        // Input Injection (for apps that listen to motion events)
        if (isDragging) {
            // TOUCH DRAG: SOURCE_TOUCHSCREEN + ACTION_MOVE
            // Always inject drag events - user explicitly initiated drag
            injectAction(MotionEvent.ACTION_MOVE, InputDevice.SOURCE_TOUCHSCREEN, 0, SystemClock.uptimeMillis())
        } else {
            // MOUSE HOVER: SOURCE_MOUSE + ACTION_HOVER_MOVE
            // Skip hover injection when over keyboard to prevent feedback loop
            if (!isOverKeyboard) {
                injectAction(MotionEvent.ACTION_HOVER_MOVE, InputDevice.SOURCE_MOUSE, 0, SystemClock.uptimeMillis())
            }
        }
    }
    // =================================================================================
    // END BLOCK: SPACEBAR MOUSE CURSOR MOVEMENT HANDLER (with BT Mouse Display Sync)
    // =================================================================================

    // =================================================================================
    // KEYBOARD BOUNDS CHECK FOR CURSOR
    // SUMMARY: Returns true if the cursor is currently positioned over the keyboard
    //          overlay window. Used to prevent feedback loops when the spacebar
    //          mouse feature moves the cursor over the keyboard itself.
    // =================================================================================
    private fun isCursorOverKeyboard(): Boolean {
        // Only check if keyboard is visible and we're on the same display
        if (!isCustomKeyboardVisible) return false
        if (inputTargetDisplayId != currentDisplayId) return false
        
        // Get keyboard bounds from the overlay
        val kbX = keyboardOverlay?.getViewX() ?: return false
        val kbY = keyboardOverlay?.getViewY() ?: return false
        val kbW = keyboardOverlay?.getViewWidth() ?: return false
        val kbH = keyboardOverlay?.getViewHeight() ?: return false
        
        // Add a small padding to the bounds to ensure we catch edge cases
        val padding = 10
        
        return cursorX >= (kbX - padding) && 
               cursorX <= (kbX + kbW + padding) &&
               cursorY >= (kbY - padding) && 
               cursorY <= (kbY + kbH + padding)
    }
    // =================================================================================
    // END BLOCK: KEYBOARD BOUNDS CHECK FOR CURSOR
    // ==============================================

    // Explicit Touch Down (Start Drag/Hold)
    fun handleExternalTouchDown() {
        injectAction(MotionEvent.ACTION_DOWN, InputDevice.SOURCE_TOUCHSCREEN, 0, SystemClock.uptimeMillis())
        android.util.Log.d("TouchInjection", "Touch DOWN at ($cursorX, $cursorY)")
    }

    // Explicit Touch Up (End Drag/Hold)
    fun handleExternalTouchUp() {
        injectAction(MotionEvent.ACTION_UP, InputDevice.SOURCE_TOUCHSCREEN, 0, SystemClock.uptimeMillis())
        android.util.Log.d("TouchInjection", "Touch UP at ($cursorX, $cursorY)")
    }

    // Quick Tap (Down + Up)
    fun handleExternalTouchTap() {
        if (shellService == null) return
        Thread {
            val now = SystemClock.uptimeMillis()
            try {
                shellService?.injectMouse(MotionEvent.ACTION_DOWN, cursorX, cursorY, inputTargetDisplayId, InputDevice.SOURCE_TOUCHSCREEN, 0, now)
                Thread.sleep(50)
                shellService?.injectMouse(MotionEvent.ACTION_UP, cursorX, cursorY, inputTargetDisplayId, InputDevice.SOURCE_TOUCHSCREEN, 0, now + 50)
                android.util.Log.d("TouchInjection", "Touch TAP at ($cursorX, $cursorY)")
            } catch (e: Exception) {
                android.util.Log.e("TouchInjection", "TAP failed", e)
            }
        }.start()
    }

    // Keep Right Click for the predictive bar if needed
    fun handleExternalMouseClick(isRight: Boolean) {
        performClick(isRight)
    }

    fun performClick(right: Boolean) { if (shellService == null) return; Thread { try { if (right) shellService?.execRightClick(cursorX, cursorY, inputTargetDisplayId) else shellService?.execClick(cursorX, cursorY, inputTargetDisplayId) } catch(e: Exception){} }.start() }
    fun resetCursorCenter() { cursorX = if (inputTargetDisplayId != currentDisplayId) targetScreenWidth/2f else uiScreenWidth/2f; cursorY = if (inputTargetDisplayId != currentDisplayId) targetScreenHeight/2f else uiScreenHeight/2f; if (inputTargetDisplayId == currentDisplayId) { cursorParams.x = cursorX.toInt(); cursorParams.y = cursorY.toInt(); windowManager?.updateViewLayout(cursorLayout, cursorParams) } else { remoteCursorParams.x = cursorX.toInt(); remoteCursorParams.y = cursorY.toInt(); try { remoteWindowManager?.updateViewLayout(remoteCursorLayout, remoteCursorParams) } catch(e: Exception){} } }
    fun performRotation() { rotationAngle = (rotationAngle + 90) % 360; cursorView?.rotation = rotationAngle.toFloat() }

    // =================================================================================
    // PROFILE KEY GENERATION
    // SUMMARY: Generates a unique key based on Resolution + Mirror Mode State.
    //          Allows separate profiles for "Standard" and "Mirror" modes.
    // =================================================================================

    // =================================================================================
    // PROFILE KEY GENERATION
    // SUMMARY: Generates a unique key based on Resolution + Mirror Mode State.
    //          Allows separate profiles for "Standard" and "Mirror" modes.
    // =================================================================================




    // =================================================================================
    // VIRTUAL MIRROR MODE PROFILE KEY
    // SUMMARY: Returns a unique profile key for mirror mode, separate from normal
    //          display-based profiles. This allows mirror mode to have its own
    //          trackpad/keyboard layout that persists independently.
    // =================================================================================

    // =================================================================================
    // END BLOCK: VIRTUAL MIRROR MODE PROFILE KEY
    // =================================================================================

    // =================================================================================
    // VIRTUAL MIRROR MODE LAYOUT SAVE
    // SUMMARY: Saves the current layout to the mirror mode profile. Called when
    //          exiting mirror mode or when explicitly saving while in mirror mode.
    //          Includes both physical keyboard AND mirror keyboard positions/sizes.
    // =================================================================================

    // =================================================================================
    // END BLOCK: VIRTUAL MIRROR MODE LAYOUT SAVE
    // =================================================================================

    // =================================================================================
    // VIRTUAL MIRROR MODE LAYOUT LOAD
    // SUMMARY: Loads the mirror mode profile layout. Called when entering mirror mode.
    //          If no saved profile exists, uses sensible defaults.
    // =================================================================================

    // =================================================================================
    // END BLOCK: VIRTUAL MIRROR MODE LAYOUT LOAD
    // =================================================================================

    // =================================================================================
    // FUNCTION: applyMirrorKeyboardSettings
    // SUMMARY: Applies saved mirror keyboard position/size/alpha to the live mirror
    //          keyboard. Called after loading a mirror mode profile.
    // =================================================================================
    private fun applyMirrorKeyboardSettings() {
        if (mirrorKeyboardParams == null || mirrorKeyboardContainer == null) return

        // Apply saved position if valid
        if (prefs.prefMirrorX != -1) {
            mirrorKeyboardParams?.x = prefs.prefMirrorX
            mirrorKeyboardParams?.gravity = Gravity.TOP or Gravity.START
        }
        if (prefs.prefMirrorY != 0 || prefs.prefMirrorX != -1) {
            mirrorKeyboardParams?.y = prefs.prefMirrorY
        }
        if (prefs.prefMirrorWidth != -1 && prefs.prefMirrorWidth > 0) {
            mirrorKeyboardParams?.width = prefs.prefMirrorWidth
        }
        if (prefs.prefMirrorHeight != -1 && prefs.prefMirrorHeight > 0) {
            mirrorKeyboardParams?.height = prefs.prefMirrorHeight
        }

        // Apply alpha
        val alpha = prefs.prefMirrorAlpha / 255f
        mirrorKeyboardContainer?.alpha = alpha

        // Update the window
        try {
            mirrorWindowManager?.updateViewLayout(mirrorKeyboardContainer, mirrorKeyboardParams)

            // Update sync dimensions after layout change
            handler.postDelayed({
                updateMirrorSyncDimensions()
            }, 100)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to apply mirror keyboard settings", e)
        }

        Log.d(TAG, "Mirror keyboard settings applied")
    }
    // =================================================================================
    // END BLOCK: applyMirrorKeyboardSettings
    // =================================================================================



    // =================================================================================
    // FUNCTION: loadLayout
    // SUMMARY: Loads a display-specific profile containing trackpad window position/size,
    //          keyboard settings (scale, alpha, position), and visual preferences.
    //          The profile key is based on screen resolution + mirror mode state.
    //          CRITICAL: After loading profile scale, syncs it to global SharedPreferences
    //          so KeyboardOverlay.show() picks up the correct value.
    // =================================================================================
    fun loadLayout() {
        val p = getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE)
        val key = getProfileKey()
        
        // 1. Load Trackpad Window
        trackpadParams.x = p.getInt("X_$key", 100)
        trackpadParams.y = p.getInt("Y_$key", 100)
        trackpadParams.width = p.getInt("W_$key", 400)
        trackpadParams.height = p.getInt("H_$key", 300)
        try {
            windowManager?.updateViewLayout(trackpadLayout, trackpadParams)
        } catch(e: Exception){}
        
        // 2. Load Settings String
        val settings = p.getString("SETTINGS_$key", null)
        var keyboardUpdated = false

        if (settings != null) {
            val parts = settings.split(";")
            if (parts.size >= 15) {
                // ... (Parsing Basic Params) ...
                prefs.cursorSpeed = parts[0].toFloat(); prefs.scrollSpeed = parts[1].toFloat()
                prefs.prefTapScroll = parts[2] == "1"; prefs.prefReverseScroll = parts[3] == "1"
                prefs.prefAlpha = parts[4].toInt(); prefs.prefBgAlpha = parts[5].toInt()
                prefs.prefKeyboardAlpha = parts[6].toInt(); prefs.prefHandleSize = parts[7].toInt()
                prefs.prefHandleTouchSize = parts[8].toInt(); prefs.prefScrollTouchSize = parts[9].toInt()
                prefs.prefScrollVisualSize = parts[10].toInt(); prefs.prefCursorSize = parts[11].toInt()
                prefs.prefKeyScale = parts[12].toInt()
                prefs.prefAutomationEnabled = parts[13] == "1"; prefs.prefAnchored = parts[14] == "1"
                
                // =================================================================================
                // FIX: SYNC PROFILE SCALE TO GLOBAL SHAREDPREFS
                // SUMMARY: KeyboardOverlay.show() reads "keyboard_key_scale" from SharedPrefs directly.
                //          We must update this global key whenever we load a profile, otherwise
                //          the keyboard will use the scale from the previous display/profile.
                // =================================================================================
                p.edit().putInt("keyboard_key_scale", prefs.prefKeyScale).apply()
                // =================================================================================
                // END BLOCK: SYNC PROFILE SCALE TO GLOBAL SHAREDPREFS
                // =================================================================================
                
                if (parts.size >= 27) {
                    prefs.prefBubbleSize = parts[15].toInt(); prefs.prefBubbleAlpha = parts[16].toInt()
                    prefs.prefBubbleIconIndex = parts[17].toInt(); prefs.prefBubbleX = parts[18].toInt()
                    prefs.prefBubbleY = parts[19].toInt(); prefs.hardkeyVolUpTap = parts[20]
                    prefs.hardkeyVolUpDouble = parts[21]; prefs.hardkeyVolUpHold = parts[22]
                    prefs.hardkeyVolDownTap = parts[23]; prefs.hardkeyVolDownDouble = parts[24]
                    prefs.hardkeyVolDownHold = parts[25]; prefs.hardkeyPowerDouble = parts[26]
                }
                
                if (parts.size >= 30) {
                    prefs.prefVibrate = parts[27] == "1"
                    prefs.prefVPosLeft = parts[28] == "1"
                    prefs.prefHPosTop = parts[29] == "1"
                }
                

            // [FIX] Load Prediction Aggression (Only if profile is new enough, i.e. has 35+ parts)
            // We check >= 35 because: 30(base) + 1(aggression) + 4(bounds) = 35
            // This prevents reading "X-coordinate" as "Aggression" on legacy profiles.
            if (parts.size >= 35) {
                try {
                    prefs.prefPredictionAggression = parts[30].toFloat()
                    PredictionEngine.instance.speedThreshold = prefs.prefPredictionAggression
                } catch (e: Exception) {
                    android.util.Log.e("OverlayService", "Failed to parse aggression", e)
                }
            }

            // Load Physical Keyboard Bounds
            // Logic:
            // Size 35+ -> Newest (Aggression at 30, Bounds at 31)
            // Size 34  -> Previous (Bounds at 30)
            // Size 31  -> Oldest (Bounds at 27)
            var kbIndex = 30
            if (parts.size >= 35) {
                kbIndex = 31
            } else if (parts.size < 34 && parts.size >= 31) {
                kbIndex = 27 
            }
            

            // Ensure we have enough parts for X, Y, W, H
            if (parts.size > kbIndex + 3) {
                 try {
                     savedKbX = parts[kbIndex].toInt()
                     savedKbY = parts[kbIndex+1].toInt()

                     savedKbW = parts[kbIndex+2].toInt(); savedKbH = parts[kbIndex+3].toInt()
                     
                     keyboardOverlay?.setWindowBounds(savedKbX, savedKbY, savedKbW, savedKbH)
                     keyboardUpdated = true
                } catch (e: Exception) { }

                // Apply Visuals
                updateBorderColor(currentBorderColor); updateScrollSize(); updateHandleSize()
                updateCursorSize(); updateScrollPosition()
                keyboardOverlay?.updateScale(prefs.prefKeyScale / 100f)
                keyboardOverlay?.updateAlpha(prefs.prefKeyboardAlpha)
                keyboardOverlay?.setAnchored(prefs.prefAnchored)
                keyboardOverlay?.setVibrationEnabled(prefs.prefVibrate)
                applyBubbleAppearance()
            }
        }
    }


        // [FIX] LOAD MIRROR KEYBOARD PARAMS (If in Mirror Mode)
        if (prefs.prefVirtualMirrorMode) {
            if (p.contains("MIRROR_X_$key")) {
                prefs.prefMirrorX = p.getInt("MIRROR_X_$key", -1)
                prefs.prefMirrorY = p.getInt("MIRROR_Y_$key", 0)
                prefs.prefMirrorWidth = p.getInt("MIRROR_W_$key", -1)
                prefs.prefMirrorHeight = p.getInt("MIRROR_H_$key", -1)
                prefs.prefMirrorAlpha = p.getInt("MIRROR_ALPHA_$key", 200)
                
                // Update live window if it exists
                applyMirrorKeyboardSettings()
            }
        }

        // [FIX] GHOSTING PREVENTION
        if (!keyboardUpdated) {
            keyboardOverlay?.resetPosition()
            showToast("Defaults Loaded")
        } else {
            showToast("Profile Loaded: ${if(prefs.prefVirtualMirrorMode) "Mirror" else "Std"}")
        }
    }
    // =================================================================================
    // END BLOCK: loadLayout
    // =================================================================================




    fun deleteCurrentProfile() { /* Stub */ }
    fun resetKeyboardPosition() {
        keyboardOverlay?.resetPosition()
    }

    fun rotateKeyboard() {
        keyboardOverlay?.cycleRotation()
    }

    fun resetTrackpadPosition() { trackpadParams.x = 100; trackpadParams.y = 100; trackpadParams.width = 400; trackpadParams.height = 300; windowManager?.updateViewLayout(trackpadLayout, trackpadParams) }    // =================================================================================
// =================================================================================
    // FUNCTION: showMirrorTemporarily
    // SUMMARY: Makes mirror keyboard visible temporarily, like when touched.
    //          Used during D-pad adjustments so user can see changes.
    // =================================================================================
    private fun showMirrorTemporarily() {
        if (mirrorKeyboardContainer == null || mirrorKeyboardView == null) return
        
        // Cancel any pending fade
        mirrorFadeHandler.removeCallbacks(mirrorFadeRunnable)
        
        // Show mirror - only adjust alpha, container is transparent
        val alpha = prefs.prefMirrorAlpha / 255f
        mirrorKeyboardContainer?.alpha = 1f
        mirrorKeyboardView?.alpha = alpha.coerceAtLeast(0.7f)
        
        // Schedule fade out after 2 seconds
        mirrorFadeHandler.postDelayed(mirrorFadeRunnable, 2000)
    }
    // =================================================================================
    // END BLOCK: showMirrorTemporarily
    // =================================================================================
    // =================================================================================
// =================================================================================
    // FUNCTION: adjustMirrorKeyboard
    // SUMMARY: Adjusts mirror keyboard position or size via D-pad controls.
    //          FIXED: Correct Y direction for both move and resize.
    //          FIXED: Handle WRAP_CONTENT properly for resize.
    // =================================================================================
    fun adjustMirrorKeyboard(isResize: Boolean, deltaX: Int, deltaY: Int) {
        // DEBUG: Show toast so we know function is called
        showToast("adjust: resize=$isResize dX=$deltaX dY=$deltaY")
        
        if (mirrorKeyboardParams == null || mirrorKeyboardContainer == null) {
            showToast("ERROR: params null")
            return
        }
        
        // Show mirror during adjustment
        showMirrorTemporarily()
        
if (isResize) {
            // =================================================================================
            // RESIZE MODE - adjust width/height AND scale the keyboard keys
            // SUMMARY: Changes container size and scales the inner KeyboardView to match.
            //          Also updates sync dimensions so touch coordinates map correctly.
            // =================================================================================
            
            // Get current dimensions from params
            var currentWidth = mirrorKeyboardParams?.width ?: 600
            var currentHeight = mirrorKeyboardParams?.height ?: 350
            
            // Handle WRAP_CONTENT (-2) - must get actual measured size from view
            if (currentWidth == WindowManager.LayoutParams.WRAP_CONTENT || currentWidth <= 0) {
                currentWidth = mirrorKeyboardContainer?.width ?: mirrorKeyboardView?.width ?: 600
                if (currentWidth <= 0) {
                    val display = displayManager?.getDisplay(inputTargetDisplayId)
                    if (display != null) {
                        val metrics = android.util.DisplayMetrics()
                        display.getRealMetrics(metrics)
                        currentWidth = (metrics.widthPixels * 0.9f).toInt()
                    } else {
                        currentWidth = 600
                    }
                }
                mirrorKeyboardParams?.width = currentWidth
            }
            
            if (currentHeight == WindowManager.LayoutParams.WRAP_CONTENT || currentHeight <= 0) {
                currentHeight = mirrorKeyboardContainer?.height ?: mirrorKeyboardView?.height ?: 350
                if (currentHeight <= 0) {
                    currentHeight = 350
                }
                mirrorKeyboardParams?.height = currentHeight
            }
            
            // Apply deltas: positive = grow, negative = shrink
            val newWidth = (currentWidth + deltaX).coerceIn(250, 1500)
            val newHeight = (currentHeight + deltaY).coerceIn(150, 1200)
            
            android.util.Log.d("MirrorResize", "Resize: ${currentWidth}x${currentHeight} -> ${newWidth}x${newHeight}")
            
            // Update container window params
            mirrorKeyboardParams?.width = newWidth
            mirrorKeyboardParams?.height = newHeight
            
            // Calculate new scale based on height ratio
            // Use physical keyboard as reference - mirror should scale proportionally
            val physicalHeight = keyboardOverlay?.getViewHeight()?.toFloat() ?: 350f
            val physicalScale = keyboardOverlay?.getScale() ?: 1.0f
            
            // Calculate what scale the mirror needs to fit in newHeight
            // Scale is proportional to height ratio
            val heightRatio = newHeight.toFloat() / physicalHeight
            val newScale = (physicalScale * heightRatio).coerceIn(0.5f, 2.0f)
            
            android.util.Log.d("MirrorResize", "Scale: physH=$physicalHeight, physScale=$physicalScale, ratio=$heightRatio, newScale=$newScale")
            
            // Apply scale to mirror keyboard - this resizes the actual keys
            mirrorKeyboardView?.setScale(newScale)
            
            // Update inner view layout params to match container
            mirrorKeyboardView?.layoutParams = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT,
                FrameLayout.LayoutParams.WRAP_CONTENT  // Let it size naturally with new scale
            )
            
            // Save to prefs
            prefs.prefMirrorWidth = newWidth
            prefs.prefMirrorHeight = newHeight
            
            getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE).edit()
                .putInt("mirror_width", newWidth)
                .putInt("mirror_height", newHeight)
                .apply()
        } else {
            // =================================================================================
            // MOVE MODE - adjust x/y position
            // For move: we want UP button to move keyboard UP on screen
            // UP sends deltaY = -20
            // With Gravity.BOTTOM: to move UP visually, Y offset must INCREASE
            // With Gravity.TOP: to move UP visually, Y offset must DECREASE
            // =================================================================================
            val currentX = mirrorKeyboardParams?.x ?: 0
            val currentY = mirrorKeyboardParams?.y ?: 0
            val gravity = mirrorKeyboardParams?.gravity ?: 0
            val isBottomGravity = (gravity and Gravity.BOTTOM) == Gravity.BOTTOM
            
            val newX = currentX + deltaX
            
            // CRITICAL FIX: Correct Y handling based on gravity
            val newY = if (isBottomGravity) {
                // Gravity.BOTTOM: positive Y = UP from bottom
                // UP button sends -20, we want to move UP, so negate: currentY - (-20) = currentY + 20
                currentY - deltaY
            } else {
                // Gravity.TOP: positive Y = DOWN from top  
                // UP button sends -20, we want to move UP, so add directly: currentY + (-20)
                currentY + deltaY
            }
            
            showToast("Move: ($currentX,$currentY)->($newX,$newY) btm=$isBottomGravity")
            
            mirrorKeyboardParams?.x = newX
            mirrorKeyboardParams?.y = newY
            
            // Switch to TOP gravity after first move for consistent behavior
            mirrorKeyboardParams?.gravity = Gravity.TOP or Gravity.START
            
            getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE).edit()
                .putInt("mirror_x", newX)
                .putInt("mirror_y", newY)
                .apply()
        }
        
        try {
            mirrorWindowManager?.updateViewLayout(mirrorKeyboardContainer, mirrorKeyboardParams)
            
            if (isResize) {
                handler.postDelayed({ updateMirrorSyncDimensions() }, 100)
            }
        } catch (e: Exception) {
            showToast("Layout update failed: ${e.message}")
        }
    }
    // =================================================================================
    // END BLOCK: adjustMirrorKeyboard
    // =================================================================================
    // =================================================================================
    // END BLOCK: adjustMirrorKeyboard
    // =================================================================================
    // =================================================================================
// =================================================================================
    // FUNCTION: resetMirrorKeyboardPosition
    // SUMMARY: Resets mirror keyboard to default centered position at bottom.
    //          Uses WRAP_CONTENT height and triggers sync dimension update.
    // =================================================================================
    fun resetMirrorKeyboardPosition() {
        if (mirrorKeyboardParams == null || mirrorKeyboardContainer == null) return
        
        // Show during reset
        showMirrorTemporarily()
        
        // Get display metrics for auto-sizing
        val display = displayManager?.getDisplay(inputTargetDisplayId) ?: return
        val metrics = android.util.DisplayMetrics()
        display.getRealMetrics(metrics)
        
        val mirrorWidth = (metrics.widthPixels * 0.95f).toInt()
        
        // Reset to defaults
        mirrorKeyboardParams?.x = 0
        mirrorKeyboardParams?.y = 0
        mirrorKeyboardParams?.gravity = Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
        mirrorKeyboardParams?.width = mirrorWidth
        mirrorKeyboardParams?.height = WindowManager.LayoutParams.WRAP_CONTENT
        
        // Clear saved prefs
        getSharedPreferences("TrackpadPrefs", Context.MODE_PRIVATE).edit()
            .remove("mirror_x")
            .remove("mirror_y")
            .remove("mirror_width")
            .remove("mirror_height")
            .apply()
        
        try {
            mirrorWindowManager?.updateViewLayout(mirrorKeyboardContainer, mirrorKeyboardParams)
            
            // FIX: Update sync dimensions after layout
            handler.postDelayed({
                updateMirrorSyncDimensions()
            }, 100)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to reset mirror keyboard layout", e)
        }
        
        Log.d(TAG, "Mirror keyboard reset to defaults")
    }
    // =================================================================================
    // END BLOCK: resetMirrorKeyboardPosition
    // =================================================================================
    fun cycleInputTarget() {
        Log.i(BT_TAG, "cycleInputTarget() initiated. Current: $inputTargetDisplayId, Host: $currentDisplayId")
        
        if (displayManager == null) return; val displays = displayManager!!.displays; var nextId = -1
        for (d in displays) { if (d.displayId != currentDisplayId) { if (inputTargetDisplayId == currentDisplayId) { nextId = d.displayId; break } else if (inputTargetDisplayId == d.displayId) { continue } else { nextId = d.displayId } } }
        
        if (nextId == -1) { 
            Log.w(BT_TAG, "Cycle -> Switching to LOCAL ($currentDisplayId). Removing BT Capture.")
            inputTargetDisplayId = currentDisplayId; targetScreenWidth = uiScreenWidth; targetScreenHeight = uiScreenHeight; removeRemoteCursor(); removeMirrorKeyboard(); removeBtMouseCaptureOverlay(); cursorX = uiScreenWidth / 2f; cursorY = uiScreenHeight / 2f; cursorParams.x = cursorX.toInt(); cursorParams.y = cursorY.toInt(); try { windowManager?.updateViewLayout(cursorLayout, cursorParams) } catch(e: Exception){}; cursorView?.visibility = View.VISIBLE; updateBorderColor(0x55FFFFFF.toInt()); showToast("Target: Local (Display $currentDisplayId)"); updateWakeLockState() 
        } else { 
            Log.w(BT_TAG, "Cycle -> Switching to REMOTE ($nextId). Creating BT Capture.")
            inputTargetDisplayId = nextId; updateTargetMetrics(nextId); createRemoteCursor(nextId); updateVirtualMirrorMode(); createBtMouseCaptureOverlay(); cursorX = targetScreenWidth / 2f; cursorY = targetScreenHeight / 2f; remoteCursorParams.x = cursorX.toInt(); remoteCursorParams.y = cursorY.toInt(); try { remoteWindowManager?.updateViewLayout(remoteCursorLayout, remoteCursorParams) } catch(e: Exception){}; cursorView?.visibility = View.GONE; updateBorderColor(0xFFFF00FF.toInt()); showToast("Target: Display $nextId"); updateWakeLockState() 
        }
    }

    // =================================================================================
    // VIRTUAL DISPLAY KEEP-ALIVE: Wake Lock Management
    // SUMMARY: Acquires/releases a SCREEN_BRIGHT wake lock when targeting a remote display.
    //          This prevents the system from timing out the display during active use.
    //          Called when cycling target display or when inputTargetDisplayId changes.
    // =================================================================================
    private fun acquireDisplayWakeLock() {
        if (displayWakeLock?.isHeld == true) return // Already held
        try {
            displayWakeLock = powerManager?.newWakeLock(
                PowerManager.SCREEN_BRIGHT_WAKE_LOCK or PowerManager.ACQUIRE_CAUSES_WAKEUP,
                "DroidOS:VirtualDisplayKeepAlive"
            )
            displayWakeLock?.acquire(60 * 60 * 1000L) // 1 hour max, will release manually
            Log.d(TAG, "Display wake lock ACQUIRED for remote display")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to acquire display wake lock", e)
        }
    }

    private fun releaseDisplayWakeLock() {
        try {
            if (displayWakeLock?.isHeld == true) {
                displayWakeLock?.release()
                Log.d(TAG, "Display wake lock RELEASED")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to release display wake lock", e)
        }
        displayWakeLock = null
    }

    private fun pingUserActivity() {
        val now = SystemClock.uptimeMillis()
        if (now - lastUserActivityPing < USER_ACTIVITY_PING_INTERVAL_MS) return
        lastUserActivityPing = now

        // Ping the power manager via shell to reset screen timeout
        Thread {
            try {
                // This simulates user activity on display 0 (main display)
                // Even when using virtual display, we want to keep the physical display awake
                shellService?.runCommand("input keyevent --longpress 0") // KEYCODE_UNKNOWN - no visible effect
            } catch (e: Exception) {
                Log.e(TAG, "Failed to ping user activity", e)
            }
        }.start()
    }

    private fun updateWakeLockState() {
        if (inputTargetDisplayId != currentDisplayId && inputTargetDisplayId >= 0) {
            // Targeting remote/virtual display - acquire wake lock
            acquireDisplayWakeLock()
        } else {
            // Targeting local display - release wake lock
            releaseDisplayWakeLock()
        }
    }
    // =================================================================================
    // END BLOCK: VIRTUAL DISPLAY KEEP-ALIVE Wake Lock Management
    // =================================================================================

    private fun createRemoteCursor(displayId: Int) { try { removeRemoteCursor(); val display = displayManager?.getDisplay(displayId) ?: return; val remoteContext = createTrackpadDisplayContext(display); remoteWindowManager = remoteContext.getSystemService(Context.WINDOW_SERVICE) as WindowManager; remoteCursorLayout = FrameLayout(remoteContext); remoteCursorView = ImageView(remoteContext); remoteCursorView?.setImageResource(R.drawable.ic_cursor); val size = if (prefs.prefCursorSize > 0) prefs.prefCursorSize else 50; remoteCursorLayout?.addView(remoteCursorView, FrameLayout.LayoutParams(size, size)); remoteCursorParams = WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.TYPE_ACCESSIBILITY_OVERLAY, WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS, PixelFormat.TRANSLUCENT); remoteCursorParams.gravity = Gravity.TOP or Gravity.LEFT; val metrics = android.util.DisplayMetrics(); display.getRealMetrics(metrics); remoteCursorParams.x = metrics.widthPixels / 2; remoteCursorParams.y = metrics.heightPixels / 2; remoteWindowManager?.addView(remoteCursorLayout, remoteCursorParams) } catch (e: Exception) { e.printStackTrace() } }
    private fun removeRemoteCursor() { try { if (remoteCursorLayout != null && remoteWindowManager != null) { remoteWindowManager?.removeView(remoteCursorLayout) } } catch (e: Exception) {}; remoteCursorLayout = null; remoteCursorView = null; remoteWindowManager = null }

    // =================================================================================
    // HELPER: Forward Touch to Sibling Windows
    // Used by BT Mouse Capture Overlay to let finger touches reach Trackpad/Keyboard
    // =================================================================================
    private fun forwardTouchToSiblings(event: MotionEvent): Boolean {
        var handled = false
        val rawX = event.rawX
        val rawY = event.rawY

        // 1. Try Menu (Highest Priority)
        if (!handled) {
            handled = menuManager?.dispatchTouchToView(event) == true
        }

        // 2. Try Bubble (High Priority - floats above KB/Trackpad)
        if (!handled && bubbleView != null && bubbleView?.isAttachedToWindow == true) {
             val bView = bubbleView!!
             val loc = IntArray(2)
             bView.getLocationOnScreen(loc)
             val x = loc[0].toFloat()
             val y = loc[1].toFloat()
             
             if (rawX >= x && rawX <= x + bView.width && rawY >= y && rawY <= y + bView.height) {
                 event.offsetLocation(-x, -y)
                 handled = bView.dispatchTouchEvent(event)
                 event.offsetLocation(x, y) // Restore
             }
        }

        // 3. Try Keyboard
        if (!handled && isCustomKeyboardVisible) {
            val kbContainer = keyboardOverlay?.getContainerView()
            if (kbContainer != null && kbContainer.isAttachedToWindow && keyboardOverlay?.isShowing() == true) {
                val loc = IntArray(2)
                kbContainer.getLocationOnScreen(loc)
                val x = loc[0].toFloat()
                val y = loc[1].toFloat()
                
                if (rawX >= x && rawX <= x + kbContainer.width && rawY >= y && rawY <= y + kbContainer.height) {
                    event.offsetLocation(-x, -y)
                    handled = kbContainer.dispatchTouchEvent(event)
                    event.offsetLocation(x, y) // Restore
                }
            }
        }

        // 3. Try Trackpad
        if (!handled && isTrackpadVisible && trackpadLayout != null) {
            val tpView = trackpadLayout!!
            if (tpView.isAttachedToWindow && tpView.visibility == View.VISIBLE) {
                val loc = IntArray(2)
                tpView.getLocationOnScreen(loc)
                val x = loc[0].toFloat()
                val y = loc[1].toFloat()
                
                if (rawX >= x && rawX <= x + tpView.width && rawY >= y && rawY <= y + tpView.height) {
                    event.offsetLocation(-x, -y)
                    handled = tpView.dispatchTouchEvent(event)
                    event.offsetLocation(x, y) // Restore
                }
            }
        }

        return handled
    }

    // =================================================================================
    // BT MOUSE CAPTURE OVERLAY - CREATE    // SUMMARY: Creates a full-screen transparent overlay on the physical display that
    //          intercepts all Bluetooth mouse input when targeting a virtual display.
    // =================================================================================
    private fun createBtMouseCaptureOverlay() {
        Log.w(BT_TAG, "")
        Log.w(BT_TAG, " CREATE REQUESTED: createBtMouseCaptureOverlay()         ")
        Log.w(BT_TAG, "")
        // Log stack trace to see WHO requested creation
        Log.d(BT_TAG, " Trigger Source:", Exception("Creation Stack Trace"))
        Log.d(BT_TAG, " isBtMouseCaptureActive: $isBtMouseCaptureActive")
        Log.d(BT_TAG, " windowManager null?: ${windowManager == null}")
        Log.d(BT_TAG, " inputTargetDisplayId: $inputTargetDisplayId")
        Log.d(BT_TAG, " currentDisplayId: $currentDisplayId")

        if (isBtMouseCaptureActive) {
            Log.d(BT_TAG, " SKIP: Already active")
            return
        }
        if (windowManager == null) {
            Log.e(BT_TAG, " ERROR: windowManager is null!")
            return
        }

        // Reset tracking state
        lastBtMouseX = 0f
        lastBtMouseY = 0f
        isBtMouseDragging = false

        btMouseCaptureLayout = object : FrameLayout(this@OverlayService) {
            
            // [FIX] View-Level Cursor Hiding (Works without Shizuku on API 24+)
            init {
                if (Build.VERSION.SDK_INT >= 24) {
                    try {
                        this.pointerIcon = android.view.PointerIcon.getSystemIcon(context, android.view.PointerIcon.TYPE_NULL)
                    } catch(e: Exception) {}
                }
            }

            override fun dispatchGenericMotionEvent(event: MotionEvent): Boolean {
                val isMouseSource = event.isFromSource(InputDevice.SOURCE_MOUSE) ||
                                    event.isFromSource(InputDevice.SOURCE_MOUSE_RELATIVE)

                // Log.v(BT_TAG, "dispatchGenericMotionEvent: action=${event.actionMasked}, isMouse=$isMouseSource, x=${event.x}, y=${event.y}")

                if (!isMouseSource) {
                    // Log.v(BT_TAG, " Not mouse source, passing to super")
                    return super.dispatchGenericMotionEvent(event)
                }

                when (event.actionMasked) {
                    MotionEvent.ACTION_HOVER_MOVE -> {
                        // Log.d(BT_TAG, "ACTION_HOVER_MOVE: x=${event.x}, y=${event.y}")

                        if (lastBtMouseX == 0f && lastBtMouseY == 0f) {
                            lastBtMouseX = event.x
                            lastBtMouseY = event.y
                            // Log.d(BT_TAG, " First event, recording position")
                            return true
                        }

                        val rawDx = event.x - lastBtMouseX
                        val rawDy = event.y - lastBtMouseY
                        lastBtMouseX = event.x
                        lastBtMouseY = event.y

                        // Log.d(BT_TAG, " Raw delta: dx=$rawDx, dy=$rawDy")

                        val (scaledDx, scaledDy) = scaleBtMouseMovement(rawDx, rawDy)
                        // Log.d(BT_TAG, " Scaled delta: dx=$scaledDx, dy=$scaledDy")

                        handleExternalMouseMove(scaledDx, scaledDy, false)
                        // Log.d(BT_TAG, " Forwarded to handleExternalMouseMove (hover)")
                        return true
                    }

                    MotionEvent.ACTION_SCROLL -> {
                        val vScroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL)
                        val hScroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL)
                        // Log.d(BT_TAG, "ACTION_SCROLL: v=$vScroll, h=$hScroll")
                        injectScroll(hScroll * 10f, vScroll * 10f)
                        return true
                    }

                    MotionEvent.ACTION_HOVER_ENTER -> {
                        // Log.d(BT_TAG, "ACTION_HOVER_ENTER: Mouse entered capture area")
                        return true
                    }

                    MotionEvent.ACTION_HOVER_EXIT -> {
                        // Log.d(BT_TAG, "ACTION_HOVER_EXIT: Mouse exited capture area")
                        return true
                    }
                }

                // Log.v(BT_TAG, " Consuming other mouse generic event: ${event.actionMasked}")
                return true
            }

            override fun dispatchTouchEvent(event: MotionEvent): Boolean {
                val toolType = event.getToolType(0)
                val isMouse = toolType == MotionEvent.TOOL_TYPE_MOUSE || 
                              event.isFromSource(InputDevice.SOURCE_MOUSE)
                
                // Log.v(BT_TAG, "dispatchTouchEvent: action=${event.actionMasked}, toolType=$toolType, isMouse=$isMouse, deviceId=${event.deviceId}")
                
                // =======================================================================
                // FINGER TOUCH FORWARDING
                // Forward finger touches to sibling windows (Trackpad, Keyboard, Menu)
                // because this overlay blocks them.
                // =======================================================================
                if (!isMouse) {
                    // Try to dispatch to siblings
                    if (forwardTouchToSiblings(event)) {
                        return true // Handled by a sibling
                    }
                    
                    // If no sibling handled it, we allow it to "pass through" (return false).
                    // Since we are full-screen, this usually drops the event, but it's safe fallback.
                    return false
                }
                // =======================================================================
                // END: FINGER TOUCH PASSTHROUGH
                // =======================================================================
                
                // Mouse events - we handle and consume these
                // CHECK BUTTON: Use actionButton to distinguish Left vs Right clicks
                val isRightButton = (event.actionButton == MotionEvent.BUTTON_SECONDARY)

                when (event.actionMasked) {
                    MotionEvent.ACTION_DOWN -> {
                        if (isRightButton) {
                             // Log.d(BT_TAG, "MOUSE RIGHT DOWN: Ignored (waiting for UP)")
                        } else {
                             // Log.d(BT_TAG, "MOUSE LEFT DOWN: Starting Touch Stream")
                             lastBtMouseX = event.x
                             lastBtMouseY = event.y
                             isBtMouseDragging = false
                             handleExternalTouchDown()
                        }
                    }
                    
                    MotionEvent.ACTION_MOVE -> {
                        // Only process drag for Left Button
                        // (Right drag is usually not a standard Android touch gesture)
                        val rawDx = event.x - lastBtMouseX
                        val rawDy = event.y - lastBtMouseY
                        
                        if (kotlin.math.abs(rawDx) > 0 || kotlin.math.abs(rawDy) > 0) {
                            isBtMouseDragging = true
                        }
                        
                        lastBtMouseX = event.x
                        lastBtMouseY = event.y
                        
                        val (scaledDx, scaledDy) = scaleBtMouseMovement(rawDx, rawDy)
                        handleExternalMouseMove(scaledDx, scaledDy, true)
                    }
                    
                    MotionEvent.ACTION_UP -> {
                        if (isRightButton) {
                             // Log.d(BT_TAG, "MOUSE RIGHT UP: Performing Right Click")
                             performClick(true)
                        } else {
                             // Log.d(BT_TAG, "MOUSE LEFT UP: Ending Touch Stream")
                             handleExternalTouchUp()
                             // REMOVED: performClick(false)
                             // The handleExternalTouchDown() + handleExternalTouchUp() sequence 
                             // already constitutes a complete click/tap.
                        }
                        isBtMouseDragging = false
                    }
                }
                
                return true // Consume mouse events
            }
        }

        btMouseCaptureLayout?.setBackgroundColor(0x00000000) // Fully transparent

        btMouseCaptureParams = WindowManager.LayoutParams(
            WindowManager.LayoutParams.MATCH_PARENT,
            WindowManager.LayoutParams.MATCH_PARENT,
            WindowManager.LayoutParams.TYPE_ACCESSIBILITY_OVERLAY,
            // FLAG_NOT_TOUCH_MODAL: Allow touches outside to go to other windows
            // FLAG_WATCH_OUTSIDE_TOUCH: Get notified of outside touches (for debugging)
            // NO FLAG_NOT_TOUCHABLE: We need to receive touch events to filter them
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or
            WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL or
            WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or
            WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,
            PixelFormat.TRANSLUCENT
        )
        
        Log.d(BT_TAG, " Flags: NOT_FOCUSABLE | NOT_TOUCH_MODAL | LAYOUT_IN_SCREEN | LAYOUT_NO_LIMITS")
        btMouseCaptureParams?.gravity = Gravity.TOP or Gravity.LEFT

        // Ensure overlay covers entire screen including system bars and cutouts
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            btMouseCaptureParams?.layoutInDisplayCutoutMode = 
                WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES
        }
        
        // Log the actual screen dimensions for debugging
        val metrics = resources.displayMetrics
        Log.d(BT_TAG, " Screen metrics: ${metrics.widthPixels}x${metrics.heightPixels}")
        Log.d(BT_TAG, " uiScreenWidth=$uiScreenWidth, uiScreenHeight=$uiScreenHeight")

        Log.d(BT_TAG, " Created LayoutParams (MATCH_PARENT x MATCH_PARENT)")
        Log.d(BT_TAG, " Flags: NOT_FOCUSABLE | LAYOUT_IN_SCREEN | LAYOUT_NO_LIMITS")

        try {
            windowManager?.addView(btMouseCaptureLayout, btMouseCaptureParams)
            isBtMouseCaptureActive = true
            Log.d(BT_TAG, "  SUCCESS: BT Mouse Capture Overlay ADDED ")
            
            // Hide the system cursor
            hideSystemCursor()
            
            Log.d(BT_TAG, " Overlay active, system cursor hidden")
            showToast("BT Mouse Capture: ON")
        } catch (e: Exception) {
            Log.e(BT_TAG, "  FAILED to add overlay: ${e.message}", e)
            btMouseCaptureLayout = null
        }
    }
    // =================================================================================
    // END BLOCK: BT MOUSE CAPTURE OVERLAY - CREATE
    // =================================================================================

    // =================================================================================
    // BT MOUSE CAPTURE OVERLAY - REMOVE
    // =================================================================================
    private fun removeBtMouseCaptureOverlay() {
        Log.w(BT_TAG, "")
        Log.w(BT_TAG, " REMOVE REQUESTED: removeBtMouseCaptureOverlay()         ")
        Log.w(BT_TAG, "")
        
        // CRITICAL: Log the stack trace to identify the culprit
        Log.w(BT_TAG, ">>> REMOVAL TRIGGER TRACE <<<", Exception("Who called remove?"))
        
        Log.d(BT_TAG, " isBtMouseCaptureActive: $isBtMouseCaptureActive")

        if (!isBtMouseCaptureActive) {
            Log.d(BT_TAG, " SKIP: Not active (Logical state was already false)")
            return
        }

        try {
            btMouseCaptureLayout?.let {
                val attached = it.isAttachedToWindow
                Log.d(BT_TAG, " isAttachedToWindow: $attached")
                if (attached) {
                    windowManager?.removeView(it)
                    Log.d(BT_TAG, "  SUCCESS: Overlay REMOVED ")
                }
            }
        } catch (e: Exception) {
            Log.w(BT_TAG, " Error removing overlay: ${e.message}")
        }

        btMouseCaptureLayout = null
        isBtMouseCaptureActive = false
        lastBtMouseX = 0f
        lastBtMouseY = 0f
        
        // Restore the system cursor
        showSystemCursor()
        
        Log.d(BT_TAG, " Cleanup complete, system cursor restored")
        showToast("BT Mouse Capture: OFF")
    }
    // =================================================================================
    // END BLOCK: BT MOUSE CAPTURE OVERLAY - REMOVE
    // =================================================================================

    // =================================================================================
    // BT MOUSE MOVEMENT SCALING
    // =================================================================================
    private fun scaleBtMouseMovement(rawDx: Float, rawDy: Float): Pair<Float, Float> {
        if (inputTargetDisplayId == currentDisplayId) {
            return Pair(rawDx * prefs.cursorSpeed, rawDy * prefs.cursorSpeed)
        }

        val scaleX = targetScreenWidth.toFloat() / uiScreenWidth.toFloat()
        val scaleY = targetScreenHeight.toFloat() / uiScreenHeight.toFloat()

        val scaledDx = rawDx * scaleX * prefs.cursorSpeed
        val scaledDy = rawDy * scaleY * prefs.cursorSpeed

        // Log.v(BT_TAG, "scaleBtMouseMovement: physical=${uiScreenWidth}x${uiScreenHeight}, " +
        //               "virtual=${targetScreenWidth}x${targetScreenHeight}, " +
        //               "scale=($scaleX, $scaleY), " +
        //               "raw=($rawDx, @rawDy) -> scaled=($scaledDx, $scaledDy)")

        return Pair(scaledDx, scaledDy)
    }
    // =================================================================================
    // END BLOCK: BT MOUSE MOVEMENT SCALING
    // =================================================================================

    // =================================================================================
    // SYSTEM CURSOR VISIBILITY CONTROL
    // SUMMARY: Hides/shows the Android system mouse cursor using reflection.
    //          When BT mouse capture is active, we hide the system cursor so only
    //          our software cursor (remoteCursorLayout) is visible on the virtual display.
    // =================================================================================
    private var systemCursorHidden = false
    
    private fun hideSystemCursor() {
        Log.d(BT_TAG, "hideSystemCursor() called")
        
        // 1. Try Shizuku (System Level)
        if (shellService != null) {
            try {
                shellService?.setSystemCursorVisibility(false)
                systemCursorHidden = true
                Log.d(BT_TAG, "  System cursor HIDDEN via Shizuku")
                return
            } catch (e: Exception) {
                Log.e(BT_TAG, " Shizuku cursor hide failed", e)
            }
        }
        
        // 2. Try Local Reflection (Legacy)
        try {
            val imClass = Class.forName("android.hardware.input.InputManager")
            val getInstance = imClass.getMethod("getInstance")
            val inputManager = getInstance.invoke(null)
            val setCursorVisibility = imClass.getMethod("setCursorVisibility", Boolean::class.javaPrimitiveType)
            setCursorVisibility.invoke(inputManager, false)
            systemCursorHidden = true
            Log.d(BT_TAG, "  System cursor HIDDEN via Local Reflection")
        } catch (e: Exception) {
            Log.w(BT_TAG, " setCursorVisibility not available, trying pointer_speed method")
            // Fallback: Set pointer speed to minimum (doesn't actually hide but reduces visibility)
            try {
                shellService?.runCommand("settings put system pointer_speed -7")
                systemCursorHidden = true
                Log.d(BT_TAG, " Set pointer_speed to -7 (fallback)")
            } catch (e2: Exception) {
                Log.e(BT_TAG, " Failed to hide cursor: ${e2.message}")
            }
        }
    }
    
    private fun showSystemCursor() {
        Log.d(BT_TAG, "showSystemCursor() called")
        if (!systemCursorHidden) {
            Log.d(BT_TAG, " Cursor wasn't hidden, skipping")
            return
        }
        
        // 1. Try Shizuku
        if (shellService != null) {
            try {
                shellService?.setSystemCursorVisibility(true)
                systemCursorHidden = false
                Log.d(BT_TAG, "  System cursor SHOWN via Shizuku")
                return
            } catch (e: Exception) {}
        }
        
        // 2. Try Local Reflection
        try {
            val imClass = Class.forName("android.hardware.input.InputManager")
            val getInstance = imClass.getMethod("getInstance")
            val inputManager = getInstance.invoke(null)
            val setCursorVisibility = imClass.getMethod("setCursorVisibility", Boolean::class.javaPrimitiveType)
            setCursorVisibility.invoke(inputManager, true)
            systemCursorHidden = false
            Log.d(BT_TAG, "  System cursor SHOWN via Local Reflection")
        } catch (e: Exception) {
            Log.w(BT_TAG, " setCursorVisibility not available, trying pointer_speed method")
            try {
                shellService?.runCommand("settings put system pointer_speed 0")
                systemCursorHidden = false
                Log.d(BT_TAG, " Reset pointer_speed to 0 (fallback)")
            } catch (e2: Exception) {
                Log.e(BT_TAG, " Failed to show cursor: ${e2.message}")
            }
        }
    }
    // =================================================================================
    // END BLOCK: SYSTEM CURSOR VISIBILITY CONTROL
    // =================================================================================

    // =================================================================================
    // VIRTUAL MIRROR MODE FUNCTIONS
    // =================================================================================

    /**
     * Creates or removes the mirror keyboard based on Virtual Mirror Mode preference.
     * Called when the preference changes or when switching displays.
     */
    private fun updateVirtualMirrorMode() {
        if (prefs.prefVirtualMirrorMode && inputTargetDisplayId != currentDisplayId) {
            createMirrorKeyboard(inputTargetDisplayId)
        } else {
            removeMirrorKeyboard()
        }
    }

// =================================================================================
    // FUNCTION: createMirrorKeyboard
    // SUMMARY: Creates a transparent keyboard mirror on the remote display.
    //          Stores dimensions for coordinate scaling between physical and mirror.
    //          FIX: Container has NO background - KeyboardView's own #1A1A1A background
    //          ensures tight wrapping. Uses OnLayoutChangeListener to track actual
    //          KeyboardView dimensions for accurate touch sync.
    // =================================================================================
    private fun createMirrorKeyboard(displayId: Int) {
        try {
            removeMirrorKeyboard()

            val display = displayManager?.getDisplay(displayId) ?: return
            val mirrorContext = createTrackpadDisplayContext(display)

            mirrorWindowManager = mirrorContext.getSystemService(Context.WINDOW_SERVICE) as WindowManager
            mirrorKeyboardContainer = FrameLayout(mirrorContext)
            // FIX: NO background on container - let KeyboardView's own background show
            mirrorKeyboardContainer?.setBackgroundColor(Color.TRANSPARENT)
            mirrorKeyboardContainer?.alpha = 0f // Start fully invisible


            // Create KeyboardView for the mirror
            mirrorKeyboardView = KeyboardView(mirrorContext, null, 0)
            mirrorKeyboardView?.setMirrorMode(true) // Disable internal logic
            mirrorKeyboardView?.alpha = 0f // Start fully invisible


            // Apply same scale as physical keyboard
            val scale = prefs.prefKeyScale / 100f
            mirrorKeyboardView?.setScale(scale)

            // Create SwipeTrailView for orientation trail - ORANGE
            mirrorTrailView = SwipeTrailView(mirrorContext)
            mirrorTrailView?.setTrailColor(0xFFFF9900.toInt())

            // Layout params for views - KeyboardView uses WRAP_CONTENT to size naturally
            val kbParams = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT,
                FrameLayout.LayoutParams.WRAP_CONTENT
            )
            val trailParams = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT,
                FrameLayout.LayoutParams.MATCH_PARENT
            )

            mirrorKeyboardContainer?.addView(mirrorKeyboardView, kbParams)
            mirrorKeyboardContainer?.addView(mirrorTrailView, trailParams)

            // Get display metrics
            val metrics = android.util.DisplayMetrics()
            display.getRealMetrics(metrics)

            // Calculate mirror keyboard size - use saved or default width
            val savedWidth = prefs.prefMirrorWidth
            val mirrorWidth = if (savedWidth != -1 && savedWidth > 0) savedWidth else (metrics.widthPixels * 0.95f).toInt()

            // Initialize with placeholder dimensions (will be updated by OnLayoutChangeListener)
            mirrorKbWidth = mirrorWidth.toFloat()
            mirrorKbHeight = 400f

            // Get physical keyboard dimensions
            physicalKbWidth = keyboardOverlay?.getKeyboardView()?.width?.toFloat() ?: 600f
            physicalKbHeight = keyboardOverlay?.getKeyboardView()?.height?.toFloat() ?: 400f

            Log.d(TAG, "Mirror KB init: ${mirrorKbWidth}x${mirrorKbHeight}, Physical KB: ${physicalKbWidth}x${physicalKbHeight}")
// Window params - use saved height or WRAP_CONTENT
            val savedHeight = prefs.prefMirrorHeight
            val mirrorHeight = if (savedHeight != -1 && savedHeight > 0) savedHeight else WindowManager.LayoutParams.WRAP_CONTENT
            
            mirrorKeyboardParams = WindowManager.LayoutParams(
                mirrorWidth,
                mirrorHeight,
                WindowManager.LayoutParams.TYPE_ACCESSIBILITY_OVERLAY,
                WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or
                WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,
                PixelFormat.TRANSLUCENT
            )
            mirrorKeyboardParams?.gravity = Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
            mirrorKeyboardParams?.y = 0
            
            // Apply saved position if available
            val savedX = prefs.prefMirrorX
            val savedY = prefs.prefMirrorY
            
            if (savedX != -1) {
                mirrorKeyboardParams?.x = savedX
                mirrorKeyboardParams?.gravity = Gravity.TOP or Gravity.START
            }
            if (savedY != -1) {
                mirrorKeyboardParams?.y = savedY
            }
            
            // Apply saved alpha
            val savedAlpha = prefs.prefMirrorAlpha / 255f
            mirrorKeyboardContainer?.alpha = savedAlpha

            mirrorWindowManager?.addView(mirrorKeyboardContainer, mirrorKeyboardParams)

            // FIX: Track actual KeyboardView dimensions for accurate touch sync
            // This listener fires after layout, giving us the real measured dimensions
            mirrorKeyboardView?.addOnLayoutChangeListener { _, _, _, _, _, _, _, _, _ ->
                updateMirrorSyncDimensions()
            }

            Log.d(TAG, "Mirror keyboard created on display $displayId")

        } catch (e: Exception) {
            Log.e(TAG, "Failed to create mirror keyboard", e)
        }
    }
    // =================================================================================
    // END BLOCK: createMirrorKeyboard
    // =================================================================================

    /**
     * Removes the mirror keyboard overlay.
     */
    private fun removeMirrorKeyboard() {
        try {
            if (mirrorKeyboardContainer != null && mirrorWindowManager != null) {
                mirrorWindowManager?.removeView(mirrorKeyboardContainer)
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }

        mirrorKeyboardContainer = null
        mirrorKeyboardView = null
        mirrorTrailView = null
        mirrorKeyboardParams = null
        mirrorWindowManager = null

        // Cancel any pending orientation mode timeout
        orientationModeHandler.removeCallbacks(orientationModeTimeout)
        mirrorFadeHandler.removeCallbacks(mirrorFadeRunnable)
        isInOrientationMode = false
    }

    // =================================================================================
    // FUNCTION: updateMirrorSyncDimensions
    // SUMMARY: Updates the scaling dimensions used for touch coordinate sync.
    //          Gets actual measured dimensions from both KeyboardViews to ensure
    //          accurate mapping regardless of container sizes or aspect ratios.
    //          Should be called after any layout change on either keyboard.
    // =================================================================================
    private fun updateMirrorSyncDimensions() {
        // Get physical keyboard's actual KeyboardView dimensions
        // Note: These are the dimensions where touch events are reported
        val physicalView = keyboardOverlay?.getKeyboardView()
        if (physicalView != null && physicalView.width > 0 && physicalView.height > 0) {
            physicalKbWidth = physicalView.width.toFloat()
            physicalKbHeight = physicalView.height.toFloat()
        }
        
        // Get mirror keyboard's actual KeyboardView dimensions
        val mirrorView = mirrorKeyboardView
        if (mirrorView != null && mirrorView.width > 0 && mirrorView.height > 0) {
            mirrorKbWidth = mirrorView.width.toFloat()
            mirrorKbHeight = mirrorView.height.toFloat()
        }
        
        Log.d(TAG, "Mirror sync updated: Physical=${physicalKbWidth}x${physicalKbHeight}, Mirror=${mirrorKbWidth}x${mirrorKbHeight}")
    }
    // =================================================================================
    // END BLOCK: updateMirrorSyncDimensions
    // =================================================================================

    // =================================================================================
    // FUNCTION: syncMirrorKeyboardLayer
    // SUMMARY: Syncs keyboard layer (state) from physical to mirror keyboard.
    //          Called when layer changes (shift, symbols, etc.)
    // =================================================================================
    private fun syncMirrorKeyboardLayer(state: KeyboardView.KeyboardState) {
        mirrorKeyboardView?.setKeyboardState(state)

        // Also sync Ctrl/Alt state
        keyboardOverlay?.getCtrlAltState()?.let { (ctrl, alt) ->
            mirrorKeyboardView?.setCtrlAltState(ctrl, alt)
        }
    }
    // =================================================================================
    // END BLOCK: syncMirrorKeyboardLayer
    // =================================================================================

// =================================================================================
    // FUNCTION: onMirrorKeyboardTouch
    // SUMMARY: Virtual Mirror Mode touch handling.
    //          - Every new touch: Show mirror + orange trail
    //          - After timeout: Switch to blue trail, allow typing
    //          - Single taps (quick touch) should also type after orientation
    //          - HOLD REPEAT: If finger stays on backspace/arrow key during orange
    //            trail, the key will repeat. The orientation timeout is CANCELLED
    //            when on a repeatable key so it stays orange and keeps repeating.
    // @return true to block input, false to allow input
    // =================================================================================

    // =================================================================================
    // FUNCTION: onMirrorKeyboardTouch
    // SUMMARY: Virtual Mirror Mode touch handling.
    // OPTIMIZED: Detects Prediction Bar touches on DOWN to start drag.
    // separates Drag logic from Orientation logic to prevent lag.
    // =================================================================================

    // =================================================================================
    // FUNCTION: onMirrorKeyboardTouch
    // SUMMARY: Virtual Mirror Mode touch handling.
    // FIXED: Restored 'handleDeferredTap' so typing works.
    // ADDED: Safe 'Prediction Bar Drag' detection that bypasses Orange logic.
    // =================================================================================


    // =================================================================================
    // FUNCTION: onMirrorKeyboardTouch
    // SUMMARY: Virtual Mirror Mode touch handling.
    // UPDATED: Added 400ms delay to Blue Mode key repeats to prevent mis-swipes.
    // =================================================================================


    fun onMirrorKeyboardTouch(x: Float, y: Float, action: Int): Boolean {
        if (!isVirtualMirrorModeActive()) return false

        val scaleX = if (physicalKbWidth > 0) mirrorKbWidth / physicalKbWidth else 1f
        val scaleY = if (physicalKbHeight > 0) mirrorKbHeight / physicalKbHeight else 1f
        val mirrorX = x * scaleX
        val mirrorY = y * scaleY

        when (action) {
            MotionEvent.ACTION_DOWN -> {
                // ALWAYS START ORANGE
                isMirrorDragActive = false
                isInOrientationMode = true
                lastOrientX = x; lastOrientY = y

                // FIX: STOP PREVIOUS ANIMATIONS IMMEDIATELY
                // Prevents transparency fighting when typing fast
                mirrorKeyboardView?.animate()?.cancel()
                mirrorFadeHandler.removeCallbacks(mirrorFadeRunnable)
                
                // Force full visibility
                mirrorKeyboardView?.alpha = 0.9f

                mirrorKeyboardContainer?.alpha = 1f

                keyboardOverlay?.setOrientationMode(true)
                mirrorTrailView?.setTrailColor(0xFFFF9900.toInt())
                keyboardOverlay?.setOrientationTrailColor(0xFFFF9900.toInt())

                mirrorTrailView?.clear()
                keyboardOverlay?.clearOrientationTrail()
                keyboardOverlay?.startOrientationTrail(x, y)
                mirrorTrailView?.addPoint(mirrorX, mirrorY)

                orientationModeHandler.removeCallbacks(orientationModeTimeout)
                orientationModeHandler.postDelayed(orientationModeTimeout, prefs.prefMirrorOrientDelayMs)

                stopMirrorKeyRepeat()
                return true
            }

            MotionEvent.ACTION_MOVE -> {
                // 1. DRAG MODE (Blue Trail + Red Backspace)
                if (isMirrorDragActive) {
                     mirrorTrailView?.setTrailColor(0xFF4488FF.toInt())
                     mirrorTrailView?.addPoint(mirrorX, mirrorY)

                     val currentKey = keyboardOverlay?.getKeyAtPosition(x, y)
                     val isBackspace = (currentKey == "BKSP" || currentKey == "" || currentKey == "BACKSPACE")
                     
                     if (isBackspace) isHoveringBackspace = true // Latch

                     if (isBackspace) {
                         mirrorKeyboardView?.highlightKey("BKSP", true, Color.RED)
                     } else {
                         mirrorKeyboardView?.highlightKey("BKSP", false, 0)
                     }

                     val now = SystemClock.uptimeMillis()
                     val event = MotionEvent.obtain(now, now, MotionEvent.ACTION_MOVE, mirrorX, mirrorY, 0)
                     mirrorKeyboardView?.dispatchTouchEvent(event)
                     event.recycle()
                     return true
                }

                // 2. ORANGE MODE
                if (isInOrientationMode) {
                    val dx = x - lastOrientX; val dy = y - lastOrientY
                    if (kotlin.math.sqrt(dx*dx + dy*dy) > MOVEMENT_THRESHOLD) {
                        lastOrientX = x; lastOrientY = y
                        orientationModeHandler.removeCallbacks(orientationModeTimeout)
                        orientationModeHandler.postDelayed(orientationModeTimeout, prefs.prefMirrorOrientDelayMs)
                    }
                    keyboardOverlay?.addOrientationTrailPoint(x, y)
                    mirrorTrailView?.addPoint(mirrorX, mirrorY)
                    return true
                } 
                
                // 3. BLUE MODE
                else {
                    mirrorTrailView?.addPoint(mirrorX, mirrorY)
                    val currentKey = keyboardOverlay?.getKeyAtPosition(x, y)
                    
                    if (currentKey != null && mirrorRepeatableKeys.contains(currentKey)) {
                         if (mirrorRepeatKey == currentKey) return false
                         stopMirrorKeyRepeat()
                         mirrorRepeatKey = currentKey
                         
                         mirrorRepeatHandler.postDelayed({
                             if (mirrorRepeatKey == currentKey && !isInOrientationMode) {
                                 isMirrorRepeating = true
                                 keyboardOverlay?.triggerKeyPress(currentKey)
                                 mirrorRepeatHandler.postDelayed(mirrorRepeatRunnable, MIRROR_REPEAT_INTERVAL)
                             }
                         }, 150) 
                    } else {
                        stopMirrorKeyRepeat()
                    }
                    return false
                }
            }

            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                // 1. END DRAG (Robust Delete)
                if (isMirrorDragActive) {
                     mirrorKeyboardView?.highlightKey("BKSP", false, 0)

                     val upKey = keyboardOverlay?.getKeyAtPosition(x, y)
                     val isDroppedOnBksp = (upKey == "BKSP" || upKey == "" || upKey == "BACKSPACE")
                     

                     if (isHoveringBackspace || isDroppedOnBksp) {
                         // 1. Update Main Logic
                         keyboardOverlay?.blockPrediction(draggedPredictionIndex)
                         
                         // 2. Update Mirror UI Instantly (Make word disappear)
                         mirrorKeyboardView?.removeCandidateAtIndex(draggedPredictionIndex)
                         
                         showToast("Blocked Prediction")
                     } else {

                         val now = SystemClock.uptimeMillis()
                         val event = MotionEvent.obtain(now, now, action, mirrorX, mirrorY, 0)
                         mirrorKeyboardView?.dispatchTouchEvent(event)
                         event.recycle()
                     }
                     
                     mirrorTrailView?.clear()
                     isMirrorDragActive = false
                     isHoveringBackspace = false
                     return true
                }

                // 2. END TOUCH
                orientationModeHandler.removeCallbacks(orientationModeTimeout)
                val wasRepeating = isMirrorRepeating
                stopMirrorKeyRepeat()

                if (isInOrientationMode) {
                    isInOrientationMode = false
                    keyboardOverlay?.setOrientationMode(false)
                    mirrorTrailView?.clear()
                    keyboardOverlay?.clearOrientationTrail()

                    if (!wasRepeating) {
                        keyboardOverlay?.handleDeferredTap(x, y)
                    }
                } else {
                    mirrorTrailView?.clear()
                }

                // Smoothly fade to dim state
                mirrorKeyboardView?.animate()?.alpha(0.3f)?.setDuration(200)?.start()
                mirrorFadeHandler.removeCallbacks(mirrorFadeRunnable)
                mirrorFadeHandler.postDelayed(mirrorFadeRunnable, 2000)


                return false
            }
        }
        return isInOrientationMode
    }






    // =================================================================================
    // END BLOCK: onMirrorKeyboardTouch
    // =================================================================================

    // =================================================================================
    // FUNCTION: stopMirrorKeyRepeat
    // SUMMARY: Stops any active mirror mode key repeat. Called on touch up or when
    //          finger moves off the repeatable key.
    // =================================================================================
    private fun stopMirrorKeyRepeat() {
        mirrorRepeatHandler.removeCallbacks(mirrorRepeatRunnable)
        mirrorRepeatKey = null
        isMirrorRepeating = false
    }
    // =================================================================================
    // END BLOCK: stopMirrorKeyRepeat
    // =================================================================================    // =================================================================================
    // FUNCTION: clearMirrorTrail
    // SUMMARY: Clears the orange orientation trail from the mirror keyboard display.
    // =================================================================================
    private fun clearMirrorTrail() {
        mirrorTrailView?.clear()
    }
    // =================================================================================
    // END BLOCK: clearMirrorTrail
    // =================================================================================

    /**
     * Returns true if Virtual Mirror Mode is currently active.
     */
    private fun isVirtualMirrorModeActive(): Boolean {
        return prefs.prefVirtualMirrorMode &&
               inputTargetDisplayId != currentDisplayId &&
               mirrorKeyboardView != null
    }

    /**
     * Returns true if currently in orientation mode (showing orange trail, blocking input).
     */
    fun isCurrentlyInOrientationMode(): Boolean {
        return isInOrientationMode
    }

    // =================================================================================
    // FUNCTION: toggleVirtualMirrorMode
    // SUMMARY: Enhanced toggle that automatically:
    //          - When ON: Saves current state, switches to virtual display, shows
    //            keyboard and trackpad, loads mirror mode profile
    //          - When OFF: Saves mirror mode profile, restores previous visibility
    //            state, switches back to local display, loads normal profile
    // =================================================================================


    fun toggleVirtualMirrorMode() {
        // 1. Save CURRENT state (before switching)
        // This correctly saves to the OLD profile (VM or STD) before we flip the switch.
        saveLayout() 

        val wasEnabled = prefs.prefVirtualMirrorMode
        prefs.prefVirtualMirrorMode = !wasEnabled

        if (prefs.prefVirtualMirrorMode) {
            // === ENTERING MIRROR MODE ===
            android.util.Log.d(TAG, "Entering Virtual Mirror Mode")

            // Store state for smart-toggle
            preMirrorTrackpadVisible = isTrackpadVisible
            preMirrorKeyboardVisible = isCustomKeyboardVisible
            preMirrorTargetDisplayId = inputTargetDisplayId

            // Switch to virtual display
            val displays = displayManager?.displays ?: emptyArray()
            var targetDisplay: Display? = null
            for (d in displays) { if (d.displayId != currentDisplayId && d.displayId >= 2) { targetDisplay = d; break } }
            if (targetDisplay == null) { for (d in displays) { if (d.displayId != currentDisplayId) { targetDisplay = d; break } } }

            if (targetDisplay != null) {
                inputTargetDisplayId = targetDisplay.displayId
                updateTargetMetrics(inputTargetDisplayId)
                createRemoteCursor(inputTargetDisplayId)
                cursorX = targetScreenWidth / 2f; cursorY = targetScreenHeight / 2f
                remoteCursorParams.x = cursorX.toInt(); remoteCursorParams.y = cursorY.toInt()
                try { remoteWindowManager?.updateViewLayout(remoteCursorLayout, remoteCursorParams) } catch(e: Exception) {}
                cursorView?.visibility = View.GONE
                updateBorderColor(0xFFFF00FF.toInt())

                // Ensure visibility
                if (!isTrackpadVisible) toggleTrackpad()
                if (!isCustomKeyboardVisible) toggleCustomKeyboard(suppressAutomation = true)

                // 2. Load MIRROR Profile (Pref is now true, so this loads VM profile)
                loadLayout()
                updateVirtualMirrorMode()

                showToast("Mirror Mode ON")

                // Create BT Mouse Capture overlay to intercept mouse on physical screen
                createBtMouseCaptureOverlay()

                val intentCycle = Intent("com.katsuyamaki.DroidOSLauncher.CYCLE_DISPLAY")
                intentCycle.setPackage("com.katsuyamaki.DroidOSLauncher")
                sendBroadcast(intentCycle)
            } else {
                prefs.prefVirtualMirrorMode = false
                showToast("No virtual display found.")
            }

        } else {
            // === EXITING MIRROR MODE ===
            android.util.Log.d(TAG, "Exiting Virtual Mirror Mode")

            // [FIX] REMOVED the redundant saveLayout() here.
            // It was overwriting the Standard Profile with the active VM layout
            // because prefVirtualMirrorMode was already set to false above.

            removeMirrorKeyboard()
            // Remove BT Mouse Capture overlay
            removeBtMouseCaptureOverlay()
            inputTargetDisplayId = currentDisplayId
            targetScreenWidth = uiScreenWidth
            targetScreenHeight = uiScreenHeight
            removeRemoteCursor()
            cursorX = uiScreenWidth / 2f; cursorY = uiScreenHeight / 2f
            cursorParams.x = cursorX.toInt(); cursorParams.y = cursorY.toInt()
            try { windowManager?.updateViewLayout(cursorLayout, cursorParams) } catch(e: Exception) {}
            cursorView?.visibility = View.VISIBLE
            updateBorderColor(0x55FFFFFF.toInt())
            
            // 3. Load STANDARD Profile (Pref is now false, so this loads STD profile)
            loadLayout() 

            showToast("Mirror Mode OFF")
            
            val intentCycle = Intent("com.katsuyamaki.DroidOSLauncher.CYCLE_DISPLAY")
            intentCycle.setPackage("com.katsuyamaki.DroidOSLauncher")
            sendBroadcast(intentCycle)
        }
        
        savePrefs()
    }


    // =================================================================================
    // END BLOCK: FUNCTION toggleVirtualMirrorMode
    // =================================================================================

    // =================================================================================
    // END BLOCK: VIRTUAL MIRROR MODE FUNCTIONS
    // =================================================================================

    private fun startTouchDrag() { if (ignoreTouchSequence || isTouchDragging) return; isTouchDragging = true; activeDragButton = MotionEvent.BUTTON_PRIMARY; dragDownTime = SystemClock.uptimeMillis(); injectAction(MotionEvent.ACTION_DOWN, InputDevice.SOURCE_TOUCHSCREEN, activeDragButton, dragDownTime); hasSentTouchDown = true; if (prefs.prefVibrate) vibrate(); updateBorderColor(0xFFFF9900.toInt()) }
    private fun startResize() {}
    private fun startMove() {}
    private fun startKeyDrag(button: Int) { vibrate(); updateBorderColor(0xFF00FF00.toInt()); isKeyDragging = true; activeDragButton = button; dragDownTime = SystemClock.uptimeMillis(); injectAction(MotionEvent.ACTION_DOWN, InputDevice.SOURCE_TOUCHSCREEN, button, dragDownTime); hasSentMouseDown = true }
    private fun stopKeyDrag(button: Int) { if (inputTargetDisplayId != currentDisplayId) updateBorderColor(0xFFFF00FF.toInt()) else updateBorderColor(0x55FFFFFF.toInt()); isKeyDragging = false; if (hasSentMouseDown) { injectAction(MotionEvent.ACTION_UP, InputDevice.SOURCE_TOUCHSCREEN, button, dragDownTime) }; hasSentMouseDown = false }
    private fun handleManualAdjust(intent: Intent) {
        val target = intent.getStringExtra("TARGET") ?: "TRACKPAD"
        val isResize = intent.hasExtra("DW")
        val dx = intent.getIntExtra(if(isResize) "DW" else "DX", 0)
        val dy = intent.getIntExtra(if(isResize) "DH" else "DY", 0)
        manualAdjust(target == "KEYBOARD", isResize, dx, dy)
    }
    private fun handlePreview(intent: Intent) {
        val target = intent.getStringExtra("TARGET") ?: return
        val value = intent.getIntExtra("VALUE", 0)
        when(target) {
            "cursor_size" -> { prefs.prefCursorSize = value; updateCursorSize() }
            "alpha" -> { prefs.prefAlpha = value; updateBorderColor(currentBorderColor) }
            "handle_size" -> { prefs.prefHandleSize = value; updateHandleSize() }
            "scroll_visual" -> { prefs.prefScrollVisualSize = value; updateScrollSize() }
            "handle_touch" -> { prefs.prefHandleTouchSize = value; updateLayoutSizes() }
            "scroll_touch" -> { prefs.prefScrollTouchSize = value; updateScrollSize() }
            "keyboard_scale" -> { prefs.prefKeyScale = value; keyboardOverlay?.updateScale(value / 100f) }
        }
    }
    private fun setTrackpadVisibility(visible: Boolean) { isTrackpadVisible = visible; if (trackpadLayout != null) trackpadLayout?.visibility = if (visible) View.VISIBLE else View.GONE }
    private fun setPreviewMode(preview: Boolean) { isPreviewMode = preview; trackpadLayout?.alpha = if (preview) 0.5f else 1.0f }
    override fun onDisplayAdded(displayId: Int) {}
    override fun onDisplayRemoved(displayId: Int) {}
    override fun onDisplayChanged(displayId: Int) {
        // =================================================================================
        // VIRTUAL DISPLAY PROTECTION
        // SUMMARY: Skip auto-switch logic when targeting a virtual display (ID >= 2).
        //          This prevents the overlay from "crashing" back to physical screens
        //          when display states flicker during virtual display use.
        // =================================================================================
        if (inputTargetDisplayId >= 2) {
            Log.d(TAG, "onDisplayChanged: Ignoring - targeting virtual display $inputTargetDisplayId")
            return
        }
        // =================================================================================
        // END BLOCK: VIRTUAL DISPLAY PROTECTION
        // =================================================================================

        // We only monitor the Main Screen (0) state changes to determine "Open/Closed"
        if (displayId == 0) {
            val display = displayManager?.getDisplay(0)
            val isDebounced = (System.currentTimeMillis() - lastManualSwitchTime > 5000)
            
            if (display != null && isDebounced) {
                // =================================================================================
                // CASE A: Phone Opened (Display 0 turned ON) -> Move to Main (0)
                // SUMMARY: When user unfolds the phone, switch UI to main screen.
                //          ALSO: Fight Samsung's keyboard takeover with delayed restoration.
                // =================================================================================
                if (display.state == Display.STATE_ON && currentDisplayId != 0) {
                    android.util.Log.w(TAG, "")
                    android.util.Log.w(TAG, " PHONE OPENED DETECTED - onDisplayChanged                 ")
                    android.util.Log.w(TAG, "")
                    android.util.Log.w(TAG, " display.state: ${display.state} (STATE_ON=${Display.STATE_ON})")
                    android.util.Log.w(TAG, " currentDisplayId: $currentDisplayId")
                    android.util.Log.w(TAG, " prefBlockSoftKeyboard: ${prefs.prefBlockSoftKeyboard}")
                    android.util.Log.w(TAG, " Scheduling UI switch in 500ms...")
                    
                    handler.postDelayed({
                        try {
                            val timeSinceManual = System.currentTimeMillis() - lastManualSwitchTime
                            android.util.Log.w(TAG, " DELAYED HANDLER EXECUTING")
                            android.util.Log.w(TAG, "   timeSinceManualSwitch: ${timeSinceManual}ms")
                            android.util.Log.w(TAG, "   Will execute: ${timeSinceManual > 5000}")
                            
                            if (timeSinceManual > 5000) {
                                // Pre-restore showMode
                                if (prefs.prefBlockSoftKeyboard) {
                                    if (Build.VERSION.SDK_INT >= 24) {
                                        try {
                                            softKeyboardController.showMode = AccessibilityService.SHOW_MODE_AUTO
                                        } catch (e: Exception) {}
                                    }
                                }
                                
                                android.util.Log.w(TAG, " Calling setupUI(0)...")
                                setupUI(0)
                                resetBubblePosition()
                                android.util.Log.w(TAG, " Phone opened handling complete")
                            }
                        } catch(e: Exception) {
                            android.util.Log.e(TAG, " EXCEPTION: ${e.message}", e)
                        }

                    }, 500)
                }
                    
                // =================================================================================
                // END BLOCK: CASE A - Phone Opened
                // =================================================================================

                // CASE B: Phone Closed (Display 0 turned OFF/DOZE) -> Move to Cover (1)
                else if (display.state != Display.STATE_ON && currentDisplayId == 0) {

                    handler.postDelayed({
                        try {
                            // Double-check state (ensure it didn't just flicker)
                            val d0 = displayManager?.getDisplay(0)
                            if (d0?.state != Display.STATE_ON && 
                                System.currentTimeMillis() - lastManualSwitchTime > 5000) {
                                
                                // [FIX] Only switch if Display 1 actually exists!
                                // This prevents the UI from disappearing on single-screen devices (Beam Pro)
                                // where setupUI(1) would remove the views but fail to re-add them.
                                if (displayManager?.getDisplay(1) != null) {
                                    setupUI(1)
                                    // We don't reset bubble pos here to avoid it jumping if you just locked the screen
                                    // But we do ensure menu is hidden if it was open
                                    menuManager?.hide()
                                }
                            }
                        } catch(e: Exception) {}
                    }, 500)
                }

            }
        }
    }
    
    override fun onDestroy() {
        super.onDestroy()
        try {
            unregisterReceiver(commandReceiver)
        } catch (e: Exception) {
            // Ignore if not registered
        }

        // VIRTUAL DISPLAY KEEP-ALIVE: Release wake lock on destroy
        releaseDisplayWakeLock()
        // =================================================================================
        // END BLOCK: VIRTUAL DISPLAY KEEP-ALIVE onDestroy cleanup
        // =================================================================================
        inputExecutor.shutdownNow() // Stop the worker thread
        if (Build.VERSION.SDK_INT >= 24) { try { softKeyboardController.showMode = AccessibilityService.SHOW_MODE_AUTO } catch (e: Exception) {} }
        Thread { shellService?.runCommand("settings put secure show_ime_with_hard_keyboard 1") }.start()
        try { unregisterReceiver(switchReceiver) } catch(e: Exception){};
        try { val im = getSystemService(Context.INPUT_SERVICE) as InputManager; im.unregisterInputDeviceListener(this) } catch (e: Exception) {}
        if (isBound) ShizukuBinder.unbind(ComponentName(packageName, ShellUserService::class.java.name), userServiceConnection)
    }

    fun forceSystemKeyboardVisible() {
        Thread {
            try {
                // Force setting to 1 (Show)
                shellService?.runCommand("settings put secure show_ime_with_hard_keyboard 1")
            } catch(e: Exception) {}
        }.start()
    }

    private fun showToast(msg: String) { handler.post { android.widget.Toast.makeText(this, msg, android.widget.Toast.LENGTH_SHORT).show() } }
    private fun updateTargetMetrics(displayId: Int) { val display = displayManager?.getDisplay(displayId) ?: return; val metrics = android.util.DisplayMetrics(); display.getRealMetrics(metrics); targetScreenWidth = metrics.widthPixels; targetScreenHeight = metrics.heightPixels }
    


    // =================================================================================
    // FUNCTION: injectKeyFromKeyboard
    // SUMMARY: Injects key events from the overlay keyboard. Routes keys appropriately:
    //          - System/Navigation keys (BACK, FORWARD, VOLUME, etc.) -> ALWAYS shell injection
    //          - Text input keys -> InputConnection if Null KB active, else shell injection
    //
    //          This separation is necessary because InputConnection.sendKeyEvent() only
    //          delivers events to the focused text editor, not to system navigation.
    //          BACK, FORWARD, HOME, VOLUME keys must bypass InputConnection entirely.
    // =================================================================================
    fun injectKeyFromKeyboard(keyCode: Int, metaState: Int) {
        // Update timestamp so we ignore the resulting AccessibilityEvent
        lastInjectionTime = System.currentTimeMillis()

        // NEW: dismiss Voice if active
        checkAndDismissVoice()

        // Define keys that MUST use shell injection (system-level, not text input)
        // These keys don't go through InputConnection because they're navigation/system keys
        val systemKeys = setOf(
            KeyEvent.KEYCODE_BACK,           // Android back navigation
            KeyEvent.KEYCODE_FORWARD,        // Android forward navigation  
            KeyEvent.KEYCODE_HOME,           // Home button
            KeyEvent.KEYCODE_APP_SWITCH,     // Recent apps
            KeyEvent.KEYCODE_VOLUME_UP,      // Volume control
            KeyEvent.KEYCODE_VOLUME_DOWN,    // Volume control
            KeyEvent.KEYCODE_VOLUME_MUTE,    // Volume mute
            KeyEvent.KEYCODE_POWER,          // Power button
            KeyEvent.KEYCODE_SLEEP,          // Sleep
            KeyEvent.KEYCODE_WAKEUP,         // Wake
            KeyEvent.KEYCODE_MEDIA_PLAY,     // Media controls
            KeyEvent.KEYCODE_MEDIA_PAUSE,
            KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE,
            KeyEvent.KEYCODE_MEDIA_STOP,
            KeyEvent.KEYCODE_MEDIA_NEXT,
            KeyEvent.KEYCODE_MEDIA_PREVIOUS,
            KeyEvent.KEYCODE_BRIGHTNESS_UP,  // Brightness
            KeyEvent.KEYCODE_BRIGHTNESS_DOWN
        )

        // Submit to the sequential queue instead of spinning a random thread
        inputExecutor.execute {
            try {
                // SYSTEM KEYS: Always use shell injection (bypasses InputConnection)
                if (keyCode in systemKeys) {
                    Log.d(TAG, "System key detected ($keyCode), using shell injection")
                    shellService?.injectKey(keyCode, KeyEvent.ACTION_DOWN, metaState, inputTargetDisplayId, 1)
                    Thread.sleep(10)
                    shellService?.injectKey(keyCode, KeyEvent.ACTION_UP, metaState, inputTargetDisplayId, 1)
                    return@execute
                }

                // TEXT INPUT KEYS: Route based on active IME
                val currentIme = android.provider.Settings.Secure.getString(contentResolver, "default_input_method") ?: ""
                val isDockActive = currentIme.contains(packageName) && (currentIme.contains("DockInputMethodService") || currentIme.contains("NullInputMethodService"))

                if (isDockActive) {
                    // STRATEGY A: NATIVE via InputConnection (for text input keys only)
                    val intent = Intent("com.example.coverscreentester.INJECT_KEY")

                    intent.setPackage(packageName)
                    intent.putExtra("keyCode", keyCode)
                    intent.putExtra("metaState", metaState)
                    sendBroadcast(intent)
                } else {
                    // STRATEGY B: SHELL INJECTION (Fallback for non-Null keyboards)
                    shellService?.injectKey(keyCode, KeyEvent.ACTION_DOWN, metaState, inputTargetDisplayId, 1)
                    Thread.sleep(10)
                    shellService?.injectKey(keyCode, KeyEvent.ACTION_UP, metaState, inputTargetDisplayId, 1)
                }
            } catch (e: Exception) {
                Log.e(TAG, "Key injection failed", e)
            }
        }
    }
    // =================================================================================
    // END BLOCK: injectKeyFromKeyboard
    // System keys are now always routed through shell injection to ensure they work
    // regardless of which IME is active. Text input keys still use the appropriate
    // method based on the active IME (InputConnection for Null KB, shell for others).
    // =================================================================================


    fun injectBulkDelete(length: Int) {
        if (length <= 0) return
        
        // Update timestamp
        lastInjectionTime = System.currentTimeMillis()

        inputExecutor.execute {
            try {
                // 1. CHECK ACTUAL SYSTEM STATE
                val currentIme = android.provider.Settings.Secure.getString(contentResolver, "default_input_method") ?: ""
                val isDockActive = currentIme.contains(packageName) && (currentIme.contains("DockInputMethodService") || currentIme.contains("NullInputMethodService"))

                if (isDockActive) {
                    // STRATEGY A: NATIVE (Clean & Fast)

                    val intent = Intent("com.example.coverscreentester.INJECT_DELETE")
                    intent.setPackage(packageName)
                    intent.putExtra("length", length)
                    sendBroadcast(intent)
                } else {
                    // STRATEGY B: SHELL INJECTION (Fallback Loop)
                    // Shell is slower, but robust enough if we aren't using the Broadcast method
                    for (i in 0 until length) {
                        shellService?.injectKey(KeyEvent.KEYCODE_DEL, KeyEvent.ACTION_DOWN, 0, inputTargetDisplayId, 1)
                        Thread.sleep(5) // Tiny delay for stability
                        shellService?.injectKey(KeyEvent.KEYCODE_DEL, KeyEvent.ACTION_UP, 0, inputTargetDisplayId, 1)
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Bulk delete failed", e)
            }
        }
    }

    fun injectText(text: String) {
        // Update timestamp so we ignore the resulting AccessibilityEvent
        lastInjectionTime = System.currentTimeMillis()

        inputExecutor.execute {
            try {

                // 1. CHECK ACTUAL SYSTEM STATE
                val currentIme = android.provider.Settings.Secure.getString(contentResolver, "default_input_method") ?: ""
                val isDockActive = currentIme.contains(packageName) && (currentIme.contains("DockInputMethodService") || currentIme.contains("NullInputMethodService"))

                if (isDockActive) {
                    // STRATEGY A: NATIVE (Cleanest)

                    val intent = Intent("com.example.coverscreentester.INJECT_TEXT")
                    intent.setPackage(packageName)
                    intent.putExtra("text", text)
                    sendBroadcast(intent)
                } else {
                    // STRATEGY B: SHELL INJECTION (Fallback)
                    val escapedText = text.replace("\"", "\\\"")
                    val cmd = "input -d $inputTargetDisplayId text \"$escapedText\""
                    shellService?.runCommand(cmd)
                }
            } catch (e: Exception) {
                Log.e(TAG, "Text injection failed", e)
            }
        }
    }

    // =================================================================================
    // INPUT DEVICE LISTENER
    // SUMMARY: Detects mouse connection/disconnection. Re-applies cursor hiding
    //          because Android resets cursor visibility when a mouse reconnects.
    // =================================================================================
    override fun onInputDeviceAdded(deviceId: Int) { handleInputDeviceChange() }
    override fun onInputDeviceRemoved(deviceId: Int) { handleInputDeviceChange() }
    override fun onInputDeviceChanged(deviceId: Int) { handleInputDeviceChange() }

    private fun handleInputDeviceChange() {
        if (isBtMouseCaptureActive) {
            Log.d(BT_TAG, "Input device change detected - Refreshing Cursor Visibility")
            // Re-hide cursor as connection events often reset it to visible
            hideSystemCursor()
        }
    }

    fun switchDisplay() {
        // ACTION: Smart Toggle
        // If we are on Main (0) or Cover (1), we assume we want to go to Virtual.
        if (currentDisplayId == 0 || currentDisplayId == 1) {
            
            // 1. Broadcast: Create Virtual Display
            val intentToggle = Intent("com.katsuyamaki.DroidOSLauncher.TOGGLE_VIRTUAL_DISPLAY")
            intentToggle.setPackage("com.katsuyamaki.DroidOSLauncher")
            sendBroadcast(intentToggle)

            showToast("Initializing Virtual Display...")

            // 2. Wait for display creation, then Cycle
            handler.postDelayed({
                 val intentCycle = Intent("com.katsuyamaki.DroidOSLauncher.CYCLE_DISPLAY")
                 intentCycle.setPackage("com.katsuyamaki.DroidOSLauncher")
                 sendBroadcast(intentCycle)
            }, 1000) // Increased wait time to 1s to be safe
            
        } else {
            // If we are already on Virtual (or other), just cycle back to Main
            val intentCycle = Intent("com.katsuyamaki.DroidOSLauncher.CYCLE_DISPLAY")
            intentCycle.setPackage("com.katsuyamaki.DroidOSLauncher")
            sendBroadcast(intentCycle)
        }
    }
}
```

## File: Cover-Screen-Launcher/app/src/main/java/com/example/quadrantlauncher/FloatingLauncherService.kt
```kotlin
package com.example.quadrantlauncher

import android.accessibilityservice.AccessibilityService
import android.app.ActivityManager
import android.app.Service
import android.view.accessibility.AccessibilityEvent
import android.content.BroadcastReceiver
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.ServiceConnection
import android.content.pm.PackageManager
import android.graphics.BitmapFactory
import android.graphics.PixelFormat
import android.graphics.Rect
import android.graphics.Color
import android.graphics.drawable.GradientDrawable
import android.net.Uri
import android.hardware.display.DisplayManager
import android.media.ImageReader
import android.os.Build
import android.os.Handler
import android.os.IBinder
import android.os.Looper
import android.os.VibrationEffect
import android.os.Vibrator
import android.os.VibratorManager
import android.text.Editable
import android.text.TextWatcher
import android.view.inputmethod.EditorInfo
import android.view.inputmethod.InputMethodManager
import android.util.DisplayMetrics
import android.util.Log
import android.view.*
import android.widget.EditText
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.Toast
import android.widget.TextView
import androidx.core.app.NotificationCompat
import androidx.recyclerview.widget.ItemTouchHelper
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import rikka.shizuku.Shizuku
import java.text.SimpleDateFormat
import java.util.*
import java.lang.reflect.Method
import java.io.BufferedReader
import java.io.InputStreamReader
import kotlin.math.hypot
import kotlin.math.min
import kotlin.math.max
import android.os.PowerManager

class FloatingLauncherService : AccessibilityService() {

    // [NEW] Debug Mode State
    private var isDebugMode = false
    private var debugClickCount = 0
    private var lastDebugClickTime = 0L

    private var virtualDisplay: android.hardware.display.VirtualDisplay? = null
    private var virtualImageReader: ImageReader? = null // Keeps surface alive
    private val ACTION_TOGGLE_VIRTUAL = "com.katsuyamaki.DroidOSLauncher.TOGGLE_VIRTUAL_DISPLAY"

    // === RECEIVER - START ===
    private val launcherReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            when (intent?.action) {
                "com.katsuyamaki.DroidOSTrackpadKeyboard.MOVE_TO_DISPLAY" -> {
                    val targetId = intent.getIntExtra("displayId", 0)
                    Log.d(TAG, "Launcher moving to Display: $targetId")
                    uiHandler.post {
                        // CLEANUP OLD VIEWS (Bubble & Drawer)
                        try {
                            val wm = attachedWindowManager ?: windowManager
                            if (bubbleView != null) {
                                try { wm.removeView(bubbleView) } catch(e: Exception) {}
                            }
                            if (drawerView != null && isExpanded) {
                                try { wm.removeView(drawerView) } catch(e: Exception) {}
                            }
                        } catch (e: Exception) { Log.e(TAG, "Receiver cleanup failed", e) }

                        currentDisplayId = targetId
                        initWindow()
                        isExpanded = false // Reset state for new display
                    }
                }
            }
        }
    }
    // === RECEIVER - END ===
// =================================================================================
    // WAKE LOCK - Prevents screen from turning off while Launcher is active
    // =================================================================================
    private var wakeLock: PowerManager.WakeLock? = null
    private var keepScreenOnEnabled = false
    // =================================================================================
    // END BLOCK: WAKE LOCK
    // =================================================================================
    private val TAG = "FloatingLauncherService"

    companion object {
        // === MODE CONSTANTS - START ===
        // Defines the different drawer modes/tabs
        const val MODE_SEARCH = 0      // App picker tab
        const val MODE_LAYOUTS = 2     // Layout selection (skips 1)
        const val MODE_RESOLUTION = 3  // Resolution settings
        const val MODE_DPI = 4         // DPI settings
        const val MODE_BLACKLIST = 5   // Blacklist management tab
        const val MODE_PROFILES = 6    // Profiles tab
        const val MODE_KEYBINDS = 7    // Keybinds tab
        const val MODE_SETTINGS = 8    // Settings tab
        const val MODE_REFRESH = 9     // [NEW] Refresh Rate Tab
        // === MODE CONSTANTS - END ===
        
        const val LAYOUT_FULL = 1
        const val LAYOUT_SIDE_BY_SIDE = 2
        const val LAYOUT_TOP_BOTTOM = 5
        const val LAYOUT_TRI_EVEN = 3
        const val LAYOUT_CORNERS = 4
        const val LAYOUT_TRI_SIDE_MAIN_SIDE = 6
        const val LAYOUT_QUAD_ROW_EVEN = 7
        const val LAYOUT_QUAD_TALL_SHORT = 8
        const val LAYOUT_HEX_TALL_SHORT = 9
        const val LAYOUT_CUSTOM_DYNAMIC = 99

        const val CHANNEL_ID = "OverlayServiceChannel"
        const val TAG = "FloatingService"
        const val DEBUG_TAG = "DROIDOS_DEBUG"
        const val ACTION_OPEN_DRAWER = "com.katsuyamaki.DroidOSLauncher.OPEN_DRAWER"
        const val ACTION_UPDATE_ICON = "com.katsuyamaki.DroidOSLauncher.UPDATE_ICON"
        const val ACTION_CYCLE_DISPLAY = "com.katsuyamaki.DroidOSLauncher.CYCLE_DISPLAY"
        const val HIGHLIGHT_COLOR = 0xFF00A0E9.toInt()
    }

    private lateinit var windowManager: WindowManager
    // Track the specific WM used to add the bubble to ensure we can remove it later
    private var attachedWindowManager: WindowManager? = null 
    private var displayManager: DisplayManager? = null
    
    private var displayContext: Context? = null
    private var currentDisplayId = 0
    private var lastPhysicalDisplayId = Display.DEFAULT_DISPLAY
    // Tracks the currently focused app package for "Active Window" commands
    private var activePackageName: String? = null
    // History for focus restoration (ignoring overlays)
    private var lastValidPackageName: String? = null
    private var secondLastValidPackageName: String? = null

    // === KEYBIND SYSTEM ===
    private var visualQueueView: View? = null
    private var visualQueueParams: WindowManager.LayoutParams? = null
    private var isVisualQueueVisible = false

    // Command State Machine
    private var pendingCommandId: String? = null

// Custom Modifier State
    private val MOD_CUSTOM = -999 // Internal ID for custom modifier
    private var customModKey = 0

private var isSoftKeyboardSupport = false
    private var isCustomModLatched = false
    // No timer runnable needed - latch stays active until consumed by next key press

    // UI Option Wrapper
    data class CustomModConfigOption(val currentKeyCode: Int)
    private var pendingArg1: Int = -1
    private val commandTimeoutRunnable = Runnable { abortCommandMode() }
    private val COMMAND_TIMEOUT_MS = 5000L

    // Key Picker State
    private var keyPickerView: View? = null
    private var keyPickerParams: WindowManager.LayoutParams? = null

    // Data Classes for Configuration
    data class CommandDef(val id: String, val label: String, val argCount: Int, val description: String)
    data class KeybindOption(val def: CommandDef, var modifier: Int, var keyCode: Int)

    val SUPPORTED_KEYS = linkedMapOf(
        "A" to KeyEvent.KEYCODE_A, "B" to KeyEvent.KEYCODE_B, "C" to KeyEvent.KEYCODE_C,
        "D" to KeyEvent.KEYCODE_D, "E" to KeyEvent.KEYCODE_E, "F" to KeyEvent.KEYCODE_F,
        "G" to KeyEvent.KEYCODE_G, "H" to KeyEvent.KEYCODE_H, "I" to KeyEvent.KEYCODE_I,
        "J" to KeyEvent.KEYCODE_J, "K" to KeyEvent.KEYCODE_K, "L" to KeyEvent.KEYCODE_L,
        "M" to KeyEvent.KEYCODE_M, "N" to KeyEvent.KEYCODE_N, "O" to KeyEvent.KEYCODE_O,
        "P" to KeyEvent.KEYCODE_P, "Q" to KeyEvent.KEYCODE_Q, "R" to KeyEvent.KEYCODE_R,
        "S" to KeyEvent.KEYCODE_S, "T" to KeyEvent.KEYCODE_T, "U" to KeyEvent.KEYCODE_U,
        "V" to KeyEvent.KEYCODE_V, "W" to KeyEvent.KEYCODE_W, "X" to KeyEvent.KEYCODE_X,
        "Y" to KeyEvent.KEYCODE_Y, "Z" to KeyEvent.KEYCODE_Z,
        "0" to KeyEvent.KEYCODE_0, "1" to KeyEvent.KEYCODE_1, "2" to KeyEvent.KEYCODE_2,
        "3" to KeyEvent.KEYCODE_3, "4" to KeyEvent.KEYCODE_4, "5" to KeyEvent.KEYCODE_5,
        "6" to KeyEvent.KEYCODE_6, "7" to KeyEvent.KEYCODE_7, "8" to KeyEvent.KEYCODE_8, "9" to KeyEvent.KEYCODE_9,
        "Left" to KeyEvent.KEYCODE_DPAD_LEFT, "Right" to KeyEvent.KEYCODE_DPAD_RIGHT,
        "Up" to KeyEvent.KEYCODE_DPAD_UP, "Down" to KeyEvent.KEYCODE_DPAD_DOWN,
        "Space" to KeyEvent.KEYCODE_SPACE, "Enter" to KeyEvent.KEYCODE_ENTER,
        "Tab" to KeyEvent.KEYCODE_TAB, "Esc" to KeyEvent.KEYCODE_ESCAPE,
        "Backspace" to KeyEvent.KEYCODE_DEL, "Delete" to KeyEvent.KEYCODE_FORWARD_DEL,
        "Home" to KeyEvent.KEYCODE_MOVE_HOME, "End" to KeyEvent.KEYCODE_MOVE_END,
        "PageUp" to KeyEvent.KEYCODE_PAGE_UP, "PageDn" to KeyEvent.KEYCODE_PAGE_DOWN,
        "F1" to KeyEvent.KEYCODE_F1, "F2" to KeyEvent.KEYCODE_F2, "F3" to KeyEvent.KEYCODE_F3,
        "F4" to KeyEvent.KEYCODE_F4, "F5" to KeyEvent.KEYCODE_F5, "F6" to KeyEvent.KEYCODE_F6,
        "F7" to KeyEvent.KEYCODE_F7, "F8" to KeyEvent.KEYCODE_F8, "F9" to KeyEvent.KEYCODE_F9,
        "F10" to KeyEvent.KEYCODE_F10, "F11" to KeyEvent.KEYCODE_F11, "F12" to KeyEvent.KEYCODE_F12
    )

    val AVAILABLE_COMMANDS = listOf(
        CommandDef("OPEN_DRAWER", "Toggle Drawer", 0, "Show/Hide Launcher"),
        CommandDef("SET_FOCUS", "Set Focus", 1, "Focus app in slot #"),
        CommandDef("FOCUS_LAST", "Focus Last", 0, "Switch to previous app"),
        CommandDef("KILL", "Kill App", 1, "Force stop app in slot"),
        CommandDef("SWAP_ACTIVE_LEFT", "Move Active Left", 0, "Move focused window to prev slot"),
        CommandDef("SWAP_ACTIVE_RIGHT", "Move Active Right", 0, "Move focused window to next slot"),
        CommandDef("MINIMIZE", "Minimize", 1, "Minimize slot (shift others)"),
        CommandDef("UNMINIMIZE", "Restore", 1, "Restore app in slot"),
        CommandDef("HIDE", "Hide (Blank)", 1, "Replace slot with blank space"),
        CommandDef("SWAP", "Swap Slots", 2, "Swap app in Slot A with Slot B")
    )

    // Debounce for display switch to prevent flickering
    private var lastManualSwitchTime = 0L
    private var switchRunnable: Runnable? = null

    // === EXECUTION DEBOUNCE - START ===
    // Prevents multiple rapid executions
    private var lastExecuteTime = 0L
    private val EXECUTE_DEBOUNCE_MS = 500L // Reduced debounce check
    private var pendingLaunchRunnable: Runnable? = null

    // Single-threaded execution lock
    @Volatile private var isExecuting = false
    @Volatile private var pendingExecutionNeeded = false
    @Volatile private var pendingFocusPackage: String? = null
    // === EXECUTION DEBOUNCE - END ===

    private var manualRefreshRateSet = false // [NEW] Prevents auto-force from overwriting user choice

    private var activeRefreshRateLabel: String? = null // [NEW] Track active software limit
    // =================================================================================
    // DISPLAY LISTENER
    // SUMMARY: Monitors display state changes to handle fold/unfold events on foldable devices.
    //          Automatically switches the launcher between main screen (0) and cover screen (1)
    //          based on which display is active.
    //          CRITICAL: Skips auto-switch when on a virtual display (ID >= 2) to prevent
    //          the launcher from jumping back to physical screens during virtual display use.
    // =================================================================================
    private val displayListener = object : DisplayManager.DisplayListener {
        override fun onDisplayAdded(displayId: Int) {}
        override fun onDisplayRemoved(displayId: Int) {
            // If a virtual display (ID >= 2) is removed, release wake lock
            if (displayId >= 2) {
                setKeepScreenOn(false)
            }
            if (displayId == currentDisplayId) {
                // If current display disconnects (e.g. glasses), revert to Default
                performDisplayChange(Display.DEFAULT_DISPLAY)
            }
        }
        override fun onDisplayChanged(displayId: Int) {
            // =================================================================================
            // VIRTUAL DISPLAY PROTECTION
            // SUMMARY: Skip auto-switch logic when targeting a virtual display (ID >= 2).
            //          This prevents the launcher from "crashing" back to physical screens
            //          when display states flicker during virtual display use (e.g., launching apps).
            // =================================================================================
            if (currentDisplayId >= 2) {
                Log.d(TAG, "onDisplayChanged: Ignoring - targeting virtual display $currentDisplayId")
                return
            }
            // =================================================================================
            // END BLOCK: VIRTUAL DISPLAY PROTECTION
            // =================================================================================

            // Logic to detect Fold/Unfold events monitoring Display 0 (Main)
            if (displayId == 0) {
                val display = displayManager?.getDisplay(0)
                // Only auto-switch if user hasn't manually switched recently
                val isDebounced = (System.currentTimeMillis() - lastManualSwitchTime > 2000)
                
                if (display != null && isDebounced) {
                    // Cancel any pending switch to prevent double-execution
                    if (switchRunnable != null) {
                        uiHandler.removeCallbacks(switchRunnable!!)
                    }

                    // CASE A: Phone Opened (Display 0 turned ON) -> Move to Main
                    if (display.state == Display.STATE_ON && currentDisplayId != 0) {
                        switchRunnable = Runnable { 
                            try { performDisplayChange(0) } catch(e: Exception) {} 
                        }
                        uiHandler.postDelayed(switchRunnable!!, 500)
                    } 
                    // CASE B: Phone Closed (Display 0 turned OFF/DOZE) -> Move to Cover (1)
                    else if (display.state != Display.STATE_ON && currentDisplayId == 0) {
                        switchRunnable = Runnable {
                            try { 
                                val d0 = displayManager?.getDisplay(0)
                                if (d0?.state != Display.STATE_ON) { 
                                    performDisplayChange(1) 
                                }
                            } catch(e: Exception) {}
                        }
                        uiHandler.postDelayed(switchRunnable!!, 500)
                    }
                }
            }
        }
    }
    // =================================================================================
    // END BLOCK: DISPLAY LISTENER
    // =================================================================================


    private var bubbleView: View? = null
    private var drawerView: View? = null
    private var debugStatusView: TextView? = null
    
    // [NEW] Persist tiling info for Watchdog recovery
    private val packageRectCache = java.util.concurrent.ConcurrentHashMap<String, Rect>()
    
    // [NEW] Prevent concurrent watchdog threads for the same package
    private val activeEnforcements = java.util.concurrent.ConcurrentHashMap.newKeySet<String>()
    
    private lateinit var bubbleParams: WindowManager.LayoutParams
    private lateinit var drawerParams: WindowManager.LayoutParams

    private var isExpanded = false
    private val selectedAppsQueue = mutableListOf<MainActivity.AppInfo>()
    private val allAppsList = mutableListOf<MainActivity.AppInfo>()
    private val displayList = mutableListOf<Any>()
    
    private var activeProfileName: String? = null
    private var currentMode = MODE_SEARCH
    
    // === KEYBOARD NAVIGATION STATE ===
    private var selectedListIndex = 0
    
    // UI Focus Areas
    private val FOCUS_SEARCH = 0
    private val FOCUS_QUEUE = 1
    private val FOCUS_LIST = 2
    private var currentFocusArea = FOCUS_SEARCH
    
    // Queue Navigation State
    private var queueSelectedIndex = -1
    private var queueCommandPending: CommandDef? = null
    private var queueCommandSourceIndex = -1
    
    // [FIX] Map to track manual minimize toggles to prevent auto-refresh overwriting them
    private val manualStateOverrides = java.util.concurrent.ConcurrentHashMap<String, Long>()
    private val TAB_ORDER = listOf(
        MODE_SEARCH, 
        MODE_LAYOUTS, 
        MODE_RESOLUTION, 
        MODE_REFRESH, 
        MODE_DPI, 
        MODE_BLACKLIST, // [FIX] Reordered to match visual icon order
        MODE_PROFILES, 
        MODE_KEYBINDS, 
        MODE_SETTINGS
    )

    private fun cycleTab(reverse: Boolean) {
        val currentIndex = TAB_ORDER.indexOf(currentMode)
        if (currentIndex == -1) return

        var nextIndex = if (reverse) currentIndex - 1 else currentIndex + 1
        
        // Loop around
        if (nextIndex >= TAB_ORDER.size) nextIndex = 0
        if (nextIndex < 0) nextIndex = TAB_ORDER.size - 1
        
        switchMode(TAB_ORDER[nextIndex])
    }
    // ================================

    private var selectedLayoutType = 2
    private var selectedResolutionIndex = 0
    private var currentDpiSetting = -1
    // [FIX] State tracking to avoid redundant resolution calls/sleeps
    private var lastAppliedResIndex = -1
    private var lastAppliedDpi = -1
    private var currentFontSize = 16f
    
    private var activeCustomRects: List<Rect>? = null
    private var activeCustomLayoutName: String? = null
    
    private var killAppOnExecute = true
    private var autoRestartTrackpad = false // NEW VARIABLE
    private var targetDisplayIndex = 1 
    private var isScreenOffState = false
    private var isInstantMode = true 
    private var showShizukuWarning = true 
    private var useAltScreenOff = false
    
    private var isVirtualDisplayActive = false
    private var currentDrawerHeightPercent = 70
    private var currentDrawerWidthPercent = 90
    private var autoResizeEnabled = true
    private var bottomMarginPercent = 0
    private var topMarginPercent = 0
    
    private var reorderSelectionIndex = -1
    private var isReorderDragEnabled = true
    private var isReorderTapEnabled = true
    
    private val PACKAGE_BLANK = "internal.blank.spacer"
    private val PACKAGE_TRACKPAD = "com.katsuyamaki.DroidOSTrackpadKeyboard"
    
    private var shellService: IShellService? = null
    private var isBound = false
    lateinit var uiHandler: Handler // Declare uiHandler here
    override fun onCreate() {
        super.onCreate()
        
        // Register ADB Receiver
        val filter = IntentFilter().apply {
            addAction("com.katsuyamaki.DroidOSTrackpadKeyboard.MOVE_TO_DISPLAY")
        }
        if (Build.VERSION.SDK_INT >= 33) {
            registerReceiver(launcherReceiver, filter, Context.RECEIVER_EXPORTED)
        } else {
            registerReceiver(launcherReceiver, filter)
        }

        uiHandler = Handler(Looper.getMainLooper())
    }

    private val shizukuBinderListener = Shizuku.OnBinderReceivedListener { if (Shizuku.checkSelfPermission() == PackageManager.PERMISSION_GRANTED) bindShizuku() }
    private val shizukuPermissionListener = Shizuku.OnRequestPermissionResultListener { _, grantResult -> if (grantResult == PackageManager.PERMISSION_GRANTED) bindShizuku() }

    private val commandReceiver = object : BroadcastReceiver() {        override fun onReceive(context: Context?, intent: Intent?) {
            val action = intent?.action
            if (action == ACTION_OPEN_DRAWER) { 
                if (isScreenOffState) wakeUp() else if (!isExpanded) toggleDrawer() 
            } 
            else if (action == ACTION_UPDATE_ICON) { 
                updateBubbleIcon()
                if (currentMode == MODE_SETTINGS) switchMode(MODE_SETTINGS) 
            }
            else if (action == ACTION_CYCLE_DISPLAY) {
                switchDisplay()
            }
            else if (action == Intent.ACTION_SCREEN_ON) {
                if (isScreenOffState) {
                    wakeUp()
                }
} else if (action == ACTION_TOGGLE_VIRTUAL) {
                toggleVirtualDisplay()
            } else if (action == "KEEP_SCREEN_ON" || action == "${packageName}.KEEP_SCREEN_ON") {
                val enable = intent?.getBooleanExtra("ENABLE", true) ?: true
                setKeepScreenOn(enable)
                safeToast(if (enable) "Screen: Always On" else "Screen: Normal Timeout")
            } else if (action == "com.katsuyamaki.DroidOSLauncher.WINDOW_MANAGER") {
                handleWindowManagerCommand(intent)
} else if (action == "com.katsuyamaki.DroidOSLauncher.REQUEST_CUSTOM_MOD_SYNC") {
                // Trackpad is asking for the key, send it
                if (customModKey != 0) {
                    sendCustomModToTrackpad()
                    Log.d(TAG, "Synced Custom Mod ($customModKey) to Trackpad")
                }
            } else if (action == "com.katsuyamaki.DroidOSLauncher.REMOTE_KEY") {
                val keyCode = intent?.getIntExtra("keyCode", 0) ?: 0
                val metaState = intent?.getIntExtra("metaState", 0) ?: 0
                if (keyCode != 0) {
                    // Simulate the event passing through the same logic as hardware keys
                    handleRemoteKeyEvent(keyCode, metaState)
                }
            } else if (action == "com.katsuyamaki.DroidOSLauncher.REQUEST_KEYBINDS") {
                broadcastKeybindsToKeyboard()
            } else if (action == "com.katsuyamaki.DroidOSLauncher.SET_MARGIN_BOTTOM") {
                val percent = intent?.getIntExtra("PERCENT", 0) ?: 0
                bottomMarginPercent = percent
                // Fix: Use outer context 'this@FloatingLauncherService'
                AppPreferences.setBottomMarginPercent(this@FloatingLauncherService, currentDisplayId, percent)
                setupVisualQueue() // Recalc HUD pos
                if (isInstantMode) applyLayoutImmediate()
                
                // Update UI if in settings mode - TARGETED UPDATE
                if (currentMode == MODE_SETTINGS) {
                    uiHandler.post {
                        val adapter = drawerView?.findViewById<RecyclerView>(R.id.rofi_recycler_view)?.adapter
                        if (adapter != null) {
                            for (i in displayList.indices) {
                                val item = displayList[i]
                                if (item is MarginOption && item.type == 1) { // 1 = Bottom Margin
                                    // Replace immutable data object
                                    displayList[i] = MarginOption(1, percent)
                                    adapter.notifyItemChanged(i)
                                    break
                                }
                            }
                        }
                    }
                }
                safeToast("Margin Updated: $percent%")
            }
        }
    }


    private fun broadcastKeybindsToKeyboard() {
        val binds = ArrayList<String>()
        // Iterate AVAILABLE_COMMANDS to ensure defaults are included
        for (cmd in AVAILABLE_COMMANDS) {
            val bind = AppPreferences.getKeybind(this, cmd.id)
            if (bind.second != 0) { // Valid keyCode
                // Format: "modifier|keyCode"
                binds.add("${bind.first}|${bind.second}")
            }
        }

        val intent = Intent("com.katsuyamaki.DroidOSTrackpadKeyboard.UPDATE_KEYBINDS")
        intent.setPackage("com.katsuyamaki.DroidOSTrackpadKeyboard")
        intent.putStringArrayListExtra("KEYBINDS", binds)
        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND)
        sendBroadcast(intent)
        Log.e(TAG, "Broadcasted ${binds.size} keybinds to Keyboard (inc. defaults)")
    }
    // === SWIPE CALLBACK - START ===
    // Handles swipe gestures for various modes including blacklist
    private val swipeCallback = object : ItemTouchHelper.SimpleCallback(0, ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT) {
        override fun getMovementFlags(r: RecyclerView, v: RecyclerView.ViewHolder): Int {
            val pos = v.adapterPosition; if (pos == RecyclerView.NO_POSITION || pos >= displayList.size) return 0
            val item = displayList[pos]
            val isSwipeable = when (currentMode) {
                MODE_LAYOUTS -> (item is LayoutOption && item.type == LAYOUT_CUSTOM_DYNAMIC && item.isCustomSaved)
                MODE_RESOLUTION -> (item is ResolutionOption && item.index >= 100)
                MODE_PROFILES -> (item is ProfileOption && !item.isCurrent)
                MODE_SEARCH -> true
                MODE_BLACKLIST -> true
                else -> false
            }
            return if (isSwipeable) makeMovementFlags(0, ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT) else 0
        }
        override fun onMove(r: RecyclerView, v: RecyclerView.ViewHolder, t: RecyclerView.ViewHolder): Boolean = false
        override fun onSwiped(v: RecyclerView.ViewHolder, direction: Int) {
            val pos = v.adapterPosition; if (pos == RecyclerView.NO_POSITION) return
            dismissKeyboardAndRestore()
            if (currentMode == MODE_PROFILES) { val item = displayList.getOrNull(pos) as? ProfileOption ?: return; AppPreferences.deleteProfile(this@FloatingLauncherService, item.name); safeToast("Deleted ${item.name}"); switchMode(MODE_PROFILES); return }
            if (currentMode == MODE_LAYOUTS) { val item = displayList.getOrNull(pos) as? LayoutOption ?: return; AppPreferences.deleteCustomLayout(this@FloatingLauncherService, item.name); safeToast("Deleted ${item.name}"); switchMode(MODE_LAYOUTS); return }
            if (currentMode == MODE_RESOLUTION) { val item = displayList.getOrNull(pos) as? ResolutionOption ?: return; AppPreferences.deleteCustomResolution(this@FloatingLauncherService, item.name); safeToast("Deleted ${item.name}"); switchMode(MODE_RESOLUTION); return }
            if (currentMode == MODE_SEARCH) {
                val item = displayList.getOrNull(pos) as? MainActivity.AppInfo ?: return
                if (item.packageName == PACKAGE_BLANK) { (drawerView!!.findViewById<RecyclerView>(R.id.rofi_recycler_view).adapter as RofiAdapter).notifyItemChanged(pos); return }
                // Left swipe = blacklist app
                if (direction == ItemTouchHelper.LEFT) {
                    val identifier = item.getIdentifier()
                    AppPreferences.addToBlacklist(this@FloatingLauncherService, identifier)
                    safeToast("${item.label} blacklisted")
                    loadInstalledApps()
                    refreshSearchList()
                }
                // Right swipe = toggle favorite (legacy behavior)
                else if (direction == ItemTouchHelper.RIGHT) {
                    toggleFavorite(item)
                    refreshSearchList()
                }
            }
            if (currentMode == MODE_BLACKLIST) {
                val item = displayList.getOrNull(pos) as? MainActivity.AppInfo ?: return
                // Left swipe = remove from blacklist
                if (direction == ItemTouchHelper.LEFT) {
                    val identifier = item.getIdentifier()
                    AppPreferences.removeFromBlacklist(this@FloatingLauncherService, identifier)
                    safeToast("${item.label} removed from blacklist")
                    loadInstalledApps()
                    loadBlacklistedApps()
                }
            }
        }
    }
    // === SWIPE CALLBACK - END ===

    private val selectedAppsDragCallback = object : ItemTouchHelper.SimpleCallback(ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT, ItemTouchHelper.UP or ItemTouchHelper.DOWN) {
        override fun isLongPressDragEnabled(): Boolean = isReorderDragEnabled
        override fun onMove(r: RecyclerView, v: RecyclerView.ViewHolder, t: RecyclerView.ViewHolder): Boolean { Collections.swap(selectedAppsQueue, v.adapterPosition, t.adapterPosition); r.adapter?.notifyItemMoved(v.adapterPosition, t.adapterPosition); return true }
        override fun onSwiped(v: RecyclerView.ViewHolder, direction: Int) { 
            dismissKeyboardAndRestore()
            val pos = v.adapterPosition
            if (pos != RecyclerView.NO_POSITION) { 
                val app = selectedAppsQueue[pos]
                if (app.packageName != PACKAGE_BLANK) { 
                    removeFromFocusHistory(app.packageName) // Clean up history
                    Thread { try { shellService?.forceStop(app.packageName) } catch(e: Exception) {} }.start()
                    safeToast("Killed ${app.label}") 
                }
                selectedAppsQueue.removeAt(pos)
                if (reorderSelectionIndex != -1) endReorderMode(false)
                updateAllUIs()
                if (isInstantMode) applyLayoutImmediate() 
            } 
        }
        override fun clearView(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder) { super.clearView(recyclerView, viewHolder); val pkgs = selectedAppsQueue.map { it.packageName }; AppPreferences.saveLastQueue(this@FloatingLauncherService, pkgs); if (isInstantMode) applyLayoutImmediate() }
    }

    // === SWIPE DETECTOR - START ===
    // Detects horizontal swipe gestures for blacklist/favorite actions
    // Left swipe = blacklist, Long press = favorite
    private inner class SwipeDetector : GestureDetector.SimpleOnGestureListener() {
        private val SWIPE_THRESHOLD = 100
        private val SWIPE_VELOCITY_THRESHOLD = 100

        override fun onFling(
            e1: MotionEvent?,
            e2: MotionEvent,
            velocityX: Float,
            velocityY: Float
        ): Boolean {
            if (e1 == null) return false

            val diffX = e2.x - e1.x
            val diffY = e2.y - e1.y

            if (Math.abs(diffX) > Math.abs(diffY)) {
                if (Math.abs(diffX) > SWIPE_THRESHOLD && Math.abs(velocityX) > SWIPE_VELOCITY_THRESHOLD) {
                    if (diffX < 0) {
                        return true // Left swipe detected
                    }
                }
            }
            return false
        }
    }
    // === SWIPE DETECTOR - END ===

    private val userServiceConnection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, binder: IBinder?) {
            shellService = IShellService.Stub.asInterface(binder)
            isBound = true
            updateExecuteButtonColor(true)
            updateBubbleIcon()
            safeToast("Shizuku Connected")

            // NEW: Auto-Restart Trackpad if enabled
            if (autoRestartTrackpad) {
                uiHandler.postDelayed({ restartTrackpad() }, 1000) // Delay to ensure stability
            }
        }
        override fun onServiceDisconnected(name: ComponentName?) { shellService = null; isBound = false; updateExecuteButtonColor(false); updateBubbleIcon() }
    }


    // === FUNCTION: restartTrackpad - START ===
    // [FIX] Uses Settings.Secure to read permissions (avoids build error) and Shell to write them




    private fun restartTrackpad() {
        safeToast("Restarting Trackpad...")
        Thread {
            try {
                // 1. Save Target Display
                val targetId = currentDisplayId
                Log.d(TAG, "Saving Target Display ID: $targetId")
                shellService?.runCommand("settings put global droidos_target_display $targetId")
                
                val pkgName = "com.katsuyamaki.DroidOSTrackpadKeyboard"
                val legacyPkg = "com.example.coverscreentester"
                val serviceComponent = "$pkgName/com.example.coverscreentester.OverlayService"
                
                // 2. DISABLE SERVICE (Reset Crash Backoff)
                val currentList = android.provider.Settings.Secure.getString(
                    contentResolver, 
                    android.provider.Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES
                ) ?: ""
                
                if (currentList.contains("OverlayService")) {
                    val newList = currentList.replace(":$serviceComponent", "")
                                           .replace("$serviceComponent:", "")
                                           .replace(serviceComponent, "")
                    shellService?.runCommand("settings put secure enabled_accessibility_services $newList")
                    Log.d(TAG, "Service Disabled")
                }

                // 3. FORCE STOP
                shellService?.runCommand("am force-stop $pkgName")
                shellService?.runCommand("am force-stop $legacyPkg")
                
                // [FIX] INCREASED WAIT: 500ms -> 2000ms
                // Give the system 2 full seconds to clean up the dead process.
                Thread.sleep(2000)

                // 4. RE-ENABLE SERVICE
                val cleanList = android.provider.Settings.Secure.getString(
                    contentResolver, 
                    android.provider.Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES
                ) ?: ""

                val enableList = if (cleanList.isEmpty() || cleanList == "null") {
                    serviceComponent
                } else {
                    "$cleanList:$serviceComponent"
                }
                
                Log.d(TAG, "Enabling Service...")
                shellService?.runCommand("settings put secure enabled_accessibility_services $enableList")
                shellService?.runCommand("settings put secure accessibility_enabled 1")

                // [FIX] WAKE UP DELAY: 500ms -> 1500ms
                // Wait another 1.5s before sending the Wake-Up command
                Thread.sleep(1500) 
                
                val serviceCmd = "am start-foreground-service -n $serviceComponent --ez force_start true"
                shellService?.runCommand(serviceCmd)
                
                val legacyCmd = "am start-foreground-service -n $legacyPkg/com.example.coverscreentester.OverlayService --ez force_start true"
                shellService?.runCommand(legacyCmd)

            } catch (e: Exception) {
                Log.e(TAG, "Shell Restart Failed", e)
                
                // [FIX] ADD FALLBACK DELAY
                // If the shell failed, we still want to wait before blindly launching the app
                Thread.sleep(2000)
                
                uiHandler.post { 
                    safeToast("Restart Failed: ${e.message}")
                    launchTrackpad() 
                }
            }
        }.start()
    }






    // === FUNCTION: restartTrackpad - END ===



// =================================================================================
    // FUNCTION: setKeepScreenOn
    // SUMMARY: Acquires or releases a wake lock to prevent screen timeout.
    //          Call with true when AR glasses/virtual display is active.
    //          Call with false when returning to normal use.
    // =================================================================================
    private fun setKeepScreenOn(enable: Boolean) {
        if (enable == keepScreenOnEnabled) return
        
        try {
            if (enable) {
                if (wakeLock == null) {
                    val powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
                    wakeLock = powerManager.newWakeLock(
                        PowerManager.SCREEN_BRIGHT_WAKE_LOCK or PowerManager.ACQUIRE_CAUSES_WAKEUP,
                        "DroidOSLauncher:KeepScreenOn"
                    )
                }
                wakeLock?.acquire(60 * 60 * 1000L) // 1 hour max, will re-acquire as needed
                keepScreenOnEnabled = true
                Log.i(TAG, "Wake lock ACQUIRED - screen will stay on")
            } else {
                wakeLock?.let {
                    if (it.isHeld) {
                        it.release()
                    }
                }
                keepScreenOnEnabled = false
                Log.i(TAG, "Wake lock RELEASED - normal screen timeout")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Wake lock error: ${e.message}")
        }
    }
    // =================================================================================
    // END BLOCK: setKeepScreenOn
    // =================================================================================




    private fun launchShizuku() { try { val intent = packageManager.getLaunchIntentForPackage("moe.shizuku.privileged.api"); if (intent != null) { intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent) } else { safeToast("Shizuku app not found") } } catch(e: Exception) { safeToast("Failed to launch Shizuku") } }

    private fun handleSoftKeyInput(event: AccessibilityEvent) {
        // Guard: Only run if feature enabled and custom key set
        if (!isSoftKeyboardSupport || customModKey == 0) return
        
        // Guard: Only care about text additions
        if (event.addedCount < 1) return
        
        val textList = event.text
        if (textList.isEmpty()) return
        
        val sequence = textList[0].toString()
        if (sequence.isEmpty()) return

        // Check the last typed character
        val typedChar = sequence.last()
        val typedCode = getKeyCodeFromChar(typedChar)

Log.d(TAG, "SoftKey: Typed '$typedChar' -> Code $typedCode. CustomMod: $customModKey. Latched: $isCustomModLatched")
        
        if (typedCode == 0) return

        // 1. IS IT THE MODIFIER?
        if (typedCode == customModKey) {
            isCustomModLatched = true
            // No timer - stays latched until next key press
            
            // Delete the character
            Thread { 
                shellService?.injectKey(KeyEvent.KEYCODE_DEL, KeyEvent.ACTION_DOWN, 0, currentDisplayId, -1)
                Thread.sleep(10)
                shellService?.injectKey(KeyEvent.KEYCODE_DEL, KeyEvent.ACTION_UP, 0, currentDisplayId, -1)
            }.start()
            
            safeToast("Custom Mod Active (Soft)")
            return
        }

        // 2. IS IT A COMMAND (WHILE LATCHED)?
        if (isCustomModLatched) {
            // Scan commands for match
            for (cmd in AVAILABLE_COMMANDS) {
                val bind = AppPreferences.getKeybind(this, cmd.id)
                // If binding uses Custom Mod AND matches typed key
                if (bind.first == MOD_CUSTOM && bind.second == typedCode) {
                    
                    // Delete character
                    Thread { 
                        shellService?.injectKey(KeyEvent.KEYCODE_DEL, KeyEvent.ACTION_DOWN, 0, currentDisplayId, -1)
                        Thread.sleep(10)
                        shellService?.injectKey(KeyEvent.KEYCODE_DEL, KeyEvent.ACTION_UP, 0, currentDisplayId, -1)
                    }.start()

                    triggerCommand(cmd)

                    isCustomModLatched = false
                    return
                }
            }
        }
        
        // 3. NUMBER INPUT FOR HUD
        if (pendingCommandId != null) {
            if (Character.isDigit(typedChar)) {
                val num = typedChar - '0'
                // Delete character
                Thread {
                    shellService?.injectKey(KeyEvent.KEYCODE_DEL, KeyEvent.ACTION_DOWN, 0, currentDisplayId, -1)
                    Thread.sleep(10)
                    shellService?.injectKey(KeyEvent.KEYCODE_DEL, KeyEvent.ACTION_UP, 0, currentDisplayId, -1)
                }.start()

                handleCommandInput(num)
                return
            } else {
                // Non-digit typed -> Abort
                abortCommandMode()
                // Let the character stay - if they typed "a" to cancel, they probably want "a"
                return
            }
        }
    }

    override fun onKeyEvent(event: KeyEvent): Boolean {
        if (event.action != KeyEvent.ACTION_DOWN) return false

        val keyCode = event.keyCode
        val metaState = event.metaState

        // CHECK CUSTOM MODIFIER
        if (customModKey != 0 && keyCode == customModKey) {
            isCustomModLatched = true
            // No timer - stays latched until next key press // 5 second latch
            safeToast("Custom Mod Active...")
            return true // Consume the key
        }

        // DEBUG: Log every key press
        val keyName = KeyEvent.keyCodeToString(keyCode)
        // WORKAROUND: KeyEvent.metaStateToString may be unresolved in some environments.
        // Using toString() directly on the integer for debug output.
        val metaStr = if (metaState != 0) "Meta($metaState)" else "None"
        Log.d("DroidOS_Keys", "INPUT: Key=$keyName($keyCode) Meta=$metaStr($metaState)")

        // 1. INPUT MODE (Entering Numbers)
        if (pendingCommandId != null) {
            if (keyCode == KeyEvent.KEYCODE_ESCAPE) {
                abortCommandMode()
                return true
            }

            // Handle Numbers (Row 0-9 and Numpad 0-9)
            val num = keyEventToNumber(keyCode)
            if (num != -1) {
                handleCommandInput(num)
                return true
            }

            // NEW: If any non-number key is pressed while HUD is open, CANCEL IT.
            // This prevents the HUD from getting stuck if the user changes their mind
            // and starts typing a sentence.
            abortCommandMode()
            return true // Consume the "cancel" key so it doesn't type into app
        }

        // 2. TRIGGER MODE (Detecting Hotkeys)
        // Check if this key matches any stored bind
        var commandTriggered = false

        for (cmd in AVAILABLE_COMMANDS) {
            val bind = AppPreferences.getKeybind(this, cmd.id)

            // Check if key code matches
            if (bind.second != 0 && bind.second == keyCode) {
                Log.d("DroidOS_Keys", " -> Key Match for '${cmd.label}'. Checking modifiers...")
                Log.d("DroidOS_Keys", "    Required: ${bind.first} | Current: $metaState")

                if (checkModifiers(metaState, bind.first)) {
                    Log.d("DroidOS_Keys", "    MATCH! Triggering...")
                    triggerCommand(cmd)
                    commandTriggered = true
                    break
                } else {
                    Log.d("DroidOS_Keys", "    Modifier Mismatch.")
                }
            }
        }

        // AUTO-RESET LATCH: If we were latched, any key press (valid command or not) consumes the latch.
        if (isCustomModLatched) {
            isCustomModLatched = false
            safeToast(if (commandTriggered) "Command Executed" else "Command Cancelled")
            return true
        }

        if (commandTriggered) return true

        return super.onKeyEvent(event)
    }

    // Shared logic for both Hardware Keys (onKeyEvent) and Virtual Remote Keys (Broadcast)
    private fun handleRemoteKeyEvent(keyCode: Int, metaState: Int) {
        val keyName = KeyEvent.keyCodeToString(keyCode)
        Log.d("DroidOS_Keys", "RECEIVER: handleRemoteKeyEvent called with $keyCode (Meta: $metaState)")

        // CHECK CUSTOM MODIFIER (Remote/Broadcast)
        if (customModKey != 0) {
            Log.d("DroidOS_Keys", "Checking Custom Mod: Recv($keyCode) vs Saved($customModKey)")

            if (keyCode == customModKey) {
                isCustomModLatched = true
                // No timer - stays latched until next key press
                safeToast("Custom Mod Active (Remote)")
                Log.d("DroidOS_Keys", "Custom Mod LATCHED via Broadcast")
                return
            }
        }

        val metaStr = if (metaState != 0) "Meta($metaState)" else "None"
        Log.d("DroidOS_Keys", "REMOTE INPUT: Key=$keyName($keyCode) Meta=$metaStr($metaState)")

        // 1. INPUT MODE (Entering Numbers for Visual Queue)
        if (pendingCommandId != null) {
            if (keyCode == KeyEvent.KEYCODE_ESCAPE) {
                abortCommandMode()
                return
            }
            val num = keyEventToNumber(keyCode)
            if (num != -1) {
                handleCommandInput(num)
                return
            }

            // NEW: If any non-number key is pressed while HUD is open, CANCEL IT.
            abortCommandMode()
            return
        }

        // 2. TRIGGER MODE (Detecting Hotkeys)
        var commandTriggered = false

        for (cmd in AVAILABLE_COMMANDS) {
            val bind = AppPreferences.getKeybind(this, cmd.id)

            if (bind.second != 0 && bind.second == keyCode) {
                // Check modifiers
                if (checkModifiers(metaState, bind.first)) {
                    Log.d("DroidOS_Keys", "    MATCH! Triggering via Remote...")
                    triggerCommand(cmd)
                    commandTriggered = true
                    break
                }
            }
        }

        // AUTO-RESET LATCH: If we were latched, any key press (valid command or not) consumes the latch.
        if (isCustomModLatched) {
            isCustomModLatched = false
            safeToast(if (commandTriggered) "Command Executed" else "Command Cancelled")
            return
        }

        if (commandTriggered) return
    }

    private fun checkModifiers(currentMeta: Int, requiredMeta: Int): Boolean {
        if (requiredMeta == 0) return true
        
        // Custom Modifier Logic
        if (requiredMeta == MOD_CUSTOM) {
            // Log.d(TAG, "Checking CSTM: latched=$isCustomModLatched")
            return isCustomModLatched
        }
        
        // Standard Android Meta Flags
        return (currentMeta and requiredMeta) != 0
    }

    private fun keyEventToNumber(code: Int): Int {
        return when (code) {
            in KeyEvent.KEYCODE_0..KeyEvent.KEYCODE_9 -> code - KeyEvent.KEYCODE_0
            in KeyEvent.KEYCODE_NUMPAD_0..KeyEvent.KEYCODE_NUMPAD_9 -> code - KeyEvent.KEYCODE_NUMPAD_0
            else -> -1
        }
    }

    private fun triggerCommand(cmd: CommandDef) {
        if (cmd.argCount == 0) {
            // Immediate
            Log.d("DroidOS_Keys", "Executing Immediate Command: ${cmd.id}")
            val intent = Intent().putExtra("COMMAND", cmd.id)
            handleWindowManagerCommand(intent)
            safeToast("Executed: ${cmd.label}")
        } else {
            // Enter Input Mode
            pendingCommandId = cmd.id
            pendingArg1 = -1
            showVisualQueue("${cmd.label}: Enter Slot #")
        }
    }

    private fun handleCommandInput(number: Int) {
        // Convert input 1-based to 0-based
        if (number == 0) return // 0 is invalid for 1-based slot
        val slotIndex = number - 1

        val cmd = AVAILABLE_COMMANDS.find { it.id == pendingCommandId } ?: return

        if (pendingArg1 == -1) {
            // First Arg Received
            pendingArg1 = slotIndex

            if (cmd.argCount == 1) {
                // Done! Execute (1 Arg)
                val intent = Intent().putExtra("COMMAND", cmd.id).putExtra("INDEX", number)
                handleWindowManagerCommand(intent)
                hideVisualQueue()
                pendingCommandId = null
            } else {
                // Need Second Arg
                showVisualQueue("${cmd.label}: Swap with?", slotIndex)
            }
        } else {
            // Second Arg Received (only supported for 2-arg commands like SWAP)
            val intent = Intent()
                .putExtra("COMMAND", cmd.id)
                .putExtra("INDEX_A", pendingArg1 + 1) // Convert back to 1-based for handler
                .putExtra("INDEX_B", number)

            handleWindowManagerCommand(intent)
            hideVisualQueue()
            pendingCommandId = null
        }
    }

    // AccessibilityService required overrides
    override fun onAccessibilityEvent(event: AccessibilityEvent?) {
        if (event == null) return

        // [EFFICIENCY] IMMEDIATE FILTER
        // Ignore high-frequency events that we don't use
        if (event.eventType == AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED ||
            event.eventType == AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED ||
            event.eventType == AccessibilityEvent.TYPE_VIEW_SCROLLED) {
            return
        }

        // 1. WATCHDOG LOGIC (Direct Event Handling)
        // If we are targeting a Virtual Display (ID >= 2), monitor Display 1 (Cover) for escapes.
        if (currentDisplayId >= 2 && event.displayId == 1) {
            val pkg = event.packageName?.toString()
            
            // Filter out safe system apps
            if (!pkg.isNullOrEmpty() && 
                pkg != packageName && 
                pkg != PACKAGE_TRACKPAD && 
                pkg != "com.android.systemui" && 
                pkg != "com.sec.android.app.launcher" && 
                !pkg.contains("inputmethod")) {
                
                // Only act on state changes (app opening/resuming)
                if (event.eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED) {
                    Log.w("DROIDOS_WATCHDOG", "ESCAPE DETECTED: $pkg on Cover (D1). Triggering Recovery to D$currentDisplayId")
                    forceAppToDisplay(pkg, currentDisplayId)
                }
            }
        }

        // --- IMPROVED ACTIVE WINDOW TRACKING (Display Aware) ---
        // Prioritizes events from the current display (Virtual Display for Glasses).
        // Filters getWindows() by displayId to avoid false positives from Phone Screen.
        try {
            if (event.eventType == AccessibilityEvent.TYPE_WINDOWS_CHANGED ||
                event.eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED ||
                event.eventType == AccessibilityEvent.TYPE_VIEW_FOCUSED) {

                var detectedPkg: String? = null
                var foundOnTargetDisplay = false

                // 1. Check Event Source (Most accurate for user interaction)
                // If the event comes from the display we are managing, trust it.
                if (Build.VERSION.SDK_INT >= 30) {
                    if (event.displayId == currentDisplayId && !event.packageName.isNullOrEmpty()) {
                        detectedPkg = event.packageName.toString()
                        foundOnTargetDisplay = true
                    }
                }

                // 2. Try Native Window API (Poll state)
                // Only if event didn't give us a definitive answer for this display
                if (!foundOnTargetDisplay && windows != null && windows.isNotEmpty()) {
                    var fallbackPkg: String? = null

                    for (window in windows) {
                        if (window.type == android.view.accessibility.AccessibilityWindowInfo.TYPE_APPLICATION && window.isFocused) {
                            val node = window.root
                            if (node != null) {
                                val pkg = node.packageName?.toString()
                                node.recycle()

                                // API 30+: Check if this window is on our target display
                                if (Build.VERSION.SDK_INT >= 30) {
                                    if (window.displayId == currentDisplayId) {
                                        detectedPkg = pkg
                                        foundOnTargetDisplay = true
                                        break
                                    }
                                }
                                // Capture focused window from ANY display as fallback
                                if (fallbackPkg == null) fallbackPkg = pkg
                            }
                        }
                    }

                    // If we didn't find a window on the target display, use the system-wide focused one
                    if (detectedPkg == null) detectedPkg = fallbackPkg
                }

                // 3. Last Resort Fallback (Pre-API 30 or empty windows)
                if (detectedPkg == null) {
                     detectedPkg = event.packageName?.toString()
                }

                // Filter & Update History
                if (!detectedPkg.isNullOrEmpty() &&
                    detectedPkg != packageName &&
                    detectedPkg != "com.android.systemui" &&
                    detectedPkg != PACKAGE_TRACKPAD &&
                    !detectedPkg.contains("inputmethod")) {

                    // Update history if package changed
                    if (activePackageName != detectedPkg) {
                        secondLastValidPackageName = lastValidPackageName
                        // [FIX] Don't overwrite history with null if we manually cleared activePackageName
                        // This preserves "Focus Last" functionality after minimizing an app
                        if (activePackageName != null) {
                            lastValidPackageName = activePackageName
                        }
                        activePackageName = detectedPkg

                        // Update UI to show underline for new focus
                        uiHandler.post { updateAllUIs() }
                    }
                }
            }
        } catch (e: Exception) {
            // Fallback: Event-based detection if windows API fails
             val pkg = event.packageName?.toString()
            if (!pkg.isNullOrEmpty() &&
                pkg != packageName &&
                pkg != "com.android.systemui" &&
                pkg != PACKAGE_TRACKPAD &&
                (event.eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED ||
                 event.eventType == AccessibilityEvent.TYPE_VIEW_FOCUSED)) {

                activePackageName = pkg
            }
        }

        // 2. SOFT KEYBOARD TRIGGER SUPPORT (Toggleable)
        if (isSoftKeyboardSupport && event.eventType == AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED) {
            handleSoftKeyInput(event)
        }
    }
    override fun onInterrupt() {}

    // AccessibilityService entry point - called when user enables service in Settings
    override fun onServiceConnected() {
        super.onServiceConnected()
        Log.d(TAG, "Accessibility Service Connected")

        // Initialize WindowManager
        windowManager = getSystemService(WINDOW_SERVICE) as WindowManager
        displayManager = getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
        displayManager?.registerDisplayListener(displayListener, uiHandler)

        // Register receivers
        val filter = IntentFilter().apply {
            addAction(ACTION_OPEN_DRAWER)
            addAction(ACTION_UPDATE_ICON)
            addAction(ACTION_CYCLE_DISPLAY)
            addAction(Intent.ACTION_SCREEN_ON)
            addAction(Intent.ACTION_SCREEN_OFF)
            addAction("KEEP_SCREEN_ON")
            addAction("com.katsuyamaki.DroidOSLauncher.WINDOW_MANAGER")
            addAction("com.katsuyamaki.DroidOSLauncher.REQUEST_CUSTOM_MOD_SYNC")
            addAction("com.katsuyamaki.DroidOSLauncher.REQUEST_KEYBINDS") // [FIX] Added this
            addAction("com.katsuyamaki.DroidOSLauncher.REMOTE_KEY")
            addAction("com.katsuyamaki.DroidOSLauncher.SET_MARGIN_BOTTOM") // [FIX] Sync Margin
        }
        if (Build.VERSION.SDK_INT >= 33) registerReceiver(commandReceiver, filter, Context.RECEIVER_EXPORTED) else registerReceiver(commandReceiver, filter)


        // Shizuku setup
        try { Shizuku.addBinderReceivedListener(shizukuBinderListener); Shizuku.addRequestPermissionResultListener(shizukuPermissionListener) } catch (e: Exception) {}
        try { if (rikka.shizuku.Shizuku.checkSelfPermission() == PackageManager.PERMISSION_GRANTED) bindShizuku() } catch (e: Exception) {}

        // Load preferences
        loadInstalledApps(); currentFontSize = AppPreferences.getFontSize(this)
        killAppOnExecute = AppPreferences.getKillOnExecute(this); targetDisplayIndex = AppPreferences.getTargetDisplayIndex(this)
        autoRestartTrackpad = AppPreferences.getAutoRestartTrackpad(this) // NEW LOAD
        isInstantMode = AppPreferences.getInstantMode(this); showShizukuWarning = AppPreferences.getShowShizukuWarning(this)
        useAltScreenOff = AppPreferences.getUseAltScreenOff(this); isReorderDragEnabled = AppPreferences.getReorderDrag(this)
        isReorderTapEnabled = AppPreferences.getReorderTap(this); currentDrawerHeightPercent = AppPreferences.getDrawerHeightPercent(this)
        currentDrawerWidthPercent = AppPreferences.getDrawerWidthPercent(this); autoResizeEnabled = AppPreferences.getAutoResizeKeyboard(this)
        // Margins now loaded in loadDisplaySettings()

        // Load Custom Mod
        customModKey = AppPreferences.getCustomModKey(this)

        isSoftKeyboardSupport = AppPreferences.getSoftKeyboardSupport(this)

        // Sync Custom Mod to Trackpad
        sendCustomModToTrackpad()

        // Sync Keybinds to Trackpad
        broadcastKeybindsToKeyboard()

        // Debug Loaded Keys
        logSavedKeybinds()

        // Build UI
        val targetDisplayId = targetDisplayIndex
        setupDisplayContext(targetDisplayId)
        setupBubble()
        setupDrawer()

        // --- IMMEDIATE RESTORE ---
        // Ensure Visual Queue is populated before user interaction
        restoreQueueFromPrefs()
        // -------------------------

        updateGlobalFontSize()
        updateBubbleIcon()
        loadDisplaySettings(currentDisplayId) // Layout loading is now inside here

        safeToast("Launcher Ready")
    }

    private fun sendCustomModToTrackpad() {
        val intent = Intent("com.katsuyamaki.DroidOSTrackpadKeyboard.SET_CUSTOM_MOD")
        intent.setPackage(PACKAGE_TRACKPAD)
        intent.putExtra("KEYCODE", customModKey)
        sendBroadcast(intent)
    }

    /* * FUNCTION: onStartCommand
     * SUMMARY: Updated to strictly handle display migration. If an ID is passed,
     * it forces the bubble to move to that display context immediately.
     */
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Priority: 1. Explicit ID from Intent (Triggered by Icon Click) 2. Last saved Physical ID
        val targetDisplayId = intent?.getIntExtra("DISPLAY_ID", currentDisplayId) ?: currentDisplayId

        Log.d(TAG, "onStartCommand: Target Display $targetDisplayId (Current: $currentDisplayId)")

        if (bubbleView != null) {
            // If we are already running but the target display changed, move the bubble
            if (targetDisplayId != currentDisplayId) {
                try {
                    windowManager.removeView(bubbleView)
                    if (isExpanded) windowManager.removeView(drawerView)
                } catch (e: Exception) {
                    Log.e(TAG, "Error removing views for migration", e)
                }
                setupDisplayContext(targetDisplayId)
                setupBubble()
                setupDrawer()
                updateBubbleIcon()
                loadDisplaySettings(currentDisplayId)
                isExpanded = false
                safeToast("Recalled to Display $targetDisplayId")

                // [FIX] Apply layout immediately if in Instant Mode
                if (isInstantMode) {
                    uiHandler.postDelayed({ applyLayoutImmediate() }, 500)
                }
            }
        } else {
            // First time initialization
            try {
                setupDisplayContext(targetDisplayId)
                setupBubble()
                setupDrawer()
                
                updateGlobalFontSize()
                updateBubbleIcon()
                loadDisplaySettings(currentDisplayId) // Layout loading is now inside here

                if (rikka.shizuku.Shizuku.checkSelfPermission() == PackageManager.PERMISSION_GRANTED) bindShizuku()
            } catch (e: Exception) {
                Log.e(TAG, "Setup failed", e)
                stopSelf()
            }
        }
        return START_NOT_STICKY
    }
    


    private fun loadDisplaySettings(displayId: Int) { 
        // 1. Margins (Per Display)
        topMarginPercent = AppPreferences.getTopMarginPercent(this, displayId)
        bottomMarginPercent = AppPreferences.getBottomMarginPercent(this, displayId)
        
        // 2. Layout & Custom Rects (Per Display)
        selectedLayoutType = AppPreferences.getLastLayout(this, displayId)
        activeCustomLayoutName = AppPreferences.getLastCustomLayoutName(this, displayId)
        
        if (selectedLayoutType == LAYOUT_CUSTOM_DYNAMIC && activeCustomLayoutName != null) {
            val data = AppPreferences.getCustomLayoutData(this, activeCustomLayoutName!!)
            if (data != null) {
                try {
                    val rects = mutableListOf<Rect>()
                    val rectParts = data.split("|")
                    for (rp in rectParts) {
                        val coords = rp.split(",")
                        if (coords.size == 4) rects.add(Rect(coords[0].toInt(), coords[1].toInt(), coords[2].toInt(), coords[3].toInt()))
                    }
                    activeCustomRects = rects
                } catch(e: Exception) {
                    Log.e(TAG, "Failed to load custom rects", e)
                }
            }
        }
        
        selectedResolutionIndex = AppPreferences.getDisplayResolution(this, displayId)
        
        // [FIX] On fresh install, grab the CURRENT system DPI instead of defaulting to -1 (Reset).
        // This prevents the "everything got huge" issue where "reset" reverts to a factory default
        // that is different from what the user was actually using.
        val savedDpi = AppPreferences.getDisplayDpi(this, displayId)
        
        if (savedDpi == -1) {
            val currentSystemDpi = displayContext?.resources?.configuration?.densityDpi ?: 0
            if (currentSystemDpi > 0) {
                currentDpiSetting = currentSystemDpi
                // Save it immediately so it becomes the baseline preference
                AppPreferences.saveDisplayDpi(this, displayId, currentDpiSetting)

                Log.d(TAG, "Initialized DPI from System: $currentDpiSetting")
            } else {
                currentDpiSetting = -1
            }
        } else {
            currentDpiSetting = savedDpi
        }
        
        // FIX: Sync state tracking to prevent unnecessary sleep on first execution
        lastAppliedResIndex = selectedResolutionIndex
        lastAppliedDpi = currentDpiSetting

        // [REMOVED] Auto-force disabled to prevent getting stuck on 120Hz
        // checkAndForceHighRefreshRate(displayId)
    }


    // =================================================================================
    // REFRESH RATE MANAGER
    // SUMMARY: Scans supported modes for the current display. If 120Hz (or higher) is found,
    //          it attempts to force it via Window Attributes (for this app) and Shell (System-wide).
    // =================================================================================


    // =================================================================================
    // REFRESH RATE MANAGER
    // =================================================================================
    private fun checkAndForceHighRefreshRate(displayId: Int) {
        if (displayId == 0) return 
        if (manualRefreshRateSet) return // [FIX] Don't override user's manual setting

        try {
            val display = displayManager?.getDisplay(displayId) ?: return
            val supportedModes = display.supportedModes
            
            var maxRate = 60f
            var bestModeId = -1
            
            for (mode in supportedModes) {
                if (mode.refreshRate > maxRate) {
                    maxRate = mode.refreshRate
                    bestModeId = mode.modeId
                }
            }

            // Only auto-force if we found a high refresh rate (>60)
            if (maxRate > 60f) {
                Log.i(TAG, "Auto-Force $maxRate Hz (Mode $bestModeId)")

                uiHandler.post {
                    try {
                        if (bubbleView != null && bubbleView?.isAttachedToWindow == true) {
                            bubbleParams.preferredDisplayModeId = bestModeId
                            val wm = attachedWindowManager ?: windowManager
                            wm.updateViewLayout(bubbleView, bubbleParams)
                        }
                    } catch (e: Exception) {}
                }
                
                val mode = supportedModes.find { it.modeId == bestModeId }
                if (mode != null && shellService != null) {
                    val cmd = "cmd display set-user-preferred-display-mode $displayId ${mode.physicalWidth} ${mode.physicalHeight} ${mode.refreshRate}"
                    Thread { try { shellService?.runCommand(cmd) } catch(e: Exception) {} }.start()
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Refresh Rate Error", e)
        }
    }




    override fun onDestroy() {
        super.onDestroy()
        try { unregisterReceiver(launcherReceiver) } catch(e: Exception) {}
        isScreenOffState = false
        wakeUp()
        try { Shizuku.removeBinderReceivedListener(shizukuBinderListener); Shizuku.removeRequestPermissionResultListener(shizukuPermissionListener); unregisterReceiver(commandReceiver) } catch (e: Exception) {}
        
        // Robust cleanup using attached manager
        try { 
            if (bubbleView != null) {
                val wm = attachedWindowManager ?: windowManager
                wm.removeView(bubbleView) 
            }
        } catch (e: Exception) {}
        
        try { 
            if (isExpanded) windowManager.removeView(drawerView) 
        } catch (e: Exception) {}

        if (isBound) { try { ShizukuBinder.unbind(ComponentName(packageName, ShellUserService::class.java.name), userServiceConnection); isBound = false } catch (e: Exception) {} }
    setKeepScreenOn(false)
    wakeLock = null
    }
    
    // === SAFE TOAST FUNCTION - START ===
    // Displays toast message and updates debug status view
    private fun safeToast(msg: String) { 
        uiHandler.post { 
            try { Toast.makeText(applicationContext, msg, Toast.LENGTH_SHORT).show() } catch(e: Exception) { }
            if (debugStatusView != null) debugStatusView?.text = msg 
        }
    }
    // === SAFE TOAST FUNCTION - END ===

    // === DEBUG APP IDENTIFICATION - START ===
    // Visual debug function to show package/activity when apps are opened/modified/identified
    // This displays in the bright green text area above the app queue in the launcher drawer
    private fun debugShowAppIdentification(action: String, pkg: String, className: String?) {
        // [FIX] Only run if Debug Mode is enabled
        if (!isDebugMode) return

        val basePkg = if (pkg.contains(":")) pkg.substringBefore(":") else pkg
        val suffix = if (pkg.contains(":")) pkg.substringAfter(":") else null
        
        // Get short class name for display
        val shortCls = when {
            className.isNullOrEmpty() -> "NO_CLASS"
            className == "null" -> "NO_CLASS"
            else -> className.substringAfterLast(".")
        }
        
        val debugText = buildString {
            append("[$action] ")
            append("pkg=${basePkg.substringAfterLast(".")}")  // Show only last part of package
            if (suffix != null) append(":$suffix")
            append(" cls=$shortCls")
        }
        
        uiHandler.post {
            debugStatusView?.text = debugText
            // Also log full details
            Log.d(DEBUG_TAG, "[$action] FULL: pkg=$pkg cls=$className")
        }
    }
    // === DEBUG APP IDENTIFICATION - END ===
    
    private fun vibrate() {
        try {
            if (Build.VERSION.SDK_INT >= 31) {
                val vibratorManager = getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager
                val vibrator = vibratorManager.defaultVibrator
                vibrator.vibrate(VibrationEffect.createOneShot(50, VibrationEffect.DEFAULT_AMPLITUDE))
            } else {
                val vibrator = getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
                vibrator.vibrate(50)
            }
        } catch (e: Exception) {}
    }

    private fun setupDisplayContext(displayId: Int) {
        val dm = getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
        val display = dm.getDisplay(displayId)
        if (display == null) { 
            windowManager = getSystemService(WINDOW_SERVICE) as WindowManager
            return 
        }
        currentDisplayId = displayId
        
        val baseContext = createDisplayContext(display)
        // Use TYPE_ACCESSIBILITY_OVERLAY (2032) for AccessibilityService
        displayContext = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            baseContext.createWindowContext(2032, null)
        } else {
            baseContext
        }
        
        windowManager = displayContext!!.getSystemService(Context.WINDOW_SERVICE) as WindowManager
    }
    private fun refreshDisplayId() { val id = displayContext?.display?.displayId ?: Display.DEFAULT_DISPLAY; currentDisplayId = id }
    private fun startForegroundService() { val channelId = if (android.os.Build.VERSION.SDK_INT >= 26) { val channel = android.app.NotificationChannel(CHANNEL_ID, "Floating Launcher", android.app.NotificationManager.IMPORTANCE_LOW); getSystemService(android.app.NotificationManager::class.java).createNotificationChannel(channel); CHANNEL_ID } else ""; val notification = NotificationCompat.Builder(this, channelId).setContentTitle("CoverScreen Launcher Active").setSmallIcon(R.drawable.ic_launcher_bubble).setPriority(NotificationCompat.PRIORITY_MIN).build(); if (android.os.Build.VERSION.SDK_INT >= 34) startForeground(1, notification, android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_SPECIAL_USE) else startForeground(1, notification) }
    private fun bindShizuku() { try { val component = ComponentName(packageName, ShellUserService::class.java.name); ShizukuBinder.bind(component, userServiceConnection, true, 1) } catch (e: Exception) { Log.e(TAG, "Bind Shizuku Failed", e) } }
    private fun updateExecuteButtonColor(isReady: Boolean) { uiHandler.post { val executeBtn = drawerView?.findViewById<ImageView>(R.id.icon_execute); if (isReady) executeBtn?.setColorFilter(Color.GREEN) else executeBtn?.setColorFilter(Color.RED) } }

    private fun setupBubble() {
        val context = displayContext ?: this
        val themeContext = ContextThemeWrapper(context, R.style.Theme_QuadrantLauncher)
        bubbleView = LayoutInflater.from(themeContext).inflate(R.layout.layout_bubble, null)
        bubbleView?.isClickable = true; bubbleView?.isFocusable = true 
        // [FIX] Disable system focus highlight to prevent ugly borders/grey overlay
        if (Build.VERSION.SDK_INT >= 26) bubbleView?.defaultFocusHighlightEnabled = false
        
        // Z-ORDER UPDATE: Try ACCESSIBILITY_OVERLAY (2032) + FLAG_LAYOUT_NO_LIMITS
        val targetType = if (Build.VERSION.SDK_INT >= 26) 2032 else WindowManager.LayoutParams.TYPE_PHONE 
        
        bubbleParams = WindowManager.LayoutParams(
            WindowManager.LayoutParams.WRAP_CONTENT, 
            WindowManager.LayoutParams.WRAP_CONTENT, 
            targetType, 
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or 
            WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or 
            WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS or 
            WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH, 
            PixelFormat.TRANSLUCENT
        )
        
        // Calculate center Y considering margin
        val display = windowManager.defaultDisplay
        val metrics = DisplayMetrics()
        display.getRealMetrics(metrics)
        val h = metrics.heightPixels
        
        val topPx = (h * topMarginPercent / 100f).toInt()
        val bottomPx = (h * bottomMarginPercent / 100f).toInt()
        val effectiveH = h - topPx - bottomPx
        
        // Absolute Y position = TopMargin + Half Effective Height
        val centerY = topPx + (effectiveH / 2)
        
        bubbleParams.gravity = Gravity.TOP or Gravity.START; bubbleParams.x = 50; bubbleParams.y = centerY
        
        // ... (Keep existing OnTouchListener logic here) ...
        var velocityTracker: VelocityTracker? = null
        bubbleView?.setOnTouchListener(object : View.OnTouchListener {
            var initialX = 0; var initialY = 0; var initialTouchX = 0f; var initialTouchY = 0f; var isDrag = false
            override fun onTouch(v: View, event: MotionEvent): Boolean {
                if (velocityTracker == null) velocityTracker = VelocityTracker.obtain(); velocityTracker?.addMovement(event)
                when (event.action) {
                    MotionEvent.ACTION_DOWN -> { initialX = bubbleParams.x; initialY = bubbleParams.y; initialTouchX = event.rawX; initialTouchY = event.rawY; isDrag = false; return true }
                    MotionEvent.ACTION_MOVE -> { if (Math.abs(event.rawX - initialTouchX) > 10 || Math.abs(event.rawY - initialTouchY) > 10) isDrag = true; if (isDrag) { bubbleParams.x = initialX + (event.rawX - initialTouchX).toInt(); bubbleParams.y = initialY + (event.rawY - initialTouchY).toInt(); windowManager.updateViewLayout(bubbleView, bubbleParams) }; return true }
                    MotionEvent.ACTION_UP -> {
                        velocityTracker?.computeCurrentVelocity(1000)
                        val vX = velocityTracker?.xVelocity ?: 0f
                        val vY = velocityTracker?.yVelocity ?: 0f
                        val totalVel = hypot(vX.toDouble(), vY.toDouble())

                        // [SAFETY] FLING RESET: Easier threshold (1500) + Hard Kill
                        if (isDrag && totalVel > 1500) {
                            safeToast("Force Closing Launcher...")

                            // 1. Force Screen On
                            isScreenOffState = false
                            wakeUp()

                            // 2. Kill Process
                            stopSelf()
                            android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
                                android.os.Process.killProcess(android.os.Process.myPid())
                                java.lang.System.exit(0)
                            }, 200)

                            return true
                        }

                        if (!isDrag) {
                            if (!isBound && showShizukuWarning) {
                                if (Shizuku.checkSelfPermission() == PackageManager.PERMISSION_GRANTED) {
                                    bindShizuku()
                                } else {
                                    safeToast("Shizuku NOT Connected. Opening Shizuku...")
                                    launchShizuku()
                                }
                            } else {
                                toggleDrawer()
                            }
                        }
                        velocityTracker?.recycle()
                        velocityTracker = null
                        return true
                    }
                    MotionEvent.ACTION_CANCEL -> { velocityTracker?.recycle(); velocityTracker = null }
                }
                return false
            }
        })

        // Z-ORDER UPDATE: Try High Z-Order, Fallback to App Overlay if denied
        try {
            windowManager.addView(bubbleView, bubbleParams)
            attachedWindowManager = windowManager
        } catch (e: Exception) {
            try {
                bubbleParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
                windowManager.addView(bubbleView, bubbleParams)
                attachedWindowManager = windowManager
            } catch (e2: Exception) {
                Log.e(TAG, "Error adding bubble", e2)
            }
        }
    }
    
    private fun updateBubbleIcon() { val iconView = bubbleView?.findViewById<ImageView>(R.id.bubble_icon) ?: return; if (!isBound && showShizukuWarning) { uiHandler.post { iconView.setImageResource(android.R.drawable.ic_dialog_alert); iconView.setColorFilter(Color.RED); iconView.imageTintList = null }; return }; uiHandler.post { try { val uriStr = AppPreferences.getIconUri(this); if (uriStr != null) { val uri = Uri.parse(uriStr); val input = contentResolver.openInputStream(uri); val bitmap = BitmapFactory.decodeStream(input); input?.close(); if (bitmap != null) { iconView.setImageBitmap(bitmap); iconView.imageTintList = null; iconView.clearColorFilter() } else { iconView.setImageResource(R.drawable.ic_launcher_bubble); iconView.imageTintList = null; iconView.clearColorFilter() } } else { iconView.setImageResource(R.drawable.ic_launcher_bubble); iconView.imageTintList = null; iconView.clearColorFilter() } } catch (e: Exception) { iconView.setImageResource(R.drawable.ic_launcher_bubble); iconView.imageTintList = null; iconView.clearColorFilter() } } }
    private fun dismissKeyboardAndRestore() { val searchBar = drawerView?.findViewById<EditText>(R.id.rofi_search_bar); if (searchBar != null && searchBar.hasFocus()) { searchBar.clearFocus(); val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager; imm.hideSoftInputFromWindow(searchBar.windowToken, 0) }; val dpiInput = drawerView?.findViewById<EditText>(R.id.input_dpi_value); if (dpiInput != null && dpiInput.hasFocus()) { dpiInput.clearFocus(); val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager; imm.hideSoftInputFromWindow(dpiInput.windowToken, 0) }; updateDrawerHeight(false) }

    // [NEW] Brings the Black Wallpaper to front.
    // This effectively minimizes whatever app is currently top, preventing the "Last App" freeze.
    private fun showWallpaper() {
        try {
            val intent = Intent(this, MainActivity::class.java)
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            intent.putExtra("WALLPAPER_MODE", true)
            val options = android.app.ActivityOptions.makeBasic()
            options.setLaunchDisplayId(currentDisplayId)
            startActivity(intent, options.toBundle())
        } catch (e: Exception) {
            Log.e(TAG, "Failed to show wallpaper", e)
        }
    }

    private fun setupDrawer() {
        val context = displayContext ?: this
        val themeContext = ContextThemeWrapper(context, R.style.Theme_QuadrantLauncher)
        drawerView = LayoutInflater.from(themeContext).inflate(R.layout.layout_rofi_drawer, null)
        drawerView!!.fitsSystemWindows = true 
        // [FIX] Disable system focus highlight (prevents screen turning grey when drawer is focused)
        if (Build.VERSION.SDK_INT >= 26) drawerView!!.defaultFocusHighlightEnabled = false
        
        // Z-ORDER UPDATE: Match Bubble settings
        val targetType = if (Build.VERSION.SDK_INT >= 26) 2032 else WindowManager.LayoutParams.TYPE_PHONE 

        drawerParams = WindowManager.LayoutParams(
            WindowManager.LayoutParams.MATCH_PARENT, 
            WindowManager.LayoutParams.MATCH_PARENT, 
            targetType, 
            WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or 
            WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS, 
            PixelFormat.TRANSLUCENT
        )
        drawerParams.gravity = Gravity.TOP or Gravity.START; drawerParams.x = 0; drawerParams.y = 0
        drawerParams.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING
        
        // FIXED: Ensure container is defined and logical
        val container = drawerView?.findViewById<LinearLayout>(R.id.drawer_container)
        if (container != null) {
            val lp = container.layoutParams as? FrameLayout.LayoutParams
            if (lp != null) { lp.gravity = Gravity.TOP or Gravity.CENTER_HORIZONTAL; lp.topMargin = 100; container.layoutParams = lp }

            debugStatusView = TextView(context)
            debugStatusView?.text = "Ready"
            debugStatusView?.setTextColor(Color.GREEN)
            debugStatusView?.textSize = 10f
            debugStatusView?.gravity = Gravity.CENTER
            
            // [FIX] Hide Debug View by Default
            debugStatusView?.visibility = View.GONE
            
            container.addView(debugStatusView, 0)
        }

        val searchBar = drawerView!!.findViewById<EditText>(R.id.rofi_search_bar); val mainRecycler = drawerView!!.findViewById<RecyclerView>(R.id.rofi_recycler_view); val selectedRecycler = drawerView!!.findViewById<RecyclerView>(R.id.selected_apps_recycler); val executeBtn = drawerView!!.findViewById<ImageView>(R.id.icon_execute)
        if (isBound) executeBtn.setColorFilter(Color.GREEN) else executeBtn.setColorFilter(Color.RED)
        // === MODE ICON CLICK LISTENERS - START ===
        // Sets up click listeners for mode switching icons in drawer
        drawerView!!.findViewById<ImageView>(R.id.icon_search_mode).setOnClickListener { dismissKeyboardAndRestore(); switchMode(MODE_SEARCH) }
        drawerView!!.findViewById<ImageView>(R.id.icon_mode_window).setOnClickListener { dismissKeyboardAndRestore(); switchMode(MODE_LAYOUTS) }
        drawerView!!.findViewById<ImageView>(R.id.icon_mode_resolution).setOnClickListener { dismissKeyboardAndRestore(); switchMode(MODE_RESOLUTION) }
        drawerView!!.findViewById<ImageView>(R.id.icon_mode_refresh)?.setOnClickListener { dismissKeyboardAndRestore(); switchMode(MODE_REFRESH) }
        drawerView!!.findViewById<ImageView>(R.id.icon_mode_dpi).setOnClickListener { dismissKeyboardAndRestore(); switchMode(MODE_DPI) }
        drawerView!!.findViewById<ImageView>(R.id.icon_mode_blacklist)?.setOnClickListener { dismissKeyboardAndRestore(); switchMode(MODE_BLACKLIST) }
        drawerView!!.findViewById<ImageView>(R.id.icon_mode_profiles).setOnClickListener { dismissKeyboardAndRestore(); switchMode(MODE_PROFILES) }
        drawerView!!.findViewById<ImageView>(R.id.icon_mode_keybinds)?.setOnClickListener { dismissKeyboardAndRestore(); switchMode(MODE_KEYBINDS) }

        // [FIX] SETTINGS ICON - DEBUG TRIGGER (5 Clicks)
        drawerView!!.findViewById<ImageView>(R.id.icon_mode_settings).setOnClickListener { 
            dismissKeyboardAndRestore()
            
            // Check for 5 clicks
            val now = System.currentTimeMillis()
            if (now - lastDebugClickTime < 500) {
                debugClickCount++
            } else {
                debugClickCount = 1
            }
            lastDebugClickTime = now

            if (debugClickCount >= 5) {
                isDebugMode = !isDebugMode
                debugClickCount = 0
                val status = if (isDebugMode) "ON" else "OFF"
                
                uiHandler.post {
                    Toast.makeText(context, "Debug Mode: $status", Toast.LENGTH_SHORT).show()
                    debugStatusView?.visibility = if (isDebugMode) View.VISIBLE else View.GONE
                    if (currentMode == MODE_SETTINGS) switchMode(MODE_SETTINGS)
                }
            }

            switchMode(MODE_SETTINGS) 
        }
        // === MODE ICON CLICK LISTENERS - END ===
        executeBtn.setOnClickListener { executeLaunch(selectedLayoutType, closeDrawer = true) }
        searchBar.addTextChangedListener(object : TextWatcher { override fun afterTextChanged(s: Editable?) { filterList(s.toString()) }; override fun beforeTextChanged(s: CharSequence?, st: Int, c: Int, a: Int) {}; override fun onTextChanged(s: CharSequence?, st: Int, b: Int, c: Int) {} })
        searchBar.imeOptions = EditorInfo.IME_ACTION_DONE
        searchBar.setOnEditorActionListener { v, actionId, event -> if (actionId == EditorInfo.IME_ACTION_DONE) { dismissKeyboardAndRestore(); return@setOnEditorActionListener true }; false }
        
        // --- SEARCH BAR INPUT LOGIC ---
        searchBar.setOnKeyListener { _, keyCode, event -> 
            if (event.action == KeyEvent.ACTION_DOWN) {
                // [FIX] Intercept TAB to cycle tabs instead of changing focus
                if (keyCode == KeyEvent.KEYCODE_TAB) {
                    cycleTab(event.isShiftPressed)
                    return@setOnKeyListener true
                }

                // ESC: Exit input mode, give focus to drawer for navigation
                if (keyCode == KeyEvent.KEYCODE_ESCAPE) {
                    dismissKeyboardAndRestore()
                    drawerView?.requestFocus()
                    return@setOnKeyListener true
                }

                // [FIX] DOWN: Search -> Queue (if exists) -> List
                if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
                    dismissKeyboardAndRestore()
                    drawerView?.requestFocus()
                    
                    if (selectedAppsQueue.isNotEmpty()) {
                        // Go to Queue
                        currentFocusArea = FOCUS_QUEUE
                        queueSelectedIndex = 0
                        selectedRecycler.adapter?.notifyDataSetChanged()
                        debugStatusView?.visibility = View.VISIBLE
                        debugStatusView?.text = "Queue Navigation: Use Arrows / Hotkeys"
                    } else {
                        // Go to List
                        currentFocusArea = FOCUS_LIST
                        if (displayList.isNotEmpty()) {
                            if (selectedListIndex >= displayList.size) selectedListIndex = 0
                            mainRecycler.adapter?.notifyItemChanged(selectedListIndex)
                            mainRecycler.scrollToPosition(selectedListIndex)
                        }
                    }
                    return@setOnKeyListener true
                }
                // ENTER: Launch top result immediately
                if (keyCode == KeyEvent.KEYCODE_ENTER) {
                    if (displayList.isNotEmpty()) {
                        val item = displayList[0]
                        if (item is MainActivity.AppInfo) {
                            addToSelection(item)
                            return@setOnKeyListener true
                        }
                    }
                }
                // DEL: Remove last from queue if empty
                if (keyCode == KeyEvent.KEYCODE_DEL && searchBar.text.isEmpty() && selectedAppsQueue.isNotEmpty()) {
                    val lastIndex = selectedAppsQueue.size - 1
                    selectedAppsQueue.removeAt(lastIndex)
                    updateSelectedAppsDock()
                    mainRecycler.adapter?.notifyDataSetChanged()
                    return@setOnKeyListener true
                }
            }
            return@setOnKeyListener false
        }
        
        searchBar.setOnFocusChangeListener { _, hasFocus -> if (autoResizeEnabled) { updateDrawerHeight(hasFocus) } }
        mainRecycler.layoutManager = LinearLayoutManager(themeContext); mainRecycler.adapter = RofiAdapter(); val itemTouchHelper = ItemTouchHelper(swipeCallback); itemTouchHelper.attachToRecyclerView(mainRecycler)
        mainRecycler.addOnScrollListener(object : RecyclerView.OnScrollListener() { override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) { if (newState == RecyclerView.SCROLL_STATE_DRAGGING) { dismissKeyboardAndRestore() } } })
        mainRecycler.setOnTouchListener { v, event -> if (event.action == MotionEvent.ACTION_DOWN) { dismissKeyboardAndRestore() }; false }
        selectedRecycler.layoutManager = LinearLayoutManager(themeContext, LinearLayoutManager.HORIZONTAL, false); selectedRecycler.adapter = SelectedAppsAdapter(); val dockTouchHelper = ItemTouchHelper(selectedAppsDragCallback); dockTouchHelper.attachToRecyclerView(selectedRecycler)
        drawerView!!.setOnClickListener { toggleDrawer() }
        
        // --- DRAWER ROOT NAVIGATION LOGIC ---
        drawerView!!.isFocusable = true
        drawerView!!.isFocusableInTouchMode = true
        drawerView!!.setOnKeyListener { _, keyCode, event -> 
            if (event.action == KeyEvent.ACTION_DOWN) {
                
                // GLOBAL: ESCAPE (Cancel/Close)
                if (keyCode == KeyEvent.KEYCODE_ESCAPE) {
                    if (queueCommandPending != null) {
                        // Cancel pending command
                        queueCommandPending = null
                        queueCommandSourceIndex = -1
                        debugStatusView?.text = "Command Cancelled"
                        // Refresh to clear highlighting
                        selectedRecycler.adapter?.notifyDataSetChanged()
                    } else {
                        // Close Drawer
                        toggleDrawer()
                    }
                    return@setOnKeyListener true
                }

                // GLOBAL: TAB (Switch Modes)
                if (keyCode == KeyEvent.KEYCODE_TAB || keyCode == KeyEvent.KEYCODE_ALT_LEFT || keyCode == KeyEvent.KEYCODE_ALT_RIGHT) {
                    cycleTab(event.isShiftPressed)
                    return@setOnKeyListener true
                }

                // === QUEUE NAVIGATION MODE ===
                if (currentFocusArea == FOCUS_QUEUE) {
                    
                    // 1. HOTKEY CHECK (Priority: Overrides Enter/Space defaults if bound)
                    // We check custom bindings first. If a key matches, execute it.
                    for (cmd in AVAILABLE_COMMANDS) {
                        val bind = AppPreferences.getKeybind(this, cmd.id)
                        
                        // [FIX] Ignore modifiers BUT SKIP Enter/Space to preserve default nav behavior
                        // This prevents "Toggle Drawer" (Space) from overriding "Set Focus" (Space)
                        if (bind.second == keyCode && keyCode != KeyEvent.KEYCODE_SPACE && keyCode != KeyEvent.KEYCODE_ENTER) {
                            
                            if (cmd.argCount == 2) {
                                // 2-Step Command (e.g. Swap)
                                queueCommandPending = cmd
                                queueCommandSourceIndex = queueSelectedIndex
                                debugStatusView?.visibility = View.VISIBLE
                                debugStatusView?.text = "${cmd.label}: Select Target & Press Enter"
                                selectedRecycler.adapter?.notifyDataSetChanged()
                            } else {
                                // 1-Step Command (e.g. Kill, Minimize, Focus Last)
                                val intent = Intent().putExtra("COMMAND", cmd.id).putExtra("INDEX", queueSelectedIndex + 1)
                                handleWindowManagerCommand(intent)
                            }
                            return@setOnKeyListener true
                        }
                    }

                    // 2. NAVIGATION & DEFAULT ACTIONS
                    when (keyCode) {
                        KeyEvent.KEYCODE_DPAD_LEFT -> {
                            if (queueSelectedIndex > 0) {
                                val old = queueSelectedIndex
                                queueSelectedIndex--
                                selectedRecycler.adapter?.notifyItemChanged(old)
                                selectedRecycler.adapter?.notifyItemChanged(queueSelectedIndex)
                                selectedRecycler.scrollToPosition(queueSelectedIndex)
                            }
                            return@setOnKeyListener true
                        }
                        KeyEvent.KEYCODE_DPAD_RIGHT -> {
                            if (queueSelectedIndex < selectedAppsQueue.size - 1) {
                                val old = queueSelectedIndex
                                queueSelectedIndex++
                                selectedRecycler.adapter?.notifyItemChanged(old)
                                selectedRecycler.adapter?.notifyItemChanged(queueSelectedIndex)
                                selectedRecycler.scrollToPosition(queueSelectedIndex)
                            }
                            return@setOnKeyListener true
                        }
                        KeyEvent.KEYCODE_DPAD_UP -> {
                            // Exit to Search
                            currentFocusArea = FOCUS_SEARCH
                            queueSelectedIndex = -1
                            selectedRecycler.adapter?.notifyDataSetChanged()
                            debugStatusView?.visibility = View.GONE
                            searchBar.requestFocus()
                            val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
                            imm.showSoftInput(searchBar, InputMethodManager.SHOW_IMPLICIT)
                            return@setOnKeyListener true
                        }
                        KeyEvent.KEYCODE_DPAD_DOWN -> {
                            // Exit to List
                            currentFocusArea = FOCUS_LIST
                            queueSelectedIndex = -1
                            selectedRecycler.adapter?.notifyDataSetChanged()
                            debugStatusView?.visibility = View.GONE
                            if (displayList.isNotEmpty()) {
                                if (selectedListIndex >= displayList.size) selectedListIndex = 0
                                mainRecycler.adapter?.notifyItemChanged(selectedListIndex)
                                mainRecycler.scrollToPosition(selectedListIndex)
                            }
                            return@setOnKeyListener true
                        }
                        KeyEvent.KEYCODE_ENTER -> {
                            if (queueCommandPending != null) {
                                // Complete 2-Step Command
                                val intent = Intent()
                                    .putExtra("COMMAND", queueCommandPending!!.id)
                                    .putExtra("INDEX_A", queueCommandSourceIndex + 1)
                                    .putExtra("INDEX_B", queueSelectedIndex + 1)
                                handleWindowManagerCommand(intent)
                                queueCommandPending = null
                                queueCommandSourceIndex = -1
                                debugStatusView?.text = "Command Executed"
                            } else {
                                // DEFAULT ENTER: TOGGLE MINIMIZE (Hide/Unhide)
                                val intent = Intent().putExtra("COMMAND", "TOGGLE_MINIMIZE").putExtra("INDEX", queueSelectedIndex + 1)
                                handleWindowManagerCommand(intent)
                            }
                            return@setOnKeyListener true
                        }
                        KeyEvent.KEYCODE_SPACE -> {
                            if (queueCommandPending == null && queueSelectedIndex in selectedAppsQueue.indices) {
                                // [FIX] DEFAULT SPACE: Toggle Internal Focus (Green Underline)
                                val app = selectedAppsQueue[queueSelectedIndex]
                                if (app.packageName != PACKAGE_BLANK) {
                                    val pkg = app.packageName
                                    
                                    // Handle Gemini alias for matching
                                    val isGemini = pkg == "com.google.android.apps.bard"
                                    val activeIsGoogle = activePackageName == "com.google.android.googlequicksearchbox"
                                    val isActive = (activePackageName == pkg) || (isGemini && activeIsGoogle)

                                    if (isActive) {
                                        // CLEAR Focus
                                        activePackageName = null
                                    } else {
                                        // SET Focus
                                        if (activePackageName != null) lastValidPackageName = activePackageName
                                        activePackageName = pkg
                                    }
                                    updateAllUIs()
                                }
                            }
                            return@setOnKeyListener true
                        }
                    }
                    return@setOnKeyListener true
                }

                // === LIST NAVIGATION MODE ===
                if (currentFocusArea == FOCUS_LIST) {
                    when (keyCode) {
                        KeyEvent.KEYCODE_DPAD_UP -> {
                            if (selectedListIndex > 0) {
                                val old = selectedListIndex
                                selectedListIndex--
                                mainRecycler.adapter?.notifyItemChanged(old)
                                mainRecycler.adapter?.notifyItemChanged(selectedListIndex)
                                mainRecycler.scrollToPosition(selectedListIndex)
                            } else {
                                // Top of list reached -> Go to Queue (if exists) or Search
                                if (selectedAppsQueue.isNotEmpty()) {
                                    currentFocusArea = FOCUS_QUEUE
                                    queueSelectedIndex = 0
                                    selectedRecycler.adapter?.notifyDataSetChanged()
                                    debugStatusView?.visibility = View.VISIBLE
                                    debugStatusView?.text = "Queue Navigation"
                                    
                                    // Clear list highlight
                                    val oldList = selectedListIndex
                                    // selectedListIndex = -1 // Optional: keep position memory?
                                    mainRecycler.adapter?.notifyItemChanged(oldList)
                                } else {
                                    currentFocusArea = FOCUS_SEARCH
                                    searchBar.requestFocus()
                                }
                            }
                            return@setOnKeyListener true
                        }
                        KeyEvent.KEYCODE_DPAD_DOWN -> {
                            if (selectedListIndex < displayList.size - 1) {
                                val old = selectedListIndex
                                selectedListIndex++
                                mainRecycler.adapter?.notifyItemChanged(old)
                                mainRecycler.adapter?.notifyItemChanged(selectedListIndex)
                                mainRecycler.scrollToPosition(selectedListIndex)
                            }
                            return@setOnKeyListener true
                        }
                        KeyEvent.KEYCODE_ENTER, KeyEvent.KEYCODE_SPACE -> {
                             // Activate selected item
                             val holder = mainRecycler.findViewHolderForAdapterPosition(selectedListIndex)
                             holder?.itemView?.performClick()
                             return@setOnKeyListener true
                        }
                    }
                }

                // Global Fallbacks
                if (keyCode == KeyEvent.KEYCODE_BACK) { toggleDrawer(); return@setOnKeyListener true }
                if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) { if(isScreenOffState) wakeUp(); return@setOnKeyListener true }
            }
            false 
        }
    }

    // === VISUAL QUEUE (HUD) ===

    private fun setupVisualQueue() {
        val themeContext = ContextThemeWrapper(displayContext ?: this, R.style.Theme_QuadrantLauncher)
        visualQueueView = LayoutInflater.from(themeContext).inflate(R.layout.layout_visual_queue, null)

        // CRITICAL: Ensure we use the WindowManager for the CURRENT display context
        val targetWM = displayContext?.getSystemService(Context.WINDOW_SERVICE) as? WindowManager ?: windowManager

        // Use Type 2032 (Accessibility) or Phone, consistent with other views
        val targetType = if (Build.VERSION.SDK_INT >= 26) 2032 else WindowManager.LayoutParams.TYPE_PHONE

        visualQueueParams = WindowManager.LayoutParams(
            WindowManager.LayoutParams.WRAP_CONTENT,
            WindowManager.LayoutParams.WRAP_CONTENT,
            targetType,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or
            WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or
            WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL,
            PixelFormat.TRANSLUCENT
        )
        
        // MARGIN ADJUSTMENT: Center in the effective safe area
        val display = (displayContext?.getSystemService(Context.WINDOW_SERVICE) as? WindowManager)?.defaultDisplay 
                      ?: windowManager.defaultDisplay
        val h = display.height
        
        val topPx = (h * topMarginPercent / 100f).toInt()
        val bottomPx = (h * bottomMarginPercent / 100f).toInt()
        
        // Standard CENTER is at h/2.
        // Effective Center is at (topPx + (h - topPx - bottomPx)/2) = topPx + h/2 - topPx/2 - bottomPx/2
        // = h/2 + (topPx - bottomPx)/2
        // Offset from standard center = (topPx - bottomPx) / 2
        
        val yShift = (topPx - bottomPx) / 2
        
        visualQueueParams?.gravity = Gravity.CENTER
        visualQueueParams?.y = yShift 

        val recycler = visualQueueView?.findViewById<RecyclerView>(R.id.visual_queue_recycler)
        recycler?.layoutManager = LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false)

        // DUMMY INPUT to keep Gboard alive
        val dummyInput = visualQueueView?.findViewById<EditText>(R.id.vq_dummy_input)
        dummyInput?.showSoftInputOnFocus = true
    }

    private fun showVisualQueue(prompt: String, highlightSlot0Based: Int = -1) {
        if (visualQueueView == null) setupVisualQueue()

        // Ensure list is sorted active-first before showing
        sortAppQueue()

        // FAST SYNC CHECK: Get visible packages for THIS display immediately
        // This ensures the HUD reflects reality even if the background poller hasn't run.
        val visiblePkgs = if (shellService != null) {
            try {
                // Determine if we should block or use cached. 
                // Since this is user-initiated HUD, we want accuracy.
                // We'll spawn a quick thread to get it and update the adapter.
                emptyList<String>() 
            } catch (e: Exception) { emptyList() }
        } else {
            emptyList()
        }
        
        // We will update the adapter with the live list asynchronously to avoid UI freeze
        Thread {
            val visible = shellService?.getVisiblePackages(currentDisplayId) ?: emptyList()
            uiHandler.post {
                val recycler = visualQueueView?.findViewById<RecyclerView>(R.id.visual_queue_recycler)
                (recycler?.adapter as? VisualQueueAdapter)?.updateVisibility(visible)
            }
        }.start()

        val promptView = visualQueueView?.findViewById<TextView>(R.id.visual_queue_prompt)
        promptView?.text = prompt

        val recycler = visualQueueView?.findViewById<RecyclerView>(R.id.visual_queue_recycler)
        recycler?.adapter = VisualQueueAdapter(highlightSlot0Based)

        // Force focus to keep keyboard up
        val dummy = visualQueueView?.findViewById<EditText>(R.id.vq_dummy_input)
        dummy?.requestFocus()

        if (!isVisualQueueVisible) {
            try {
                // Use display-specific WM
                val targetWM = displayContext?.getSystemService(Context.WINDOW_SERVICE) as? WindowManager ?: windowManager
                targetWM.addView(visualQueueView, visualQueueParams)
                isVisualQueueVisible = true
                Log.d(TAG, "Visual Queue Added to Display $currentDisplayId")
            } catch (e: Exception) {
                Log.e(TAG, "Failed to add Visual Queue", e)
                e.printStackTrace()
            }
        } else {
            // Just update adapter if already visible
            recycler?.adapter?.notifyDataSetChanged()
        }

        // NO TIMEOUT - Removed postDelayed (stays open until command completes or ESC)
        uiHandler.removeCallbacks(commandTimeoutRunnable)

        // Tell Trackpad to redirect input to us
        val captureIntent = Intent("com.katsuyamaki.DroidOSTrackpadKeyboard.SET_INPUT_CAPTURE")
        captureIntent.setPackage(PACKAGE_TRACKPAD)
        captureIntent.putExtra("CAPTURE", true)
        sendBroadcast(captureIntent)

        // NEW: Auto-switch keyboard to Number Layer
        val layerIntent = Intent("com.katsuyamaki.DroidOSTrackpadKeyboard.SET_NUM_LAYER")
        layerIntent.setPackage(PACKAGE_TRACKPAD)
        layerIntent.putExtra("ACTIVE", true)
        sendBroadcast(layerIntent)
    }

    private fun hideVisualQueue() {
        if (isVisualQueueVisible && visualQueueView != null) {
            try {
                val targetWM = displayContext?.getSystemService(Context.WINDOW_SERVICE) as? WindowManager ?: windowManager
                targetWM.removeView(visualQueueView)
                isVisualQueueVisible = false
            } catch (e: Exception) {}
        }
        uiHandler.removeCallbacks(commandTimeoutRunnable)

        // Release Trackpad input
        val captureIntent = Intent("com.katsuyamaki.DroidOSTrackpadKeyboard.SET_INPUT_CAPTURE")
        captureIntent.setPackage(PACKAGE_TRACKPAD)
        captureIntent.putExtra("CAPTURE", false)
        sendBroadcast(captureIntent)

        // NEW: Restore previous keyboard layer
        val layerIntent = Intent("com.katsuyamaki.DroidOSTrackpadKeyboard.SET_NUM_LAYER")
        layerIntent.setPackage(PACKAGE_TRACKPAD)
        layerIntent.putExtra("ACTIVE", false)
        sendBroadcast(layerIntent)
    }

    private fun abortCommandMode() {
        if (pendingCommandId != null) {
            safeToast("Command Cancelled")
            pendingCommandId = null
            pendingArg1 = -1
            hideVisualQueue()
        }
    }

// [NEW] Robust Move Logic: Finds original slot and forces move with retries
    private fun forceAppToDisplay(pkg: String, targetDisplayId: Int) {
        // [LOCK] Prevent duplicate threads
        if (activeEnforcements.contains(pkg)) {
            Log.d("DROIDOS_WATCHDOG", "SKIP: Enforcement already active for $pkg")
            return
        }
        activeEnforcements.add(pkg)

        Thread {
            try {
                // 1. Get Task ID & Class Name
                var tid = shellService?.getTaskId(pkg, null) ?: -1
                if (tid == -1) {
                    Thread.sleep(200) 
                    tid = shellService?.getTaskId(pkg, null) ?: -1
                }

                if (tid != -1) {
                    Log.w("DROIDOS_WATCHDOG", "Targeting Task $tid for $pkg. Starting Locked Loop...")

                    // 2. Lookup Cache / AppInfo
                    var bounds: Rect? = packageRectCache[pkg]
                    var className: String? = null
                    
                    // Fallback to queue + get Class Name
                    val appEntry = selectedAppsQueue.find { it.packageName == pkg || it.getBasePackage() == pkg }
                    if (appEntry != null) {
                         className = appEntry.className
                         if (bounds == null) {
                             val appIndex = selectedAppsQueue.indexOf(appEntry)
                             val rects = getLayoutRects()
                             if (appIndex >= 0 && appIndex < rects.size) bounds = rects[appIndex]
                         }
                    }

                    // 3. AGGRESSIVE Loop (10 attempts)
                    for (i in 1..10) {
                        // A. Try Task Move (Standard)
                        shellService?.runCommand("am task move-task-to-display $tid $targetDisplayId")
                        shellService?.runCommand("am task set-windowing-mode $tid 5")
                        
                        // B. Escalation Levels
                        // Level 1 (Attempts 3-6): Force Relaunch with NEW_TASK flag
                        if (i > 3 && i <= 6 && className != null) {
                             val cmd = "am start -n $pkg/$className --display $targetDisplayId --windowingMode 5 -f 0x10000000 --user 0"
                             Log.w("DROIDOS_WATCHDOG", "Escalating L1 (Relaunch): $cmd")
                             shellService?.runCommand(cmd)
                        }
                        
                        // Level 2 (Attempts 7+): NUCLEAR OPTION (Kill & Restart)
                        // If it refuses to move after 6 tries, the process is likely stuck with bad display affinity.
                        if (i > 6 && className != null) {
                             Log.e("DROIDOS_WATCHDOG", "Escalating L2 (Nuclear): Killing $pkg to break display affinity")
                             shellService?.forceStop(pkg)
                             Thread.sleep(300) // Wait for death
                             
                             val cmd = "am start -n $pkg/$className --display $targetDisplayId --windowingMode 5 -f 0x10000000 --user 0"
                             shellService?.runCommand(cmd)
                        }
                        
                        // Apply Bounds
                        if (bounds != null) {
                            shellService?.runCommand("am task resize $tid ${bounds.left} ${bounds.top} ${bounds.right} ${bounds.bottom}")
                            Log.d("DROIDOS_WATCHDOG", "Attempt $i: D$targetDisplayId @ $bounds")
                        } else {
                            shellService?.runCommand("am task resize $tid 0 0 1000 1000")
                            Log.d("DROIDOS_WATCHDOG", "Attempt $i: D$targetDisplayId (Default)")
                        }

                        // Check success
                        // We check BOTH display ID and visibility
                        val visibleOnTarget = shellService?.getVisiblePackages(targetDisplayId)?.contains(pkg) == true
                        if (visibleOnTarget) {
                            Log.w("DROIDOS_WATCHDOG", "SUCCESS: App moved on attempt $i")
                            // One final resize to ensure it stuck
                            if (bounds != null) shellService?.runCommand("am task resize $tid ${bounds.left} ${bounds.top} ${bounds.right} ${bounds.bottom}")
                            break
                        }
                        
                        Thread.sleep(300) // Slightly slower retry to let system process
                    }
                } else {
                    Log.e("DROIDOS_WATCHDOG", "Could not find Task ID for $pkg")
                }
            } catch (e: Exception) {
                Log.e("DROIDOS_WATCHDOG", "Force move failed", e)
            } finally {
                // [UNLOCK] Release lock
                activeEnforcements.remove(pkg)
            }
        }.start()
    }

    // === KEY PICKER (POPUP) ===
    private fun showKeyPicker(cmdId: String, currentMod: Int) {
        // Remove existing if any
        if (keyPickerView != null) {
            try { windowManager.removeView(keyPickerView) } catch(e: Exception){}
            keyPickerView = null
        }

        val themeContext = ContextThemeWrapper(displayContext ?: this, R.style.Theme_QuadrantLauncher)
        keyPickerView = LayoutInflater.from(themeContext).inflate(R.layout.layout_key_picker, null)

        val targetType = if (Build.VERSION.SDK_INT >= 26) 2032 else WindowManager.LayoutParams.TYPE_PHONE

        keyPickerParams = WindowManager.LayoutParams(
            WindowManager.LayoutParams.WRAP_CONTENT,
            WindowManager.LayoutParams.WRAP_CONTENT,
            targetType,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or
            WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or
            WindowManager.LayoutParams.FLAG_DIM_BEHIND,
            PixelFormat.TRANSLUCENT
        )
        keyPickerParams?.dimAmount = 0.5f
        keyPickerParams?.gravity = Gravity.CENTER

        val recycler = keyPickerView?.findViewById<RecyclerView>(R.id.picker_recycler)
        recycler?.layoutManager = LinearLayoutManager(this)

        val keys = SUPPORTED_KEYS.toList() // Convert to list of pairs

        recycler?.adapter = object : RecyclerView.Adapter<RecyclerView.ViewHolder>() {
            override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
                return object : RecyclerView.ViewHolder(
                    LayoutInflater.from(parent.context).inflate(R.layout.item_simple_text, parent, false)
                ) {}
            }
            override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
                val (label, code) = keys[position]
                val tv = holder.itemView.findViewById<TextView>(R.id.text1)
                tv.text = label

                holder.itemView.setOnClickListener {
                    // SAVE BINDING
                    if (cmdId == "CUSTOM_MOD_SETUP") {
                        AppPreferences.saveCustomModKey(this@FloatingLauncherService, code)
                        customModKey = code // Update live var
                    } else {
                        AppPreferences.saveKeybind(this@FloatingLauncherService, cmdId, currentMod, code)
                        broadcastKeybindsToKeyboard() // Update keyboard immediately
                    }
                    safeToast("Bound to $label")

                    // Close picker
                    if (keyPickerView != null) {
                        try { windowManager.removeView(keyPickerView) } catch(e: Exception){}
                        keyPickerView = null
                    }
                    // Refresh main list
                    uiHandler.post { switchMode(MODE_KEYBINDS) }
                }
            }
            override fun getItemCount() = keys.size
        }

        keyPickerView?.findViewById<View>(R.id.btn_cancel_picker)?.setOnClickListener {
            if (keyPickerView != null) {
                try { windowManager.removeView(keyPickerView) } catch(e: Exception){}
                keyPickerView = null
            }
        }

        try {
            // Add ON TOP of everything
            windowManager.addView(keyPickerView, keyPickerParams)
        } catch (e: Exception) { e.printStackTrace() }
    }

    // ADAPTER for the HUD
    inner class VisualQueueAdapter(private val highlightIndex: Int) : RecyclerView.Adapter<VisualQueueAdapter.Holder>() {
        
        private var visiblePackages: List<String> = emptyList()
        
        fun updateVisibility(visible: List<String>) {
            visiblePackages = visible
            notifyDataSetChanged()
        }
        inner class Holder(v: View) : RecyclerView.ViewHolder(v) {
            val icon: ImageView = v.findViewById(R.id.vq_app_icon)
            val badge: TextView = v.findViewById(R.id.vq_slot_number)
            val highlight: View = v.findViewById(R.id.vq_highlight)
            val underline: View = v.findViewById(R.id.focus_underline)
        }
        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): Holder {
            return Holder(LayoutInflater.from(parent.context).inflate(R.layout.item_visual_queue_app, parent, false))
        }
        override fun onBindViewHolder(holder: Holder, position: Int) {
            val app = selectedAppsQueue[position]
            val slotNum = position + 1 // 1-Based Display

            // Show Focus Underline if matches activePackageName
            // Handle Gemini/Google alias logic
            val isFocused = (app.packageName == activePackageName) ||
                            (app.packageName == "com.google.android.apps.bard" && activePackageName == "com.google.android.googlequicksearchbox")

            holder.underline.visibility = if (isFocused) View.VISIBLE else View.GONE
            holder.badge.text = slotNum.toString()

            if (app.packageName == PACKAGE_BLANK) {
                holder.icon.setImageResource(R.drawable.ic_box_outline)
                holder.icon.alpha = 0.5f
            } else {
                try {
                    val basePkg = if (app.packageName.contains(":")) app.packageName.substringBefore(":") else app.packageName
                    holder.icon.setImageDrawable(packageManager.getApplicationIcon(basePkg))
                } catch (e: Exception) {
                    holder.icon.setImageResource(R.drawable.ic_launcher_bubble)
                }
                
                // VISIBILITY LOGIC:
                // 1. Is it explicitly minimized by user? -> Inactive
                // 2. Is it visible on THIS screen? -> Active
                // 3. Otherwise -> Inactive (e.g. open on other screen)
                
                val isVisibleOnScreen = visiblePackages.contains(app.getBasePackage()) || 
                                      (app.getBasePackage() == "com.google.android.apps.bard" && visiblePackages.contains("com.google.android.googlequicksearchbox"))

                // If visible packages list is empty (loading), fall back to stored state
                val isActuallyActive = if (visiblePackages.isNotEmpty()) {
                    isVisibleOnScreen
                } else {
                    !app.isMinimized
                }
                
                holder.icon.alpha = if (isActuallyActive) 1.0f else 0.4f
            }

            // Highlight logic
            if (position == highlightIndex) {
                holder.highlight.visibility = View.VISIBLE
                holder.highlight.setBackgroundResource(R.drawable.bg_item_active)
            } else {
                holder.highlight.visibility = View.GONE
            }
        }
        override fun getItemCount() = selectedAppsQueue.size
    }

    /**
     * Initializes or re-initializes the window and all its components.
     * This is called when the service starts or when the target display changes.
     */
    private fun initWindow() {
        setupDisplayContext(currentDisplayId)
        setupBubble()
        setupDrawer()
        updateBubbleIcon()
        loadDisplaySettings(currentDisplayId)

        // [FIX] Apply layout immediately if in Instant Mode
        if (isInstantMode) {
            uiHandler.postDelayed({ applyLayoutImmediate() }, 500)
        }
    }
    
    private fun startReorderMode(index: Int) { if (!isReorderTapEnabled) return; if (index < 0 || index >= selectedAppsQueue.size) return; val prevIndex = reorderSelectionIndex; reorderSelectionIndex = index; val adapter = drawerView!!.findViewById<RecyclerView>(R.id.selected_apps_recycler).adapter; if (prevIndex != -1) adapter?.notifyItemChanged(prevIndex); adapter?.notifyItemChanged(reorderSelectionIndex); safeToast("Tap another app to Swap") }
    private fun swapReorderItem(targetIndex: Int) { if (reorderSelectionIndex == -1) return; Collections.swap(selectedAppsQueue, reorderSelectionIndex, targetIndex); val adapter = drawerView!!.findViewById<RecyclerView>(R.id.selected_apps_recycler).adapter; adapter?.notifyItemChanged(reorderSelectionIndex); adapter?.notifyItemChanged(targetIndex); endReorderMode(true) }
    private fun endReorderMode(triggerInstantMode: Boolean) { val prevIndex = reorderSelectionIndex; reorderSelectionIndex = -1; val adapter = drawerView!!.findViewById<RecyclerView>(R.id.selected_apps_recycler).adapter; if (prevIndex != -1) adapter?.notifyItemChanged(prevIndex); if (triggerInstantMode && isInstantMode) applyLayoutImmediate() }
    
    private fun updateDrawerHeight(isKeyboardMode: Boolean) {
        val container = drawerView?.findViewById<LinearLayout>(R.id.drawer_container) ?: return
        val dm = DisplayMetrics(); windowManager.defaultDisplay.getRealMetrics(dm); val screenH = dm.heightPixels; val screenW = dm.widthPixels
        val lp = container.layoutParams as? FrameLayout.LayoutParams; val topMargin = lp?.topMargin ?: 100
        var finalHeight = (screenH * (currentDrawerHeightPercent / 100f)).toInt()
        if (isKeyboardMode) { finalHeight = (screenH * 0.40f).toInt(); val maxAvailable = screenH - topMargin - 20; if (finalHeight > maxAvailable) finalHeight = maxAvailable }
        val newW = (screenW * (currentDrawerWidthPercent / 100f)).toInt()
        if (container.layoutParams.height != finalHeight || container.layoutParams.width != newW) { container.layoutParams.width = newW; container.layoutParams.height = finalHeight; container.requestLayout(); if (drawerParams.y != 0) { drawerParams.y = 0; windowManager.updateViewLayout(drawerView, drawerParams) } }
    }

    // === TOGGLE DRAWER - START ===
    // Opens/closes the launcher drawer overlay
    // Updates debug display with queue state when opening
    private fun toggleDrawer() {
        Log.d(TAG, "toggleDrawer called. isExpanded=$isExpanded")
        if (isExpanded) {
            Log.d(TAG, "Closing drawer")
            try { windowManager.removeView(drawerView) } catch(e: Exception) {}
            // bubbleView?.visibility = View.VISIBLE // No need to toggle if always visible
            isExpanded = false

            // Auto-Restore Focus
            if (activePackageName != null) {
                // Focus the app that was active BEFORE we opened the drawer
                // (Or the current active one if we didn't switch away)
                val target = activePackageName
                Thread {
                    val app = selectedAppsQueue.find { it.packageName == target }
                    if (app != null) {
                        try {
                            val rects = getLayoutRects()
                            val idx = selectedAppsQueue.indexOf(app)
                            val bounds = if (idx >= 0 && idx < rects.size) rects[idx] else null
                            launchViaShell(app.getBasePackage(), app.className, bounds)
                        } catch(e: Exception) {}
                    }
                }.start()
            }
        } else {
            Log.d(TAG, "Opening drawer")
            updateDrawerHeight(false)
            
            // Z-ORDER UPDATE: Try adding with High Priority, Fallback if fails
            try {
                Log.d(TAG, "Attempting to add drawer view")
                windowManager.addView(drawerView, drawerParams)
                Log.d(TAG, "Drawer view added successfully")
            } catch(e: Exception) {
                Log.e(TAG, "Failed to add drawer with high priority: ${e.message}")
                try {
                    drawerParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
                    windowManager.addView(drawerView, drawerParams)
                    Log.d(TAG, "Drawer added with fallback type")
                } catch(e2: Exception) {
                    Log.e(TAG, "Failed to add drawer with fallback: ${e2.message}")
                }
            }

            // bubbleView?.visibility = View.GONE // Keep bubble visible
            isExpanded = true
            
            // [FIX] Reset all navigation/focus state to prevent ghost highlights
            currentFocusArea = FOCUS_SEARCH
            queueSelectedIndex = -1
            queueCommandPending = null
            queueCommandSourceIndex = -1
            debugStatusView?.visibility = View.GONE
            
            switchMode(MODE_SEARCH)
            
            val et = drawerView?.findViewById<EditText>(R.id.rofi_search_bar)
            et?.setText("")
            et?.requestFocus() // Auto-focus for immediate typing
            updateSelectedAppsDock()
            
            // Show current queue state in debug view when drawer opens
            showQueueDebugState()
            
            if (isInstantMode) fetchRunningApps() 
        }
    }
    // === TOGGLE DRAWER - END ===
    
    // === SHOW QUEUE DEBUG STATE - START ===
    private fun showQueueDebugState() {
        if (selectedAppsQueue.isEmpty()) {
            debugStatusView?.text = "[DRAWER] Queue empty"
        } else {
            val queueInfo = selectedAppsQueue.mapIndexed { i, app ->
                val shortCls = when {
                    app.className.isNullOrEmpty() -> "NO_CLS"
                    app.className == "null" -> "NO_CLS"
                    app.className == "default" -> "BAD_CLS"
                    else -> app.className!!.substringAfterLast(".")
                }
                val shortPkg = app.packageName.substringAfterLast(".")
                "$i:$shortPkg($shortCls)"
            }.joinToString(" | ")
            debugStatusView?.text = "[Q] $queueInfo"
            
            // Also log full details
            selectedAppsQueue.forEachIndexed { i, app ->
                Log.d(DEBUG_TAG, "Queue[$i]: ${app.label} pkg=${app.packageName} cls=${app.className}")
            }
        }
    }
    // === SHOW QUEUE DEBUG STATE - END ===
    private fun updateGlobalFontSize() { val searchBar = drawerView?.findViewById<EditText>(R.id.rofi_search_bar); searchBar?.textSize = currentFontSize; drawerView?.findViewById<RecyclerView>(R.id.rofi_recycler_view)?.adapter?.notifyDataSetChanged() }

// This ensures that the internal list always has two separate entries for the Google package.
// We force the standard one to be "Google" and the assistant one to be "Gemini".

    // === LOAD INSTALLED APPS - START ===
    // Loads all launcher apps with proper className capture
    private fun loadInstalledApps() {
        val pm = packageManager
        val intent = Intent(Intent.ACTION_MAIN, null).apply { addCategory(Intent.CATEGORY_LAUNCHER) }
        val riList = pm.queryIntentActivities(intent, 0)
        allAppsList.clear()
        allAppsList.add(MainActivity.AppInfo(" (Blank Space)", PACKAGE_BLANK, null))

        val blacklist = AppPreferences.getBlacklist(this)

        for (ri in riList) {
            val pkg = ri.activityInfo.packageName
            // Get the FULL activity class name - this is critical for tiling
            val cls = ri.activityInfo.name
            
            if (pkg == PACKAGE_TRACKPAD || pkg == packageName) continue

            var label = ri.loadLabel(pm).toString()
            
            // Standalone Gemini app (com.google.android.apps.bard)
            if (pkg == "com.google.android.apps.bard") {
                label = "Gemini"
            }
            // Google Quick Search Box with Gemini/Assistant activity
            else if (pkg == "com.google.android.googlequicksearchbox" &&
                (cls.lowercase().contains("assistant") || 
                 cls.lowercase().contains("gemini") ||
                 cls.lowercase().contains("bard"))) {
                label = "Gemini (Google)"
            }

            // Validate className - must not be null, empty, or "default"
            val validClassName = if (cls.isNullOrEmpty() || cls == "default") {
                Log.w(DEBUG_TAG, "App $label ($pkg) has invalid className: $cls")
                null
            } else {
                cls
            }

            val app = MainActivity.AppInfo(
                label = label, 
                packageName = pkg, 
                className = validClassName,
                isFavorite = AppPreferences.isFavorite(this, pkg)
            )

            if (!blacklist.contains(app.getIdentifier())) {
                allAppsList.add(app)
            }
            
            Log.d(DEBUG_TAG, "Loaded: $label pkg=$pkg cls=$validClassName")
        }
        allAppsList.sortBy { it.label.lowercase() }
        Log.d(TAG, "Loaded ${allAppsList.size} apps total")
    }
    // === LOAD INSTALLED APPS - END ===

    // === LOAD BLACKLISTED APPS - START ===
    // Loads all blacklisted apps for display in blacklist tab
    // Reconstructs AppInfo objects from blacklist identifiers
    private fun loadBlacklistedApps() {
        displayList.clear()

        val pm = packageManager
        val blacklist = AppPreferences.getBlacklist(this)

        for (identifier in blacklist) {
            try {
                val parts = identifier.split(":")
                val pkg = parts[0]
                val activity = if (parts.size > 1) parts[1] else null

                // Determine label
                val label = when {
                    identifier.contains("gemini") -> "Gemini"
                    pkg == "com.google.android.googlequicksearchbox" -> "Google"
                    else -> {
                        try {
                            pm.getApplicationLabel(pm.getApplicationInfo(pkg, 0)).toString()
                        } catch (e: Exception) {
                            identifier
                        }
                    }
                }

                val app = MainActivity.AppInfo(label, pkg, activity, false, false)
                displayList.add(app)
            } catch (e: Exception) {
                Log.e(TAG, "Failed to load blacklisted app: $identifier", e)
            }
        }

        displayList.sortBy { (it as? MainActivity.AppInfo)?.label?.lowercase() }
        drawerView?.findViewById<RecyclerView>(R.id.rofi_recycler_view)?.adapter?.notifyDataSetChanged()
    }
    // === LOAD BLACKLISTED APPS - END ===


    private fun launchTrackpad() {
        // [FIX] Robust Launch Strategy: Service -> Activity -> Broadcast
        // 1. Try to start the Service directly (Fastest, maintains state)
        try {
            val serviceIntent = Intent()
            serviceIntent.component = ComponentName(
                "com.katsuyamaki.DroidOSTrackpadKeyboard", 
                "com.example.coverscreentester.OverlayService" 
            )
            if (Build.VERSION.SDK_INT >= 26) startForegroundService(serviceIntent) else startService(serviceIntent)
            safeToast("Starting Trackpad Service...")
            return
        } catch (e: Exception) {
            // Service start failed (likely Background Restrictions) -> Proceed to Step 2
        }

        // 2. Try to Launch the Main Activity (Guaranteed to wake app)
        try {
            val launchIntent = packageManager.getLaunchIntentForPackage("com.katsuyamaki.DroidOSTrackpadKeyboard")
            if (launchIntent != null) {
                launchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                startActivity(launchIntent)
                safeToast("Launching Trackpad App...")
                return
            }
        } catch (e: Exception) {
            // New package not found -> Proceed to Step 3
        }

        // 3. Legacy Fallback (Old Package Name)
        try {
            val oldIntent = Intent()
            oldIntent.component = ComponentName(
                "com.example.coverscreentester", 
                "com.example.coverscreentester.OverlayService"
            )
            if (Build.VERSION.SDK_INT >= 26) startForegroundService(oldIntent) else startService(oldIntent)
            return
        } catch (e: Exception) {
            // Legacy Service failed -> Try Legacy Activity
            try {
                val oldLaunchIntent = packageManager.getLaunchIntentForPackage("com.example.coverscreentester")
                if (oldLaunchIntent != null) {
                    oldLaunchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    startActivity(oldLaunchIntent)
                    return
                }
            } catch (e2: Exception) {}
        }

        // 4. Final Resort: Broadcast (Only works if app is already alive)
        val broadcastNew = Intent("com.katsuyamaki.DroidOSTrackpadKeyboard.SET_TRACKPAD_VISIBILITY")
        broadcastNew.setPackage("com.katsuyamaki.DroidOSTrackpadKeyboard")
        broadcastNew.putExtra("VISIBLE", true)
        sendBroadcast(broadcastNew)
        
        safeToast("Trackpad not found or failed to launch.")
    }

    private fun isTrackpadRunning(): Boolean { try { val am = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager; val runningApps = am.runningAppProcesses; if (runningApps != null) { for (info in runningApps) { if (info.processName == PACKAGE_TRACKPAD) return true } } } catch (e: Exception) {}; return false }
    private fun getLayoutName(type: Int): String { 
        // Check for user-renamed default
        if (type != LAYOUT_CUSTOM_DYNAMIC) {
            val custom = AppPreferences.getDefaultLayoutName(this, type)
            // [FIX] Auto-Repair: Ignore names that look like Settings toggles
            if (custom != null && !custom.contains("Virtual Display") && !custom.contains("Switch Display")) {
                return custom
            }
        }
        
        return when(type) { 
            LAYOUT_FULL -> "1 App - Full"
            LAYOUT_SIDE_BY_SIDE -> "2 Apps - Split"
            LAYOUT_TOP_BOTTOM -> "2 Apps - Top/Bot"
            LAYOUT_TRI_EVEN -> "3 Apps - Even"
            LAYOUT_CORNERS -> "4 Apps - Quadrant"
            LAYOUT_TRI_SIDE_MAIN_SIDE -> "3 Apps - Side/Main/Side"
            LAYOUT_QUAD_ROW_EVEN -> "4 Apps - Row"
            LAYOUT_QUAD_TALL_SHORT -> "4 Apps - 2 Tall / 2 Short"
            LAYOUT_HEX_TALL_SHORT -> "6 Apps - 3 Tall / 3 Short"
            LAYOUT_CUSTOM_DYNAMIC -> "Custom"
            else -> "Unknown" 
        } 
    }
    private fun getRatioName(index: Int): String { return when(index) { 1 -> "1:1"; 2 -> "16:9"; 3 -> "32:9"; else -> "Default" } }
    private fun getTargetDimensions(index: Int): Pair<Int, Int>? { return when(index) { 1 -> 1422 to 1500; 2 -> 1920 to 1080; 3 -> 3840 to 1080; else -> null } }
    private fun getResolutionCommand(index: Int): String { return when(index) { 1 -> "wm size 1422x1500 -d $currentDisplayId"; 2 -> "wm size 1920x1080 -d $currentDisplayId"; 3 -> "wm size 3840x1080 -d $currentDisplayId"; else -> "wm size reset -d $currentDisplayId" } }

// Sorts active apps to front and minimized to back.
            // Maintains relative order (Stable Sort), ensuring newly minimized apps
            // appear at the front of the inactive group (Left-to-Right).
            private fun sortAppQueue() {
                selectedAppsQueue.sortWith(compareBy { it.isMinimized })
            }

            private fun updateAllUIs() {
                // 1. Update Drawer Dock
                updateSelectedAppsDock()
                drawerView?.findViewById<RecyclerView>(R.id.rofi_recycler_view)?.adapter?.notifyDataSetChanged()
                
                // 2. Update Visual Queue HUD (if exists)
                if (visualQueueView != null) {
                    val recycler = visualQueueView?.findViewById<RecyclerView>(R.id.visual_queue_recycler)
                    recycler?.adapter?.notifyDataSetChanged()
                }
            }    private fun updateSelectedAppsDock() { val dock = drawerView!!.findViewById<RecyclerView>(R.id.selected_apps_recycler); if (selectedAppsQueue.isEmpty()) { dock.visibility = View.GONE } else { dock.visibility = View.VISIBLE; dock.adapter?.notifyDataSetChanged(); dock.scrollToPosition(selectedAppsQueue.size - 1) } }
    private fun refreshSearchList() { val query = drawerView?.findViewById<EditText>(R.id.rofi_search_bar)?.text?.toString() ?: ""; filterList(query) }
    private fun filterList(query: String) {
        if (currentMode != MODE_SEARCH) return; val actualQuery = query.substringAfterLast(",").trim(); displayList.clear()
        val filtered = if (actualQuery.isEmpty()) { allAppsList } else { allAppsList.filter { it.label.contains(actualQuery, ignoreCase = true) } }
        val sorted = filtered.sortedWith(compareBy<MainActivity.AppInfo> { it.packageName != PACKAGE_BLANK }.thenByDescending { it.isFavorite }.thenBy { it.label.lowercase() }); displayList.addAll(sorted); drawerView!!.findViewById<RecyclerView>(R.id.rofi_recycler_view)?.adapter?.notifyDataSetChanged()
    }

    // Helper to scrub dead apps from focus history so we don't accidentally re-launch them
    private fun removeFromFocusHistory(pkg: String) {
        val basePkg = if (pkg.contains(":")) pkg.substringBefore(":") else pkg
        val alias = if (basePkg == "com.google.android.apps.bard") "com.google.android.googlequicksearchbox" else null

        // Shift history down if the killed app was the active one
        if (activePackageName == basePkg || activePackageName == alias) {
            activePackageName = lastValidPackageName
            lastValidPackageName = secondLastValidPackageName
            secondLastValidPackageName = null
        }
        // Also scrub from other positions if it's lingering there
        else {
            if (lastValidPackageName == basePkg || lastValidPackageName == alias) {
                lastValidPackageName = secondLastValidPackageName
                secondLastValidPackageName = null
            } else if (secondLastValidPackageName == basePkg || secondLastValidPackageName == alias) {
                secondLastValidPackageName = null
            }
        }
    }

    // === ADD TO SELECTION - START ===
    // Adds app to the selection queue, handles removal if already selected
    // Uses proper package name extraction for force-stop and launch operations
    private fun addToSelection(app: MainActivity.AppInfo) {
        dismissKeyboardAndRestore()
        val et = drawerView!!.findViewById<EditText>(R.id.rofi_search_bar)
        
        // Handle blank spacer
        if (app.packageName == PACKAGE_BLANK) { 
            selectedAppsQueue.add(app)
            sortAppQueue()
            updateSelectedAppsDock()
            drawerView!!.findViewById<RecyclerView>(R.id.rofi_recycler_view)?.adapter?.notifyDataSetChanged()
            if (isInstantMode) applyLayoutImmediate()
            return 
        }
        
        // Debug: show what app is being selected
        debugShowAppIdentification("SELECT", app.packageName, app.className)
        
        // Check if app is already in queue (by matching both package and class for precision)
        val existing = selectedAppsQueue.find { 
            it.packageName == app.packageName && it.className == app.className 
        }
        
        if (existing != null) { 
            // Remove from queue
            selectedAppsQueue.remove(existing)
            
            // Force stop using BASE package name (shell commands need base pkg)
            val basePkg = if (app.packageName.contains(":")) app.packageName.substringBefore(":") else app.packageName
            Thread { 
                try { 
                    shellService?.forceStop(basePkg) 
                } catch(e: Exception) {
                    Log.e(TAG, "forceStop failed for $basePkg", e)
                } 
            }.start()
            
            safeToast("Removed ${app.label}")
            sortAppQueue()
            updateAllUIs()
            et.setText("")
            if (isInstantMode) applyLayoutImmediate() 
        } else { 
            // Add to queue and launch if instant mode
            app.isMinimized = false
            selectedAppsQueue.add(app)
            sortAppQueue()
            updateAllUIs()
            et.setText("")
            
            if (isInstantMode) { 
                // Launch using both API and Shell for reliability
                launchViaApi(app.packageName, app.className, null)
                launchViaShell(app.packageName, app.className, null)
                
                // Delayed layout application to allow app to start
                uiHandler.postDelayed({ applyLayoutImmediate() }, 200)
                uiHandler.postDelayed({ applyLayoutImmediate() }, 800) 
            } 
            
            // [FIX] Close drawer after successful add
            toggleDrawer()
        }
    }
    // === ADD TO SELECTION - END ===

    private fun toggleFavorite(app: MainActivity.AppInfo) { val newState = AppPreferences.toggleFavorite(this, app.packageName); app.isFavorite = newState; allAppsList.find { it.packageName == app.packageName }?.isFavorite = newState }


    // === LAUNCH VIA API - START ===
    // Launches app using Android API with launch bounds
    private fun launchViaApi(pkg: String, className: String?, bounds: Rect?) {
        try {
            val basePkg = if (pkg.contains(":")) pkg.substringBefore(":") else pkg

            debugShowAppIdentification("LAUNCH_API", basePkg, className)

            val intent: Intent?

            if (!className.isNullOrEmpty() && className != "null" && className != "default") {
                intent = Intent()
                intent.setClassName(basePkg, className)
                intent.action = Intent.ACTION_MAIN
                intent.addCategory(Intent.CATEGORY_LAUNCHER)
                Log.d(TAG, "launchViaApi: explicit component $basePkg/$className")
            } else {
                intent = packageManager.getLaunchIntentForPackage(basePkg)
                Log.d(TAG, "launchViaApi: default intent for $basePkg")
            }

            if (intent == null) {
                Log.w(TAG, "launchViaApi: No intent for $basePkg, trying shell")
                launchViaShell(basePkg, className, bounds)
                return
            }

            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)

            val options = android.app.ActivityOptions.makeBasic()
            options.setLaunchDisplayId(currentDisplayId)

            if (bounds != null) {
                options.setLaunchBounds(bounds)
                Log.d(TAG, "launchViaApi: bounds=$bounds")
            }

            startActivity(intent, options.toBundle())
            Log.d(TAG, "launchViaApi: SUCCESS $basePkg")

        } catch (e: Exception) {
            Log.e(TAG, "launchViaApi FAILED, trying shell", e)
            launchViaShell(pkg, className, bounds)
        }
    }
    // === LAUNCH VIA API - END ===


    // === LAUNCH VIA SHELL - START ===
    // Launches app via shell with freeform windowing mode
    private fun launchViaShell(pkg: String, className: String?, bounds: Rect?) {
        try {
            val basePkg = if (pkg.contains(":")) pkg.substringBefore(":") else pkg

            debugShowAppIdentification("LAUNCH_SHELL", basePkg, className)

            val component = if (!className.isNullOrEmpty() && className != "null" && className != "default") {
                "$basePkg/$className"
            } else {
                null
            }

            // Build launch command with freeform mode (--windowingMode 5)
            val cmd = if (component != null) {
                "am start -n $component --display $currentDisplayId --windowingMode 5 --user 0"
            } else {
                "am start -p $basePkg -a android.intent.action.MAIN -c android.intent.category.LAUNCHER --display $currentDisplayId --windowingMode 5 --user 0"
            }

            Log.d(TAG, "launchViaShell: $cmd")

            Thread {
                try {
                    shellService?.runCommand(cmd)
                    Log.d(TAG, "launchViaShell: SUCCESS")
                } catch (e: Exception) {
                    Log.e(TAG, "launchViaShell: FAILED", e)
                }
            }.start()

        } catch (e: Exception) {
            Log.e(TAG, "launchViaShell FAILED: $pkg", e)
        }
    }
    // === LAUNCH VIA SHELL - END ===

    
    private fun toggleVirtualDisplay() {
        if (virtualDisplay == null) {
            setKeepScreenOn(true)
            val dm = getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
            
            // 1. Create ImageReader to act as the screen buffer
            virtualImageReader = ImageReader.newInstance(1920, 1080, PixelFormat.RGBA_8888, 2)
            
            // 2. Set flags (Public allows other apps/system to see it; Presentation allows secondary content)
            val flags = DisplayManager.VIRTUAL_DISPLAY_FLAG_PRESENTATION or DisplayManager.VIRTUAL_DISPLAY_FLAG_PUBLIC
            
            // 3. Create Display with Surface
            virtualDisplay = dm.createVirtualDisplay(
                "DroidOS-Virtual", 
                1920, 1080, 320, 
                virtualImageReader?.surface, 
                flags
            )
            
            Toast.makeText(this, "Virtual Display Created (1080p)", Toast.LENGTH_SHORT).show()
        } else {
            // Optional: Destroy if toggled again? For now, just warn.
            Toast.makeText(this, "Virtual Display Already Active", Toast.LENGTH_SHORT).show()
        }
    }

    fun switchDisplay() {
        val dm = getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
        
        // 1. Determine where the Bubble actually is (Source of Truth)
        var actualCurrentId = currentDisplayId
        // Safe check for view location
        if (bubbleView != null && bubbleView?.isAttachedToWindow == true) {
             bubbleView?.display?.let { actualCurrentId = it.displayId }
        }

        var targetId = actualCurrentId

        // 2. Logic: Physical <-> Virtual
        if (actualCurrentId == 0 || actualCurrentId == 1) {
            // CASE: We are on a Physical Display -> Go to Virtual
            
            // Find the first display that ISN'T 0 or 1
            val virtualDisplay = dm.displays.firstOrNull { it.displayId != 0 && it.displayId != 1 }
            
            if (virtualDisplay != null) {
                targetId = virtualDisplay.displayId
                setKeepScreenOn(true)  // Keep screen on when switching TO virtual display
            } else {
                // Fallback: If no virtual display exists, just toggle normally so button works
                targetId = if (actualCurrentId == 0) 1 else 0
                Toast.makeText(this, "No Virtual Display Active", Toast.LENGTH_SHORT).show()
            }
        } else {
            // CASE: We are on Virtual -> Go back to ACTIVE Physical Display
            
            val d0 = dm.getDisplay(0)
            val d1 = dm.getDisplay(1)
            setKeepScreenOn(false)
            
            // Check states to see which screen is actually awake
            val isZeroOn = d0?.state == Display.STATE_ON
            val isOneOn = d1?.state == Display.STATE_ON
            
            if (isZeroOn) {
                targetId = 0
            } else if (isOneOn) {
                targetId = 1
            } else {
                // If both are reported off (unlikely while using phone), default to Main
                targetId = 0
            }
        }

        // 3. Execute Switch if target is different
        if (targetId != actualCurrentId) {
            performDisplayChange(targetId)
        }
    }
    private fun performDisplayChange(newId: Int) {
        lastManualSwitchTime = System.currentTimeMillis()
        val dm = getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
        val targetDisplay = dm.getDisplay(newId) ?: return
        
        // 1. CLEANUP using the captured manager (Robust)
        try { 
            val wm = attachedWindowManager ?: windowManager
            
            if (bubbleView != null) {
                try { wm.removeView(bubbleView) } catch(e: Exception) {}
            }
            
            if (drawerView != null && isExpanded) {
                try { wm.removeView(drawerView) } catch(e: Exception) {}
            }
        } catch (e: Exception) { Log.e(TAG, "Cleanup failed", e) }

        // Clear cached auxiliary views using CURRENT (Old) WM before switching context
        if (visualQueueView != null) {
            try { windowManager.removeView(visualQueueView) } catch(e: Exception){}
            visualQueueView = null
            isVisualQueueVisible = false
        }
        if (keyPickerView != null) {
            try { windowManager.removeView(keyPickerView) } catch(e: Exception){}
            keyPickerView = null
        }

        // 2. SWITCH
        currentDisplayId = newId
        setupDisplayContext(currentDisplayId)
        targetDisplayIndex = currentDisplayId
        AppPreferences.setTargetDisplayIndex(this, targetDisplayIndex)
        
        // WATCHDOG STATE LOG
        if (currentDisplayId >= 2) {
            Log.w("DROIDOS_WATCHDOG", ">>> WATCHDOG ENABLED (Targeting Virtual D$currentDisplayId) <<<")
        } else {
            Log.w("DROIDOS_WATCHDOG", ">>> WATCHDOG DISABLED (Targeting Physical D$currentDisplayId) <<<")
        }
        
        // [NEW] Launch Wallpaper if on Virtual Display
        // This ensures there is always a window at the bottom of the stack to hold focus.
        if (currentDisplayId >= 2) {
            try {
                val intent = Intent(this, MainActivity::class.java)
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                intent.putExtra("WALLPAPER_MODE", true)
                
                val options = android.app.ActivityOptions.makeBasic()
                options.setLaunchDisplayId(currentDisplayId)
                
                startActivity(intent, options.toBundle())
                
                // Optional: Move it to back after a short delay so it doesn't cover existing apps
                // (If you are switching to a display that already has apps open)
                uiHandler.postDelayed({
                    try {
                        val tid = shellService?.getTaskId(packageName, null) ?: -1
                        if (tid != -1) shellService?.moveTaskToBack(tid)
                    } catch(e: Exception){}
                }, 500)
                
            } catch (e: Exception) {
                Log.e(TAG, "Failed to launch wallpaper", e)
            }
        }

        // 3. REBUILD
        setupBubble()
        setupDrawer()
        
        loadDisplaySettings(currentDisplayId)
        updateBubbleIcon()
        isExpanded = false
        safeToast("Switched to Display $currentDisplayId (${targetDisplay.name})")

        // [FIX] Apply layout immediately if in Instant Mode
        if (isInstantMode) {
            uiHandler.postDelayed({ applyLayoutImmediate() }, 500)
        }
    }
    private fun toggleVirtualDisplay(enable: Boolean) { isVirtualDisplayActive = enable; Thread { try { if (enable) { shellService?.runCommand("settings put global overlay_display_devices \"1920x1080/320\""); uiHandler.post { safeToast("Creating Virtual Display... Wait a moment, then Switch Display.") } } else { shellService?.runCommand("settings delete global overlay_display_devices"); uiHandler.post { safeToast("Destroying Virtual Display...") } } } catch (e: Exception) { Log.e(TAG, "Virtual Display Toggle Failed", e) } }.start(); if (currentMode == MODE_SETTINGS) uiHandler.postDelayed({ switchMode(MODE_SETTINGS) }, 500) }

    // --- v2.0 SCREEN OFF LOGIC ---
    private fun performScreenOff() {
        vibrate()
        isScreenOffState = true
        safeToast("Screen Off: Double press Power Button to turn on")
        
        if (useAltScreenOff) {
             Thread {
                 try {
                     if (shellService != null) {
                         shellService?.setBrightness(0, -1)
                         uiHandler.post { safeToast("Pixels OFF (Alternate Mode)") }
                     } else {
                         safeToast("Service Disconnected!")
                     }
                 } catch (e: Exception) {
                     Log.e(TAG, "Binder Call Failed", e)
                     safeToast("Error: ${e.message}")
                 }
            }.start()
        } else {
            Thread { try { shellService?.setScreenOff(0, true) } catch (e: Exception) {} }.start()
            safeToast("Screen OFF (SurfaceControl)")
        }
    }
    
    private fun wakeUp() {
        vibrate()
        isScreenOffState = false
        
        Thread { try { shellService?.setBrightness(0, 128) } catch (e: Exception) {} }.start()
        Thread { try { shellService?.setScreenOff(0, false) } catch (e: Exception) {} }.start()

        safeToast("Screen On")
        if (currentMode == MODE_SETTINGS) drawerView?.findViewById<RecyclerView>(R.id.rofi_recycler_view)?.adapter?.notifyDataSetChanged()
    }

    private fun applyLayoutImmediate(focusPackage: String? = null) { executeLaunch(selectedLayoutType, closeDrawer = false, focusPackage = focusPackage) }

    // === RESTORE QUEUE IMMEDIATE - START ===
    // Loads the saved queue from preferences immediately without checking shell/running state.
    // Ensures Visual Queue is populated even if the Drawer hasn't been opened yet.
    private fun restoreQueueFromPrefs() {
        val lastQueue = AppPreferences.getLastQueue(this)
        selectedAppsQueue.clear()
        
        for (identifier in lastQueue) {
            if (identifier == PACKAGE_BLANK) {
                selectedAppsQueue.add(MainActivity.AppInfo(" (Blank Space)", PACKAGE_BLANK, null))
            } else {
                val appInfo = findAppByIdentifier(identifier)
                if (appInfo != null) {
                    selectedAppsQueue.add(appInfo)
                }
            }
        }
        
        // Preserve sorting (Active -> Minimized)
        sortAppQueue()
        updateAllUIs()
        Log.d(TAG, "Restored ${selectedAppsQueue.size} apps from prefs")
    }
    // === RESTORE QUEUE IMMEDIATE - END ===

    // === FETCH RUNNING APPS - START ===
    // Fetches visible and running apps from system, merges with saved queue
    // Handles Gemini/Google trampoline case where Gemini runs inside Google Quick Search Box task
    // Key insight: Gemini (com.google.android.apps.bard) shows up as com.google.android.googlequicksearchbox
    // in system visibility reports because it trampolines through Google's SearchActivity
    private fun fetchRunningApps() {
        if (shellService == null) return

        Thread {
            try {
                val visiblePackages = shellService!!.getVisiblePackages(currentDisplayId)
                val allRunning = shellService!!.getAllRunningPackages()
                val lastQueue = AppPreferences.getLastQueue(this)

                // Log.d(DEBUG_TAG, "fetchRunningApps: visible=${visiblePackages.joinToString()}")
                // Log.d(DEBUG_TAG, "fetchRunningApps: lastQueue=${lastQueue.joinToString()}")

                uiHandler.post {
                    selectedAppsQueue.clear()

                    // === PHASE 1: Restore apps from saved queue ===
                    for (identifier in lastQueue) {
                        if (identifier == PACKAGE_BLANK) {
                            selectedAppsQueue.add(MainActivity.AppInfo(" (Blank Space)", PACKAGE_BLANK, null))
                        } else {
                            // Find by identifier (handles both package-only and package:suffix formats)
                            val appInfo = findAppByIdentifier(identifier)

                            if (appInfo != null) {
                                val basePkg = appInfo.getBasePackage()

                                // Check if running - handle Gemini special case
                                val isRunning = if (basePkg == "com.google.android.apps.bard") {
                                    // Gemini trampolines through Google Quick Search Box
                                    allRunning.contains(basePkg) ||
                                    allRunning.contains("com.google.android.googlequicksearchbox")
                                } else {
                                    allRunning.contains(basePkg)
                                }

                                if (isRunning) {
                                    // Check visibility - handle Gemini special case
                                    val isVisible = if (basePkg == "com.google.android.apps.bard") {
                                        visiblePackages.contains(basePkg) ||
                                        visiblePackages.contains("com.google.android.googlequicksearchbox")
                                    } else {
                                        visiblePackages.contains(basePkg)
                                    }

                                    // [FIX] Check for recent manual override (within 5 seconds)
                                    // Prevents app from flickering grey/hidden immediately after unminimizing
                                    val lastManualTime = manualStateOverrides[basePkg] ?: 0L
                                    val isRecentOverride = (System.currentTimeMillis() - lastManualTime) < 5000

                                    if (!isRecentOverride) {
                                        appInfo.isMinimized = !isVisible
                                    } else {
                                        Log.d(DEBUG_TAG, "fetchRunningApps: Ignoring system visibility for ${appInfo.label} (Manual Override Active)")
                                    }

                                    selectedAppsQueue.add(appInfo)
                                    Log.d(DEBUG_TAG, "fetchRunningApps: Restored ${appInfo.label} minimized=${appInfo.isMinimized}")
                                }
                            } else {
                                Log.w(DEBUG_TAG, "fetchRunningApps: Could not find app for identifier=$identifier")
                            }
                        }
                    }

                    // === PHASE 2: Add newly visible apps not already in queue ===
                    for (pkg in visiblePackages) {
                        // Skip if it's Google Quick Search Box - we handle Gemini specifically
                        // and don't want to auto-add Google if the user has Gemini in queue
                        val isGoogleQSB = pkg == "com.google.android.googlequicksearchbox"

                        // Check if already in queue by package or related package
                        val alreadyInQueue = selectedAppsQueue.any { queuedApp ->
                            val queuedBasePkg = queuedApp.getBasePackage()
                            when {
                                // Direct match
                                queuedBasePkg == pkg -> true
                                // Gemini is in queue, and we see Google QSB (trampoline case)
                                isGoogleQSB && queuedBasePkg == "com.google.android.apps.bard" -> true
                                // Google QSB is in queue, and we see Google QSB
                                isGoogleQSB && queuedBasePkg == "com.google.android.googlequicksearchbox" -> true
                                else -> false
                            }
                        }

                        if (!alreadyInQueue) {
                            val appInfo = allAppsList.find { it.packageName == pkg }
                            if (appInfo != null) {
                                appInfo.isMinimized = false
                                selectedAppsQueue.add(appInfo)
                                Log.d(DEBUG_TAG, "fetchRunningApps: Added new visible ${appInfo.label}")
                            }
                        }
                    }

                    sortAppQueue() // Now empty/disabled
                    updateAllUIs()
                }
            } catch (e: Exception) {
                Log.e(TAG, "Fetch failed", e)
            }
        }.start()
    }
    // === FETCH RUNNING APPS - END ===

    // === FIND APP BY IDENTIFIER - START ===
    // Finds an AppInfo from allAppsList by its identifier
    // Handles both simple package names and compound identifiers (package:suffix)
    // Also handles the getIdentifier() format used for saving
    private fun findAppByIdentifier(identifier: String): MainActivity.AppInfo? {
        // First, try exact getIdentifier() match
        val exactMatch = allAppsList.find { it.getIdentifier() == identifier }
        if (exactMatch != null) return exactMatch

        // If identifier contains ":", try matching the components
        if (identifier.contains(":")) {
            val basePkg = identifier.substringBefore(":")
            val suffix = identifier.substringAfter(":")

            // Special case: "com.google.android.googlequicksearchbox:gemini" -> find Gemini app
            if (basePkg == "com.google.android.googlequicksearchbox" && suffix == "gemini") {
                // Look for the standalone Gemini app first
                val geminiStandalone = allAppsList.find { it.packageName == "com.google.android.apps.bard" }
                if (geminiStandalone != null) return geminiStandalone

                // Fall back to Google QSB with Gemini activity
                val geminiInGoogle = allAppsList.find {
                    it.packageName == basePkg &&
                    (it.className?.lowercase()?.contains("gemini") == true ||
                     it.className?.lowercase()?.contains("assistant") == true ||
                     it.className?.lowercase()?.contains("bard") == true)
                }
                if (geminiInGoogle != null) return geminiInGoogle
            }

            // Try matching by base package
            val byBasePkg = allAppsList.find { it.packageName == basePkg }
            if (byBasePkg != null) return byBasePkg
        }

        // Simple package name match
        return allAppsList.find { it.packageName == identifier }
    }
    // === FIND APP BY IDENTIFIER - END ===


    private fun selectLayout(opt: LayoutOption) { 
        dismissKeyboardAndRestore()
        selectedLayoutType = opt.type
        activeCustomRects = opt.customRects
        
        if (opt.type == LAYOUT_CUSTOM_DYNAMIC) { 
            activeCustomLayoutName = opt.name
            AppPreferences.saveLastCustomLayoutName(this, opt.name, currentDisplayId)
        } else { 
            activeCustomLayoutName = null
            AppPreferences.saveLastCustomLayoutName(this, null, currentDisplayId)
        }
        
        AppPreferences.saveLastLayout(this, opt.type, currentDisplayId)
        drawerView!!.findViewById<RecyclerView>(R.id.rofi_recycler_view)?.adapter?.notifyDataSetChanged()
        
        if (isInstantMode) applyLayoutImmediate() 
    }
    private fun saveCurrentAsCustom() { Thread { try { val rawLayouts = shellService!!.getWindowLayouts(currentDisplayId); if (rawLayouts.isEmpty()) { safeToast("Found 0 active app windows"); return@Thread }; val rectStrings = mutableListOf<String>(); for (line in rawLayouts) { val parts = line.split("|"); if (parts.size == 2) { rectStrings.add(parts[1]) } }; if (rectStrings.isEmpty()) { safeToast("Found 0 valid frames"); return@Thread }; val count = rectStrings.size; var baseName = "$count Apps - Custom"; val existingNames = AppPreferences.getCustomLayoutNames(this); var counter = 1; var finalName = "$baseName $counter"; while (existingNames.contains(finalName)) { counter++; finalName = "$baseName $counter" }; AppPreferences.saveCustomLayout(this, finalName, rectStrings.joinToString("|")); safeToast("Saved: $finalName"); uiHandler.post { switchMode(MODE_LAYOUTS) } } catch (e: Exception) { Log.e(TAG, "Failed to save custom layout", e); safeToast("Error saving: ${e.message}") } }.start() }


// =================================================================================
    // FUNCTION: applyRefreshRate
    // SUMMARY: Forces a refresh rate. If hardware doesn't support the rate (e.g. 60Hz 
    //          on 120Hz glasses), attempts multiple software throttling methods.
    //          For displays with only 120Hz (like XReal), uses frame rate throttling
    //          via SurfaceFlinger which limits app rendering (frames duplicate on HW).
    // =================================================================================
    private fun applyRefreshRate(targetRate: Float) {
        manualRefreshRateSet = true 
        safeToast("Applying ${targetRate.toInt()}Hz...")
        
        if (shellService == null) {
            safeToast("Error: Shizuku Disconnected!")
            return
        }
        
        Thread {
            try {
                val dm = getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
                val display = dm.getDisplay(currentDisplayId)
                val modes = display?.supportedModes ?: emptyArray()
                val currentMode = display?.mode
                
                // Log available modes for debugging
                Log.d(TAG, "=== REFRESH RATE DEBUG ===")
                Log.d(TAG, "Target rate: $targetRate Hz")
                Log.d(TAG, "Display $currentDisplayId has ${modes.size} mode(s):")
                modes.forEach { mode ->
                    Log.d(TAG, "  Mode ${mode.modeId}: ${mode.physicalWidth}x${mode.physicalHeight} @ ${mode.refreshRate}Hz")
                }
                
                // Check if hardware supports target rate
                var bestModeId = -1
                var hasHardwareSupport = false
                for (mode in modes) {
                    if (Math.abs(mode.refreshRate - targetRate) < 1.0f) {
                        bestModeId = mode.modeId
                        hasHardwareSupport = true
                        break
                    }
                }
                
                val width = currentMode?.physicalWidth ?: 1920
                val height = currentMode?.physicalHeight ?: 1080
                val rateStr = String.format("%.1f", targetRate)
                val rateInt = targetRate.toInt()
                
                if (hasHardwareSupport) {
                    // === METHOD A: Hardware mode exists - use standard approach ===
                    Log.d(TAG, "Hardware supports ${targetRate}Hz (Mode $bestModeId)")
                    
                    // 1. App-Level Window Override
                    uiHandler.post {
                        try {
                            if (bubbleView != null) {
                                bubbleParams.preferredDisplayModeId = bestModeId
                                val wm = attachedWindowManager ?: windowManager
                                wm.updateViewLayout(bubbleView, bubbleParams)
                            }
                        } catch(e: Exception) {
                            Log.e(TAG, "Window mode override failed", e)
                        }
                    }
                    
                    // 2. System settings
                    shellService?.runCommand("settings put system peak_refresh_rate $rateStr")
                    shellService?.runCommand("settings put system min_refresh_rate $rateStr")
                    
                    // 3. Force display mode
                    val forceCmd = "cmd display set-user-preferred-display-mode $currentDisplayId $width $height $targetRate"
                    shellService?.runCommand(forceCmd)
                    Log.d(TAG, "Applied HW mode: $forceCmd")
                    
                    activeRefreshRateLabel = "${rateInt}Hz"
                    
                } else {
                    // === METHOD B: No hardware support - use software throttling ===
                    Log.w(TAG, "Hardware does NOT support ${targetRate}Hz - using software throttling")
                    
                    // Method B1: SurfaceFlinger frame rate override for the display
                    // This tells SF to throttle frame composition for this display
                    val sfThrottleCmd = "service call SurfaceFlinger 1035 i32 $currentDisplayId f $targetRate"
                    val sfResult = shellService?.runCommand(sfThrottleCmd)
                    Log.d(TAG, "SF throttle result: $sfResult")
                    
                    // Method B2: Set frame rate policy via display service
                    // This affects the render frame rate policy
                    val policyCmd = "cmd display set-match-content-frame-rate-pref 1"
                    shellService?.runCommand(policyCmd)
                    
                    // Method B3: Use render frame rate limit via SurfaceFlinger properties
                    // Note: These may require root or special permissions
                    shellService?.runCommand("service call SurfaceFlinger 1008 i32 ${rateInt}")
                    
                    // Method B4: Set the desired display mode specs with clamped range
                    // This requests SF to limit the render rate even if HW is higher
                    val specCmd = "cmd display set-desired-display-mode-specs $currentDisplayId -p $targetRate $targetRate -r $targetRate $targetRate"
                    val specResult = shellService?.runCommand(specCmd)
                    Log.d(TAG, "Mode specs result: $specResult")
                    
                    // Method B5: Try forcing the base/peak refresh for this display specifically
                    shellService?.runCommand("settings put system min_refresh_rate_$currentDisplayId $rateStr")
                    shellService?.runCommand("settings put system peak_refresh_rate_$currentDisplayId $rateStr")
                    
                    // Method B6: Global settings (may not affect external displays but worth trying)
                    shellService?.runCommand("settings put system peak_refresh_rate $rateStr")
                    shellService?.runCommand("settings put system min_refresh_rate $rateStr")
                    
                    // Method B7: Attempt user-preferred mode anyway (sometimes kicks SF into action)
                    val forceCmd = "cmd display set-user-preferred-display-mode $currentDisplayId $width $height $targetRate"
                    shellService?.runCommand(forceCmd)
                    
                    activeRefreshRateLabel = "Limit: ${rateInt}Hz (SW)"
                    
                    Log.i(TAG, "Software throttle applied - display still at HW rate but rendering limited")
                }
                
                Thread.sleep(800)
                
                // Re-query to see what actually happened
                val newDisplay = dm.getDisplay(currentDisplayId)
                val actualRate = newDisplay?.refreshRate ?: 0f
                Log.d(TAG, "Post-apply rate: $actualRate Hz")
                
                uiHandler.post { 
                    switchMode(MODE_REFRESH)
                    if (hasHardwareSupport) {
                        safeToast("Applied: ${rateInt}Hz")
                    } else {
                        safeToast("SW Limit: ${rateInt}Hz (HW: ${actualRate.toInt()}Hz)")
                    }
                }
                
            } catch (e: Exception) {
                Log.e(TAG, "Failed to set refresh rate", e)
                uiHandler.post { safeToast("Error: ${e.message}") }
            }
        }.start()
    }
    // =================================================================================
    // END BLOCK: applyRefreshRate
    // =================================================================================




    private fun applyResolution(opt: ResolutionOption) { dismissKeyboardAndRestore(); if (opt.index != -1) { selectedResolutionIndex = opt.index; AppPreferences.saveDisplayResolution(this, currentDisplayId, opt.index) }; drawerView!!.findViewById<RecyclerView>(R.id.rofi_recycler_view)?.adapter?.notifyDataSetChanged(); if (isInstantMode && opt.index != -1) { Thread { val resCmd = getResolutionCommand(selectedResolutionIndex); shellService?.runCommand(resCmd); Thread.sleep(1500); uiHandler.post { applyLayoutImmediate() } }.start() } }
    private fun selectDpi(value: Int) { currentDpiSetting = if (value == -1) -1 else value.coerceIn(50, 600); AppPreferences.saveDisplayDpi(this, currentDisplayId, currentDpiSetting); Thread { try { if (currentDpiSetting == -1) { shellService?.runCommand("wm density reset -d $currentDisplayId") } else { val dpiCmd = "wm density $currentDpiSetting -d $currentDisplayId"; shellService?.runCommand(dpiCmd) } } catch(e: Exception) { e.printStackTrace() } }.start() }
    private fun changeFontSize(newSize: Float) { currentFontSize = newSize.coerceIn(10f, 30f); AppPreferences.saveFontSize(this, currentFontSize); updateGlobalFontSize(); if (currentMode == MODE_SETTINGS) { switchMode(MODE_SETTINGS) } }
    private fun changeDrawerHeight(delta: Int) { currentDrawerHeightPercent = (currentDrawerHeightPercent + delta).coerceIn(30, 100); AppPreferences.setDrawerHeightPercent(this, currentDrawerHeightPercent); updateDrawerHeight(false); if (currentMode == MODE_SETTINGS) { drawerView!!.findViewById<RecyclerView>(R.id.rofi_recycler_view)?.adapter?.notifyDataSetChanged() } }
    private fun changeDrawerWidth(delta: Int) { currentDrawerWidthPercent = (currentDrawerWidthPercent + delta).coerceIn(30, 100); AppPreferences.setDrawerWidthPercent(this, currentDrawerWidthPercent); updateDrawerHeight(false); if (currentMode == MODE_SETTINGS) { drawerView!!.findViewById<RecyclerView>(R.id.rofi_recycler_view)?.adapter?.notifyDataSetChanged() } }
    private fun pickIcon() { toggleDrawer(); try { refreshDisplayId(); val intent = Intent(this, IconPickerActivity::class.java); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); val metrics = windowManager.maximumWindowMetrics; val w = 1000; val h = (metrics.bounds.height() * 0.7).toInt(); val x = (metrics.bounds.width() - w) / 2; val y = (metrics.bounds.height() - h) / 2; val options = android.app.ActivityOptions.makeBasic(); options.setLaunchDisplayId(currentDisplayId); options.setLaunchBounds(Rect(x, y, x+w, y+h)); startActivity(intent, options.toBundle()) } catch (e: Exception) { safeToast("Error launching picker: ${e.message}") } }
    private fun saveProfile() { var name = drawerView?.findViewById<EditText>(R.id.rofi_search_bar)?.text?.toString()?.trim(); if (name.isNullOrEmpty()) { val timestamp = SimpleDateFormat("HH:mm", Locale.getDefault()).format(Date()); name = "Profile_$timestamp" }; val pkgs = selectedAppsQueue.map { it.packageName }; AppPreferences.saveProfile(this, name, selectedLayoutType, selectedResolutionIndex, currentDpiSetting, pkgs); safeToast("Saved: $name"); drawerView?.findViewById<EditText>(R.id.rofi_search_bar)?.setText(""); switchMode(MODE_PROFILES) }
    private fun loadProfile(name: String) { 
        val data = AppPreferences.getProfileData(this, name) ?: return
        try { 
            val parts = data.split("|")
            selectedLayoutType = parts[0].toInt()
            selectedResolutionIndex = parts[1].toInt()
            currentDpiSetting = parts[2].toInt()
            val pkgList = parts[3].split(",")
            selectedAppsQueue.clear()
            for (pkg in pkgList) { 
                if (pkg.isNotEmpty()) { 
                    if (pkg == PACKAGE_BLANK) { 
                        selectedAppsQueue.add(MainActivity.AppInfo(" (Blank Space)", PACKAGE_BLANK, null)) 
                    } else { 
                        val app = allAppsList.find { it.packageName == pkg }
                        if (app != null) selectedAppsQueue.add(app) 
                    } 
                } 
            }
            // Save settings for CURRENT DISPLAY
            AppPreferences.saveLastLayout(this, selectedLayoutType, currentDisplayId)
            // Note: Profile loading doesn't inherently set a specific CUSTOM layout name unless we inferred it,
            // so we might want to clear the custom layout name to avoid mismatches, or keep as is.
            // For safety, let's clear custom layout name to prevent stale rects if profile used standard layout.
            if (selectedLayoutType != LAYOUT_CUSTOM_DYNAMIC) {
                activeCustomLayoutName = null
                AppPreferences.saveLastCustomLayoutName(this, null, currentDisplayId)
            }
            
            AppPreferences.saveDisplayResolution(this, currentDisplayId, selectedResolutionIndex)
            AppPreferences.saveDisplayDpi(this, currentDisplayId, currentDpiSetting)
            
            activeProfileName = name
            updateSelectedAppsDock()
            safeToast("Loaded: $name")
            drawerView!!.findViewById<RecyclerView>(R.id.rofi_recycler_view)?.adapter?.notifyDataSetChanged()
            
            if (isInstantMode) applyLayoutImmediate() 
        } catch (e: Exception) { 
            Log.e(TAG, "Failed to load profile", e) 
        } 
    }
    

    // === EXECUTE LAUNCH - START ===
    // Main execution function that launches and tiles all selected apps
    // Uses a locking mechanism to prevent parallel shell commands causing race conditions.
    private fun executeLaunch(layoutType: Int, closeDrawer: Boolean, focusPackage: String? = null) {
        // Cancel any pending runnable
        if (pendingLaunchRunnable != null) {
            uiHandler.removeCallbacks(pendingLaunchRunnable!!)
            pendingLaunchRunnable = null
        }

        // If already executing, queue this request
        if (isExecuting) {
            Log.d(TAG, "executeLaunch: Already running. Queueing next run.")
            pendingExecutionNeeded = true
            if (focusPackage != null) pendingFocusPackage = focusPackage
            return
        }

        isExecuting = true
        pendingExecutionNeeded = false // Reset pending flag for THIS run

        // Get currently visible apps on this display, excluding ourselves and the trackpad
        val activeApps = shellService?.getVisiblePackages(currentDisplayId)
            ?.mapNotNull { pkgName -> allAppsList.find { it.packageName == pkgName } }
            ?.filter { it.packageName != packageName && it.packageName != PACKAGE_TRACKPAD }
            ?: emptyList()

        if (closeDrawer) toggleDrawer()
        refreshDisplayId()

        // Save queue
        val identifiers = selectedAppsQueue.map { it.getIdentifier() }
        AppPreferences.saveLastQueue(this, identifiers)
        
        Thread { 
            try { 
                var configChanged = false

                // Apply resolution only if changed
                if (selectedResolutionIndex != lastAppliedResIndex) {
                    val resCmd = getResolutionCommand(selectedResolutionIndex)
                    shellService?.runCommand(resCmd)
                    lastAppliedResIndex = selectedResolutionIndex
                    configChanged = true
                }
                
                // Apply DPI only if changed
                if (currentDpiSetting != lastAppliedDpi) {
                    if (currentDpiSetting > 0) { 
                        shellService?.runCommand("wm density $currentDpiSetting -d $currentDisplayId")
                    } else if (currentDpiSetting == -1) { 
                        shellService?.runCommand("wm density reset -d $currentDisplayId")
                    }
                    lastAppliedDpi = currentDpiSetting
                    configChanged = true
                }
                
                // [FIX] Only sleep if we actually changed system configuration
                if (configChanged) {
                    Thread.sleep(800)
                }
                
                // Get screen dimensions
                
                                // [FIX] Use getLayoutRects() which contains the Bottom Margin logic.
                // We use the member variable 'selectedLayoutType' (which matches the passed 'layoutType' 99% of the time).
                val rects = getLayoutRects()
                
                Log.d(TAG, "executeLaunch: Generated ${rects.size} tiles with Margin $bottomMarginPercent%")
                
                if (selectedAppsQueue.isEmpty()) {
                    uiHandler.post { safeToast("No apps in queue") }
                    return@Thread
                }
                
                // Handle minimized apps
                val minimizedApps = selectedAppsQueue.filter { it.isMinimized }
                
                // If on Virtual Display and NO active apps (Show Desktop), just launch Wallpaper
                if (currentDisplayId >= 2 && activeApps.isEmpty() && minimizedApps.isNotEmpty()) {
                    showWallpaper()
                } else {
                    // Standard Loop
                    for (app in minimizedApps) { 
                        if (app.packageName != PACKAGE_BLANK) { 
                            try { 
                                val basePkg = app.getBasePackage()
                                val tid = shellService?.getTaskId(basePkg, app.className) ?: -1
                                if (tid != -1) shellService?.moveTaskToBack(tid) 
                            } catch (e: Exception) {} 
                        } 
                    }
                }
                
                val activeApps = selectedAppsQueue.filter { !it.isMinimized }
                
                // Kill/Prep Logic - Only wait if we actually have apps to launch
                // [FIX] If activeApps is empty (we are just minimizing), SKIP THE SLEEP.
                if (activeApps.isNotEmpty()) {
                    if (killAppOnExecute) { 
                        for (app in activeApps) { 
                            if (app.packageName != PACKAGE_BLANK) { 
                                val basePkg = app.getBasePackage()
                                shellService?.forceStop(basePkg)
                            } 
                        }
                        Thread.sleep(400) 
                    } else { 
                        Thread.sleep(100) 
                    }
                }
                
// === LAUNCH AND TILE APPS (Robust Background Loop) ===
                // [FIX] We use Thread.sleep inside this background thread instead of uiHandler.postDelayed.
                // This ensures the sequence continues executing even if the UI thread is throttled/closed.
                for (i in 0 until minOf(activeApps.size, rects.size)) {
                    val app = activeApps[i]
                    val bounds = rects[i]

                    if (app.packageName == PACKAGE_BLANK) continue

                    val basePkg = app.getBasePackage()
                    val cls = app.className

                    // UI Update must be posted
                    uiHandler.post {
                        debugShowAppIdentification("TILE[$i]", basePkg, cls)
                    }
                    
                    // [CACHE] Store intended bounds for Watchdog recovery
                    packageRectCache[basePkg] = bounds

                    // 1. Launch App (SYNCHRONOUSLY)
                    val component = if (!cls.isNullOrEmpty() && cls != "null" && cls != "default") "$basePkg/$cls" else null
                    val cmd = if (component != null) {
                        "am start -n $component --display $currentDisplayId --windowingMode 5 --user 0"
                    } else {
                        "am start -p $basePkg -a android.intent.action.MAIN -c android.intent.category.LAUNCHER --display $currentDisplayId --windowingMode 5 --user 0"
                    }

                    try {
                        // Log.d(TAG, "Tile[$i]: Executing Launch: $cmd")
                        shellService?.runCommand(cmd)
                    } catch (e: Exception) {
                        // Log.e(TAG, "Tile[$i]: Launch failed", e)
                    }

                    val isGeminiApp = basePkg.contains("bard") || basePkg.contains("gemini")

                    // 2. WAIT AND RESIZE (Sequential/Blocking)
                    // We block the loop here until THIS window is ready and resized.
                    // This ensures App 1 is fully positioned before we even touch App 2.
                    try {
                        // SMART POLLING:
                        // Active Window (Swap): Returns almost instantly.
                        // Cold Boot: Waits up to 3s.
                        var tid = -1
                        val maxWait = if (isGeminiApp) 8000L else 3000L
                        val startPoll = System.currentTimeMillis()

                        // Fast poll (50ms) for snappiness
                        while (System.currentTimeMillis() - startPoll < maxWait) {
                            tid = shellService?.getTaskId(basePkg, cls) ?: -1
                            if (tid != -1) break
                            Thread.sleep(50)
                        }

                        // If we found it instantly (already running), delay is minimal (50ms).
                        // If it took time, we wait a tiny bit for the window surface to be ready.
                        val wasInstant = (System.currentTimeMillis() - startPoll < 150)
                        if (!wasInstant) Thread.sleep(200)

                        // PASS 1: Set Mode & Resize
                        // Log.d(TAG, "Tile[$i]: Repositioning ${app.label} (TID: $tid)")
                        shellService?.repositionTask(basePkg, cls, bounds.left, bounds.top, bounds.right, bounds.bottom)

                        // PASS 2: Redundant Resize for Samsung (Only if not instant swap)
                        // If we are just swapping active windows, Pass 1 is usually enough.
                        // We do a quick check-up resize.
                        if (!wasInstant) Thread.sleep(200)

                        val finalTid = shellService?.getTaskId(basePkg, cls) ?: -1
                        if (finalTid != -1) {
                            shellService?.runCommand("am task resize $finalTid ${bounds.left} ${bounds.top} ${bounds.right} ${bounds.bottom}")
                        }

                    } catch (e: Exception) {
                        Log.e(TAG, "Tile[$i]: Reposition failed", e)
                    }

                    // 3. Buffer before next app
                    // Increased to 150ms to ensure WindowManager state settles before next 'am start'
                    Thread.sleep(150)
                }
                // === LAUNCH AND TILE APPS - END ===

                // === REFOCUS LOGIC ===
                // After swapping/moving windows, re-launch the active app to bring it back to focus
                if (focusPackage != null) {
                    val focusIndex = activeApps.indexOfFirst {
                        it.packageName == focusPackage ||
                        (it.packageName == "com.google.android.apps.bard" && focusPackage == "com.google.android.googlequicksearchbox")
                    }

                    if (focusIndex != -1 && focusIndex < rects.size) {
                        val app = activeApps[focusIndex]
                        val bounds = rects[focusIndex]
                        Thread.sleep(200)
                        Log.d(TAG, "Refocusing Active Window: ${app.label}")
                        launchViaShell(app.getBasePackage(), app.className, bounds)
                    }
                }
                // === REFOCUS LOGIC - END ===

                if (closeDrawer) { 
                    uiHandler.post { 
                        selectedAppsQueue.clear()
                        updateSelectedAppsDock() 
                    } 
                }
                
                uiHandler.post {
                     safeToast("Tiling Sequence Complete")
                }

            } catch (e: Exception) {
                Log.e(TAG, "Execute Failed", e)
                uiHandler.post { safeToast("Execute Failed: ${e.message}") }
            } finally {
                // [EFFICIENCY] Invalidate cache so "Active Window" updates instantly
                (shellService as? ShellUserService)?.invalidateVisibleCache()

                isExecuting = false

                // If a request came in while we were running, trigger it now
                if (pendingExecutionNeeded) {
                    Log.d(TAG, "executeLaunch: Triggering pending execution")
                    val nextFocus = pendingFocusPackage
                    pendingFocusPackage = null
                    uiHandler.post {
                        executeLaunch(selectedLayoutType, false, nextFocus)
                    }
                }
            }
        }.start()

        drawerView?.findViewById<EditText>(R.id.rofi_search_bar)?.setText("")
    }

    // === EXECUTE LAUNCH - END ===
    
    private fun calculateGCD(a: Int, b: Int): Int { return if (b == 0) a else calculateGCD(b, a % b) }

    // === SWITCH MODE - START ===
    // Switches between different drawer tabs/modes
    // Handles UI updates for search bar, icons, and list content
    private fun switchMode(mode: Int) {
        currentMode = mode
        selectedListIndex = 0 // Reset selection on tab switch
        
        val searchBar = drawerView!!.findViewById<EditText>(R.id.rofi_search_bar); val searchIcon = drawerView!!.findViewById<ImageView>(R.id.icon_search_mode); val iconWin = drawerView!!.findViewById<ImageView>(R.id.icon_mode_window);        val iconRes = drawerView!!.findViewById<ImageView>(R.id.icon_mode_resolution);
        val iconRefresh = drawerView!!.findViewById<ImageView>(R.id.icon_mode_refresh); val iconDpi = drawerView!!.findViewById<ImageView>(R.id.icon_mode_dpi); val iconBlacklist = drawerView!!.findViewById<ImageView>(R.id.icon_mode_blacklist); val iconProf = drawerView!!.findViewById<ImageView>(R.id.icon_mode_profiles); val iconKeybinds = drawerView!!.findViewById<ImageView>(R.id.icon_mode_keybinds); val iconSet = drawerView!!.findViewById<ImageView>(R.id.icon_mode_settings); val executeBtn = drawerView!!.findViewById<ImageView>(R.id.icon_execute)
        searchIcon.setColorFilter(if(mode==MODE_SEARCH) Color.WHITE else Color.GRAY); iconWin.setColorFilter(if(mode==MODE_LAYOUTS) Color.WHITE else Color.GRAY);        iconRes.setColorFilter(if(mode==MODE_RESOLUTION) Color.WHITE else Color.GRAY);
        iconRefresh?.setColorFilter(if(mode==MODE_REFRESH) Color.WHITE else Color.GRAY); iconDpi.setColorFilter(if(mode==MODE_DPI) Color.WHITE else Color.GRAY); iconBlacklist?.setColorFilter(if(mode==MODE_BLACKLIST) Color.WHITE else Color.GRAY); iconProf.setColorFilter(if(mode==MODE_PROFILES) Color.WHITE else Color.GRAY); iconKeybinds?.setColorFilter(if(mode==MODE_KEYBINDS) Color.WHITE else Color.GRAY); iconSet.setColorFilter(if(mode==MODE_SETTINGS) Color.WHITE else Color.GRAY)
        executeBtn.visibility = if (isInstantMode) View.GONE else View.VISIBLE; displayList.clear(); val dock = drawerView!!.findViewById<RecyclerView>(R.id.selected_apps_recycler); dock.visibility = if (mode == MODE_SEARCH && selectedAppsQueue.isNotEmpty()) View.VISIBLE else View.GONE

        when (mode) {
            MODE_SEARCH -> { searchBar.hint = "Search apps..."; refreshSearchList() }
            MODE_LAYOUTS -> { 
                searchBar.hint = "Select Layout"
                displayList.add(ActionOption("Save Current Arrangement") { saveCurrentAsCustom() })
                
                // [FIX] Add Reset Button to fix corrupted names
                displayList.add(ActionOption("Reset Default Names") { 
                    AppPreferences.clearDefaultLayoutNames(this)
                    safeToast("Layout names reset")
                    switchMode(MODE_LAYOUTS) // Refresh
                })
                
                // Add all default layouts (Labels are fetched via getLayoutName which supports renaming)
                val defaults = listOf(
                    LAYOUT_FULL, LAYOUT_SIDE_BY_SIDE, LAYOUT_TOP_BOTTOM,
                    LAYOUT_TRI_EVEN, LAYOUT_TRI_SIDE_MAIN_SIDE,
                    LAYOUT_CORNERS, LAYOUT_QUAD_ROW_EVEN,
                    LAYOUT_QUAD_TALL_SHORT, LAYOUT_HEX_TALL_SHORT
                )
                
                for (type in defaults) {
                    displayList.add(LayoutOption(getLayoutName(type), type))
                }

                val customNames = AppPreferences.getCustomLayoutNames(this).sorted()
                for (name in customNames) { 
                    val data = AppPreferences.getCustomLayoutData(this, name)
                    if (data != null) { 
                        try { 
                            val rects = mutableListOf<Rect>()
                            val rectParts = data.split("|")
                            for (rp in rectParts) { 
                                val coords = rp.split(",")
                                if (coords.size == 4) { 
                                    rects.add(Rect(coords[0].toInt(), coords[1].toInt(), coords[2].toInt(), coords[3].toInt())) 
                                } 
                            } 
                            displayList.add(LayoutOption(name, LAYOUT_CUSTOM_DYNAMIC, true, rects)) 
                        } catch(e: Exception) {} 
                    } 
                } 
            }
            MODE_RESOLUTION -> {
                searchBar.hint = "Select Resolution"; displayList.add(CustomResInputOption); val savedResNames = AppPreferences.getCustomResolutionNames(this).sorted(); for (name in savedResNames) { val value = AppPreferences.getCustomResolutionValue(this, name) ?: continue; displayList.add(ResolutionOption(name, "wm size  -d $currentDisplayId", 100 + savedResNames.indexOf(name))) }; displayList.add(ResolutionOption("Default (Reset)", "wm size reset -d $currentDisplayId", 0)); displayList.add(ResolutionOption("1:1 Square (1422x1500)", "wm size 1422x1500 -d $currentDisplayId", 1)); displayList.add(ResolutionOption("16:9 Landscape (1920x1080)", "wm size 1920x1080 -d $currentDisplayId", 2)); displayList.add(ResolutionOption("32:9 Ultrawide (3840x1080)", "wm size 3840x1080 -d $currentDisplayId", 3))
            }

// =================================================================================
            // MODE_REFRESH UI BUILDER
            // SUMMARY: Builds the refresh rate selection menu. Queries hardware for supported
            //          modes and marks unavailable rates as greyed out with "(N/A)" suffix.
            //          Single-mode displays (like XReal) show clear "Only XXHz" messaging.
            // =================================================================================
            MODE_REFRESH -> {
                searchBar.hint = "Refresh Rate"
                
                // 1. Get display info and supported modes
                val dm = getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
                val display = dm.getDisplay(currentDisplayId)
                val modes = display?.supportedModes ?: emptyArray()
                val currentRate = display?.refreshRate ?: 60f
                val roundedRate = String.format("%.0f", currentRate)
                
                // 2. Build set of hardware-supported rates (within 1Hz tolerance)
                val supportedRates = mutableSetOf<Int>()
                modes.forEach { mode ->
                    supportedRates.add(Math.round(mode.refreshRate).toInt())
                }
                
                Log.d(TAG, "Display $currentDisplayId supported rates: $supportedRates")
                
                // 3. Build header text based on available modes
                val headerText = when {
                    supportedRates.size == 1 -> {
                        // Single mode display (like XReal glasses)
                        val onlyRate = supportedRates.first()
                        if (activeRefreshRateLabel != null) {
                            "Fixed: ${onlyRate}Hz | $activeRefreshRateLabel"
                        } else {
                            " Display only supports ${onlyRate}Hz"
                        }
                    }
                    activeRefreshRateLabel != null -> {
                        "HW: ${roundedRate}Hz | $activeRefreshRateLabel"
                    }
                    else -> {
                        "Current: ${roundedRate}Hz (${supportedRates.size} modes)"
                    }
                }
                displayList.add(RefreshHeaderOption(headerText))
                
                // 4. Add rate options with availability status
                val rates = listOf(30f, 60f, 90f, 120f)
                for (rate in rates) {
                    val rateInt = rate.toInt()
                    val isHardwareSupported = supportedRates.any { Math.abs(it - rateInt) <= 1 }
                    val isCurrentlyActive = Math.abs(currentRate - rate) < 1.0f
                    
                    // Build label with availability indicator
                    val label = if (isHardwareSupported) {
                        "${rateInt}Hz"
                    } else {
                        "${rateInt}Hz (N/A)"
                    }
                    
                    displayList.add(RefreshItemOption(
                        label = label,
                        targetRate = rate,
                        isSelected = isCurrentlyActive,
                        isAvailable = isHardwareSupported
                    ))
                }
                
                // 5. If only one mode, add info item explaining the limitation
                if (supportedRates.size == 1) {
                    displayList.add(ActionOption(" Hardware Limitation") {
                        safeToast("This display only supports ${supportedRates.first()}Hz. Software limiting not possible.")
                    })
                }
            }
            // =================================================================================
            // END MODE_REFRESH UI BUILDER  
            // =================================================================================
            MODE_DPI -> { searchBar.hint = "Adjust Density (DPI)"; displayList.add(ActionOption("Reset Density (Default)") { selectDpi(-1) }); var savedDpi = currentDpiSetting; if (savedDpi <= 0) { savedDpi = displayContext?.resources?.configuration?.densityDpi ?: 160 }; displayList.add(DpiOption(savedDpi)) }
            MODE_BLACKLIST -> { searchBar.hint = "Blacklisted Apps"; loadBlacklistedApps(); executeBtn.visibility = View.GONE }
            MODE_PROFILES -> { searchBar.hint = "Enter Profile Name..."; displayList.add(ProfileOption("Save Current as New", true, 0,0,0, emptyList())); val profileNames = AppPreferences.getProfileNames(this).sorted(); for (pName in profileNames) { val data = AppPreferences.getProfileData(this, pName); if (data != null) { try { val parts = data.split("|"); val lay = parts[0].toInt(); val res = parts[1].toInt(); val d = parts[2].toInt(); val pkgs = parts[3].split(",").filter { it.isNotEmpty() }; displayList.add(ProfileOption(pName, false, lay, res, d, pkgs)) } catch(e: Exception) {} } } }
            MODE_KEYBINDS -> {
                searchBar.hint = "Configure Hotkeys"
                displayList.add(ActionOption("How to use: Set modifier + key. Press to trigger.") {})
                
                // Add Custom Modifier Config Row
                // displayList.add(CustomModConfigOption(customModKey))

                // TextWatcher Toggle
                // displayList.add(ToggleOption("Gboard/Soft-Key Support", isSoftKeyboardSupport) { enabled ->
                //    isSoftKeyboardSupport = enabled
                //    AppPreferences.setSoftKeyboardSupport(this, enabled)
                //    if (enabled) {
                //        safeToast("Warning: Monitors text changes. Slight performance cost.")
                //    }
                // })

                for (cmd in AVAILABLE_COMMANDS) {
                    val bind = AppPreferences.getKeybind(this, cmd.id)
                    displayList.add(KeybindOption(cmd, bind.first, bind.second))
                }
            }
            MODE_SETTINGS -> {
                searchBar.hint = "Settings"
                // [FIX] Use restartTrackpad() (Hard Kill) to ensure Z-Order is reset properly.
                // launchTrackpad() alone is too gentle and doesn't reset the window stack.
                displayList.add(ActionOption("Launch/Reset Trackpad") { 
                    if (isBound && shellService != null) {
                        restartTrackpad() 
                    } else {
                        launchTrackpad()
                    }
                })


                displayList.add(ActionOption("Switch Display (Current $currentDisplayId)") { switchDisplay() })
                displayList.add(ToggleOption("Virtual Display (1080p)", isVirtualDisplayActive) { toggleVirtualDisplay(it) })
                displayList.add(HeightOption(currentDrawerHeightPercent))
                displayList.add(WidthOption(currentDrawerWidthPercent))
                displayList.add(MarginOption(0, topMarginPercent)) // 0 = Top
                displayList.add(MarginOption(1, bottomMarginPercent)) // 1 = Bottom
                displayList.add(ToggleOption("Auto-Shrink for Keyboard", autoResizeEnabled) { autoResizeEnabled = it; AppPreferences.setAutoResizeKeyboard(this, it) })
                displayList.add(FontSizeOption(currentFontSize))
                displayList.add(IconOption("Launcher Icon (Tap to Change)"))
                displayList.add(ToggleOption("Reorder: Drag & Drop", isReorderDragEnabled) { isReorderDragEnabled = it; AppPreferences.setReorderDrag(this, it) })
                displayList.add(ToggleOption("Reorder: Tap to Swap (Long Press)", isReorderTapEnabled) { isReorderTapEnabled = it; AppPreferences.setReorderTap(this, it) })
                displayList.add(ToggleOption("Instant Mode (Live Changes)", isInstantMode) { isInstantMode = it; AppPreferences.setInstantMode(this, it); executeBtn.visibility = if (it) View.GONE else View.VISIBLE; if (it) fetchRunningApps() })
                displayList.add(ToggleOption("Kill App on Execute", killAppOnExecute) { killAppOnExecute = it; AppPreferences.setKillOnExecute(this, it) })
                
                // --- V2.0 MENU ITEMS RESTORED ---
                
                
                // STANDARD MODE TOGGLE
                displayList.add(ToggleOption("Screen Off (Standard)", isScreenOffState && !useAltScreenOff) { 
                    if (it) {
                        if (isScreenOffState) wakeUp() // Reset if already off
                        useAltScreenOff = false
                        AppPreferences.setUseAltScreenOff(this, false)
                        performScreenOff()
                    } else {
                        wakeUp()
                    }
                })

                // ALTERNATE MODE TOGGLE
                displayList.add(ToggleOption("Screen Off (Alternate)", isScreenOffState && useAltScreenOff) { 
                    if (it) {
                        if (isScreenOffState) wakeUp() // Reset if already off
                        useAltScreenOff = true
                        AppPreferences.setUseAltScreenOff(this, true)
                        performScreenOff()
                    } else {
                        wakeUp()
                    }
                })
                
                displayList.add(ToggleOption("Auto-Start Trackpad", autoRestartTrackpad) { autoRestartTrackpad = it; AppPreferences.setAutoRestartTrackpad(this, it); if (it) safeToast("Trackpad will restart on next Launcher startup") })
                displayList.add(ToggleOption("Shizuku Warning (Icon Alert)", showShizukuWarning) { showShizukuWarning = it; AppPreferences.setShowShizukuWarning(this, it); updateBubbleIcon() })

                // Restart Button (Process Kill - Auto Restarts Service)
                displayList.add(ActionOption("Restart DroidOS Launcher") {
                    safeToast("Restarting Launcher...")
                    stopSelf()
                    android.os.Process.killProcess(android.os.Process.myPid())
                })

                // Terminate Button (Disables Accessibility Service - Requires Manual Re-enable)
                displayList.add(ActionOption("Terminate DroidOS Service") {
                    safeToast("Terminating Service...")
                    if (Build.VERSION.SDK_INT >= 24) {
                        disableSelf()
                    } else {
                        stopSelf()
                    }
                })
            }
        }
        drawerView!!.findViewById<RecyclerView>(R.id.rofi_recycler_view)?.adapter?.notifyDataSetChanged()
    }
    // === SWITCH MODE - END ===

    object CustomResInputOption
    data class RefreshHeaderOption(val text: String)
    // =================================================================================
    // DATA CLASS: RefreshItemOption
    // SUMMARY: Represents a refresh rate option in the menu. isAvailable indicates
    //          if the hardware supports this rate. Unavailable rates are greyed out.
    // =================================================================================
    data class RefreshItemOption(
        val label: String, 
        val targetRate: Float, 
        val isSelected: Boolean,

    val isAvailable: Boolean = true  // NEW: false if hardware doesn't support this rate
    )
    // =================================================================================
    // END DATA CLASS: RefreshItemOption
    // =================================================================================

    data class LayoutOption(val name: String, val type: Int, val isCustomSaved: Boolean = false, val customRects: List<Rect>? = null)
    data class ResolutionOption(val name: String, val command: String, val index: Int)
    data class DpiOption(val currentDpi: Int)
    data class ProfileOption(val name: String, val isCurrent: Boolean, val layout: Int, val resIndex: Int, val dpi: Int, val apps: List<String>)
    data class FontSizeOption(val currentSize: Float)
    data class HeightOption(val currentPercent: Int)
    data class WidthOption(val currentPercent: Int)
    data class MarginOption(val type: Int, val currentPercent: Int) // type: 0=Top, 1=Bottom
    data class IconOption(val name: String)
    data class ActionOption(val name: String, val action: () -> Unit)
    data class ToggleOption(val name: String, var isEnabled: Boolean, val onToggle: (Boolean) -> Unit)
    data class TimeoutOption(val seconds: Int)

    inner class SelectedAppsAdapter : RecyclerView.Adapter<SelectedAppsAdapter.Holder>() {
        inner class Holder(v: View) : RecyclerView.ViewHolder(v) {
            val icon: ImageView = v.findViewById(R.id.selected_app_icon)
            val underline: View = v.findViewById(R.id.focus_underline)
            val frame: View = itemView // Use root frame for border
        }
        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): Holder { return Holder(LayoutInflater.from(parent.context).inflate(R.layout.item_selected_app, parent, false)) }

        // === SELECTED APPS ADAPTER BIND - START ===
        override fun onBindViewHolder(holder: Holder, position: Int) {
            val app = selectedAppsQueue[position]

            // Show Focus Underline
            val isFocused = (app.packageName == activePackageName) ||
                            (app.packageName == "com.google.android.apps.bard" && activePackageName == "com.google.android.googlequicksearchbox")
            holder.underline.visibility = if (isFocused) View.VISIBLE else View.GONE

            // === KEYBOARD NAVIGATION HIGHLIGHT ===
            // 1. Is this the currently selected slot?
            val isNavSelected = (currentFocusArea == FOCUS_QUEUE && position == queueSelectedIndex)
            
            // 2. Is this the source slot for a pending command (e.g. Swap)?
            val isCommandSource = (queueCommandPending != null && position == queueCommandSourceIndex)

            if (isNavSelected) {
                // Bright White Border for Selection
                val bg = GradientDrawable()
                bg.setStroke(4, Color.WHITE)
                bg.cornerRadius = 8f
                bg.setColor(Color.parseColor("#44FFFFFF")) // Semi-transparent fill
                holder.frame.background = bg
            } else if (isCommandSource) {
                // Dashed Yellow/Green Border for Source
                val bg = GradientDrawable()
                bg.setStroke(4, Color.GREEN, 10f, 5f) // Dashed
                bg.cornerRadius = 8f
                holder.frame.background = bg
            } else {
                holder.frame.background = null
            }
            // =====================================

            holder.icon.clearColorFilter()
            
            if (app.packageName == PACKAGE_BLANK) { 
                holder.icon.setImageResource(R.drawable.ic_box_outline) 
            } else { 
                try { 
                    // Use packageName directly - it should be the real package, not a modified identifier
                    val iconPkg = app.packageName
                    // Log.d(DEBUG_TAG, "Loading icon for position $position: ${app.label} pkg=$iconPkg") // SILENCED
                    holder.icon.setImageDrawable(packageManager.getApplicationIcon(iconPkg)) 
                } catch (e: Exception) { 
                    // Log.e(DEBUG_TAG, "Failed to load icon for ${app.packageName}", e) // SILENCED
                    holder.icon.setImageResource(R.drawable.ic_launcher_bubble) 
                }
                holder.icon.alpha = if (app.isMinimized) 0.4f else 1.0f 
            }
            
            holder.itemView.setOnClickListener { 
                try { 
                    dismissKeyboardAndRestore()
                    if (reorderSelectionIndex != -1) { 
                        if (position == reorderSelectionIndex) { 
                            endReorderMode(false) 
                        } else { 
                            swapReorderItem(position) 
                        } 
                    } else { 
                        if (app.packageName != PACKAGE_BLANK) { 
                            // [FIX] Use centralized command to ensure focus logic runs
                            // This routes the click through handleWindowManagerCommand which contains the logic
                            // to clear activePackageName if the minimized app was the focused one.
                            val intent = Intent().apply {
                                putExtra("COMMAND", "TOGGLE_MINIMIZE")
                                putExtra("INDEX", position + 1) // Handler expects 1-based index
                            }
                            handleWindowManagerCommand(intent)
                        } 
                    } 
                } catch(e: Exception) {
                    // Log.e(DEBUG_TAG, "Click handler error", e) // SILENCED
                } 
            }
            
            holder.itemView.setOnLongClickListener { 
                if (isReorderTapEnabled) { 
                    startReorderMode(position)
                    true 
                } else { 
                    false 
                } 
            }
        }
        // === SELECTED APPS ADAPTER BIND - END ===
        override fun getItemCount() = selectedAppsQueue.size
    }

    // =================================================================================
    // WINDOW MANAGER COMMAND PROCESSOR (v2)
    // SUMMARY: Handles headless commands with 1-BASED INDEXING.
    //          Supports Active Window swapping and Blank Space hiding.
    // =================================================================================
    private fun handleWindowManagerCommand(intent: Intent) {
        val cmd = intent.getStringExtra("COMMAND")?.uppercase(Locale.ROOT) ?: return
        
        // CONVERT 1-BASED INDEX TO 0-BASED INTERNAL INDEX
        // If user sends 1, we get 0. If user sends 0 or nothing (-1), it stays invalid (-1).
        val rawIndex = intent.getIntExtra("INDEX", -1)
        val index = if (rawIndex > 0) rawIndex - 1 else -1

        Log.d(TAG, "WM Command: $cmd RawIdx: $rawIndex (Internal: $index)")

        when (cmd) {
            "SWAP" -> {
                // Convert both A and B from 1-based
                val rawA = intent.getIntExtra("INDEX_A", -1)
                val rawB = intent.getIntExtra("INDEX_B", -1)
                val idxA = if (rawA > 0) rawA - 1 else -1
                val idxB = if (rawB > 0) rawB - 1 else -1
                
                if (idxA in selectedAppsQueue.indices && idxB in selectedAppsQueue.indices) {
                    val appA = selectedAppsQueue[idxA]
                    val appB = selectedAppsQueue[idxB]

                    // LOGIC: State Swap if mixed Active/Inactive
                    // This allows inactive apps to "take the place" of active ones
                    if (appA.isMinimized != appB.isMinimized) {
                        val stateA = appA.isMinimized
                        appA.isMinimized = appB.isMinimized
                        appB.isMinimized = stateA
                    }

                    Collections.swap(selectedAppsQueue, idxA, idxB)

                    // LOGIC: Remove Inactive Blanks (Auto-Delete)
                    // If a blank space was swapped into an inactive state, delete it
                    val toRemove = mutableListOf<MainActivity.AppInfo>()
                    if (appA.packageName == PACKAGE_BLANK && appA.isMinimized) toRemove.add(appA)
                    if (appB.packageName == PACKAGE_BLANK && appB.isMinimized) toRemove.add(appB)
                    
                    if (toRemove.isNotEmpty()) {
                        selectedAppsQueue.removeAll(toRemove)
                    }

                    refreshQueueAndLayout("Swapped slots $rawA & $rawB")
                }
            }
            // =====================================================================
            // ACTIVE WINDOW COMMANDS (PC Style)
            // Finds the currently focused app in the queue and moves it.
            // =====================================================================
            "SWAP_ACTIVE_LEFT", "SWAP_ACTIVE_RIGHT" -> {
                if (activePackageName == null) {
                    safeToast("No active window detected")
                    return
                }
                
                // Find index of active app
                // We match by package name (simplest)
                val activeIdx = selectedAppsQueue.indexOfFirst { 
                    it.packageName == activePackageName || 
                    (it.packageName == "com.google.android.apps.bard" && activePackageName == "com.google.android.googlequicksearchbox") 
                }

                if (activeIdx != -1) {
                    val dir = if (cmd == "SWAP_ACTIVE_LEFT") -1 else 1
                    val targetIdx = activeIdx + dir

                    if (targetIdx in selectedAppsQueue.indices) {
                        Collections.swap(selectedAppsQueue, activeIdx, targetIdx)
                        refreshQueueAndLayout("Moved Active Window ${if(dir<0) "Left" else "Right"}", activePackageName)
                    } else {
                        safeToast("Edge of layout reached")
                    }
                } else {
                    safeToast("Active app not in layout")
                }
            }
            "KILL" -> {
                if (index in selectedAppsQueue.indices) {
                    val app = selectedAppsQueue[index]
                    if (app.packageName != PACKAGE_BLANK) {
                        val basePkg = app.getBasePackage()
                        removeFromFocusHistory(basePkg) // Clean up history
                        Thread { try { shellService?.forceStop(basePkg) } catch(e: Exception){} }.start()
                    }
                    selectedAppsQueue.removeAt(index)
                    
                    if (reorderSelectionIndex == index) reorderSelectionIndex = -1
                    else if (reorderSelectionIndex > index) reorderSelectionIndex--
                    
                    refreshQueueAndLayout("Closed ${app.label}")
                }
            }
            // =====================================================================
            // MINIMIZE (Formerly Hide) - Toggles 'isMinimized' flag
            // =====================================================================
            // =====================================================================
            // MINIMIZE (Shifting Hide)
            // SUMMARY: Toggles the 'isMinimized' flag. The app remains in queue
            //          but is skipped by tiling, causing neighbors to SHIFT to fill gap.
            // =====================================================================
            "MINIMIZE", "UNMINIMIZE", "TOGGLE_MINIMIZE" -> {
                if (index in selectedAppsQueue.indices) {
                    val app = selectedAppsQueue[index]

                    // SPECIAL BLANK LOGIC: Hide/Minimize = Delete
                    if (app.packageName == PACKAGE_BLANK) {
                        if (cmd == "MINIMIZE" || (cmd == "TOGGLE_MINIMIZE" && !app.isMinimized)) {
                            selectedAppsQueue.removeAt(index)
                            refreshQueueAndLayout("Removed Blank Space")
                            return
                        }
                    }

                    val newState = when (cmd) {
                        "MINIMIZE" -> true
                        "UNMINIMIZE" -> false
                        else -> !app.isMinimized
                    }

                                        if (app.isMinimized != newState) {
                                                                app.isMinimized = newState
                                                                
                                                                val basePkg = app.getBasePackage()
                                                                // [FIX] Record manual override timestamp
                                                                manualStateOverrides[basePkg] = System.currentTimeMillis()
                                                                
                                                                val cls = app.className
                                                                
                                                                if (newState) {
                                                                     // [FIX] Clear focus if minimizing the active app
                                                                     // Handles Gemini alias (app=bard, active=google)
                                                                     val isGemini = basePkg == "com.google.android.apps.bard"
                                                                     val activeIsGoogle = activePackageName == "com.google.android.googlequicksearchbox"
                                                                     
                                                                     if (activePackageName == basePkg || 
                                                                         activePackageName == app.packageName ||
                                                                         (isGemini && activeIsGoogle)) {
                                                                         activePackageName = null
                                                                     }
                                                                     
    // MINIMIZING: Move to Back
                                     Thread {
                                         try {
                                             // Virtual Display Strategy
                                             if (currentDisplayId >= 2) {
                                                 // Check if this is the ONLY visible app
                                                 val visibleCount = shellService?.getVisiblePackages(currentDisplayId)?.size ?: 0
                                                 val isLastApp = visibleCount <= 1 

                                                 if (isLastApp) {
                                                     // LAST APP: "Launch" the wallpaper to cover it.
                                                     // This avoids the system hanging while searching for a Home screen.
                                                     showWallpaper()
                                                 } else {
                                                     // NOT LAST: Standard minimize works fine (focus transfers to app behind)
                                                     val tid = shellService?.getTaskId(basePkg, cls) ?: -1
                                                     if (tid != -1) shellService?.moveTaskToBack(tid)
                                                 }
                                             } else {
                                                 // Standard Display (Phone/Cover)
                                                 val tid = shellService?.getTaskId(basePkg, cls) ?: -1
                                                 if (tid != -1) shellService?.moveTaskToBack(tid)
                                             }
                                         } catch(e: Exception){}
                                     }.start()
                                                                     // We removed the redundant thread here to prevent race conditions and double-execution lag.

                                                                } else {
                             // RESTORING: Bring to Front on Current Display
                             // We reuse the launch logic which handles "Bring to Front" if already running.
                             // We run this in background to avoid UI stutter.
                             Thread {
                                 try {
                                     // Use launchViaShell which forces display ID and windowing mode
                                     // We calculate the target bounds based on current layout to ensure it snaps back correctly
                                     val rects = getLayoutRects()
                                     val bounds = if (index < rects.size) rects[index] else null

                                     // This command forces the activity to the top of the stack on current display
                                     val component = if (!cls.isNullOrEmpty() && cls != "null" && cls != "default") "$basePkg/$cls" else null
                                     val cmd = if (component != null) {
                                         "am start -n $component --display $currentDisplayId --windowingMode 5 --user 0"
                                     } else {
                                         "am start -p $basePkg -a android.intent.action.MAIN -c android.intent.category.LAUNCHER --display $currentDisplayId --windowingMode 5 --user 0"
                                     }
                                     shellService?.runCommand(cmd)

                                     // If we have bounds, apply them immediately
                                     if (bounds != null) {
                                         Thread.sleep(300) // Wait for start
                                         val tid = shellService?.getTaskId(basePkg, cls) ?: -1
                                         if (tid != -1) {
                                             shellService?.runCommand("am task resize $tid ${bounds.left} ${bounds.top} ${bounds.right} ${bounds.bottom}")
                                         }
                                     }
                                 } catch(e: Exception) {
                                     Log.e(TAG, "Restore failed", e)
                                 }
                             }.start()
                        }

                        refreshQueueAndLayout(if (newState) "Minimized ${app.label}" else "Restored ${app.label}")
                    }
                }
            }

                        // =====================================================================
                        // HIDE (Swap & Minimize)
                        // SUMMARY: 1. Minimizes target app window.
                        //          2. Adds Blank Space to end of queue.
                        //          3. Swaps Target App with Blank Space.
                        //          Result: Slot becomes empty. Target App moves to end of dock (saved).
                        // =====================================================================
                        "HIDE" -> {
                             if (index in selectedAppsQueue.indices) {
                                val targetApp = selectedAppsQueue[index]
                                
                                // If already blank, remove it
                                if (targetApp.packageName == PACKAGE_BLANK) {
                                    selectedAppsQueue.removeAt(index)
                                    refreshQueueAndLayout("Removed Blank Space")
                                    return
                                }
                                
                                // 1. Force Minimize the visual window
                                val basePkg = targetApp.getBasePackage()
                                val cls = targetApp.className
                                
                                // [FIX] Clear focus if hiding the active app
                                val isGemini = basePkg == "com.google.android.apps.bard"
                                val activeIsGoogle = activePackageName == "com.google.android.googlequicksearchbox"

                                if (activePackageName == basePkg || 
                                    activePackageName == targetApp.packageName ||
                                    (isGemini && activeIsGoogle)) {
                                    activePackageName = null
                                    Log.d(TAG, "WM Command: Cleared focus for hidden app: $basePkg")
                                }

                                Thread { 
                                    try { 
                                        val tid = shellService?.getTaskId(basePkg, cls) ?: -1
                                        if (tid != -1) shellService?.moveTaskToBack(tid)
                                        if (killAppOnExecute) shellService?.forceStop(basePkg)
                                    } catch(e: Exception){}
                                }.start()
                                
                                // 2. Mark target as minimized (Grey out)
                                targetApp.isMinimized = true
                                
                                // 3. Create Blank App
                                val blankApp = MainActivity.AppInfo(" (Blank Space)", PACKAGE_BLANK, null)
                                
                                // 4. Add Blank to end of queue
                                selectedAppsQueue.add(blankApp)
                                
                                // 5. Swap Target (at index) with Blank (at end)
                                // Layout: [A, B, C] -> HIDE B -> [A, Blank, C, B(min)]
                                Collections.swap(selectedAppsQueue, index, selectedAppsQueue.lastIndex)
                                
                                refreshQueueAndLayout("Hidden Slot ${index + 1}")
                             }
                        }            "LAYOUT" -> {
                val type = intent.getIntExtra("TYPE", -1)
                if (type != -1) {
                    selectedLayoutType = type
                    AppPreferences.saveLastLayout(this, type, currentDisplayId)
                    refreshQueueAndLayout("Layout: ${getLayoutName(type)}")
                }
            }
            "CLEAR_ALL" -> {
                if (killAppOnExecute) {
                    val activeApps = selectedAppsQueue.filter { !it.isMinimized && it.packageName != PACKAGE_BLANK }
                    Thread {
                        for (app in activeApps) {
                            try { shellService?.forceStop(app.getBasePackage()) } catch(e: Exception){}
                        }
                    }.start()
                }
                // Wipe all history
                activePackageName = null
                lastValidPackageName = null
                secondLastValidPackageName = null
                
                selectedAppsQueue.clear()
                refreshQueueAndLayout("Cleared All")
            }
            "OPEN_DRAWER" -> {
                Log.d(TAG, "OPEN_DRAWER command received, calling toggleDrawer()")
                toggleDrawer()
                refreshQueueAndLayout("Toggled Drawer")
            }
            "SET_FOCUS" -> {
                // 'index' is 0-based here
                if (index in selectedAppsQueue.indices) {
                    val app = selectedAppsQueue[index]
                    if (app.packageName != PACKAGE_BLANK) {
                        
                        // [FIX] Internal Focus vs System Launch
                        if (isExpanded) {
                            // Drawer Open: Update Internal Variable Only (Green Underline)
                            if (activePackageName != app.packageName) {
                                if (activePackageName != null) lastValidPackageName = activePackageName
                                activePackageName = app.packageName
                                updateAllUIs()
                            }
                        } else {
                            // Drawer Closed: Perform Actual Launch
                            val rects = getLayoutRects()
                            val bounds = if (index < rects.size) rects[index] else null
                            Thread {
                                 launchViaShell(app.getBasePackage(), app.className, bounds)
                            }.start()
                            safeToast("Focused: ${app.label}")
                        }
                    }
                }
            }
            "FOCUS_LAST" -> {
                // Switch to previous valid app
                val target = if (lastValidPackageName == activePackageName) secondLastValidPackageName else lastValidPackageName

                if (target != null) {
                    val app = selectedAppsQueue.find { it.packageName == target }
                    if (app != null) {
                        
                        // [FIX] Internal Focus vs System Launch
                        if (isExpanded) {
                            // Drawer Open: Update Internal Variable Only
                            if (activePackageName != app.packageName) {
                                activePackageName = app.packageName
                                // Swap logic for history
                                lastValidPackageName = target
                                updateAllUIs()
                            }
                        } else {
                            // Drawer Closed: Perform Actual Launch
                            val idx = selectedAppsQueue.indexOf(app)
                            val rects = getLayoutRects()
                            val bounds = if (idx >= 0 && idx < rects.size) rects[idx] else null
                            Thread {
                                 launchViaShell(app.getBasePackage(), app.className, bounds)
                            }.start()
                            safeToast("Focused: ${app.label}")
                        }
                    } else {
                        safeToast("Last app not in layout")
                    }
                } else {
                    safeToast("No history found")
                }
            }
        }
    }

    // Helper to calculate current layout rectangles without executing launch
    private fun getLayoutRects(): List<Rect> {
        val dm = getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
        val display = dm.getDisplay(currentDisplayId) ?: return emptyList()
        val metrics = DisplayMetrics()
        display.getRealMetrics(metrics)
        var w = metrics.widthPixels
        var h = metrics.heightPixels

        // Apply Resolution Override (if any)
        val targetDim = getTargetDimensions(selectedResolutionIndex)
        if (targetDim != null) {
             w = targetDim.first
             h = targetDim.second
        }

        // === MARGIN LOGIC ===
        // Calculate effective height based on Top and Bottom margins
        val topPx = (h * topMarginPercent / 100f).toInt()
        val bottomPx = (h * bottomMarginPercent / 100f).toInt()
        val effectiveH = max(100, h - topPx - bottomPx) // Safety floor
        // ====================

        val rects = mutableListOf<Rect>()
        when (selectedLayoutType) {
            LAYOUT_FULL -> rects.add(Rect(0, 0, w, effectiveH))
            LAYOUT_SIDE_BY_SIDE -> {
                rects.add(Rect(0, 0, w/2, effectiveH))
                rects.add(Rect(w/2, 0, w, effectiveH))
            }
            LAYOUT_TOP_BOTTOM -> {
                // Split effective space in half
                val mid = effectiveH / 2
                rects.add(Rect(0, 0, w, mid))
                rects.add(Rect(0, mid, w, effectiveH))
            }
            LAYOUT_TRI_EVEN -> {
                val third = w / 3
                rects.add(Rect(0, 0, third, effectiveH))
                rects.add(Rect(third, 0, third * 2, effectiveH))
                rects.add(Rect(third * 2, 0, w, effectiveH))
            }
            LAYOUT_CORNERS -> {
                val midH = effectiveH / 2
                val midW = w / 2
                rects.add(Rect(0, 0, midW, midH))
                rects.add(Rect(midW, 0, w, midH))
                rects.add(Rect(0, midH, midW, effectiveH))
                rects.add(Rect(midW, midH, w, effectiveH))
            }
            LAYOUT_TRI_SIDE_MAIN_SIDE -> {
                val quarter = w / 4
                rects.add(Rect(0, 0, quarter, effectiveH))
                rects.add(Rect(quarter, 0, quarter * 3, effectiveH))
                rects.add(Rect(quarter * 3, 0, w, effectiveH))
            }
            LAYOUT_QUAD_ROW_EVEN -> {
                val quarter = w / 4
                rects.add(Rect(0, 0, quarter, effectiveH))
                rects.add(Rect(quarter, 0, quarter * 2, effectiveH))
                rects.add(Rect(quarter * 2, 0, quarter * 3, effectiveH))
                rects.add(Rect(quarter * 3, 0, w, effectiveH))
            }
            LAYOUT_QUAD_TALL_SHORT -> {
                // Top Row: 75% H, 2 Apps (50% W each)
                // Bottom Row: 25% H, 2 Apps (50% W each)
                val splitY = (effectiveH * 0.75f).toInt()
                val midW = w / 2
                
                rects.add(Rect(0, 0, midW, splitY))
                rects.add(Rect(midW, 0, w, splitY))
                rects.add(Rect(0, splitY, midW, effectiveH))
                rects.add(Rect(midW, splitY, w, effectiveH))
            }
            LAYOUT_HEX_TALL_SHORT -> {
                // Top Row: 75% H, 3 Apps (Side/Main/Side 25/50/25)
                // Bottom Row: 25% H, 3 Apps (Same widths)
                val splitY = (effectiveH * 0.75f).toInt()
                val q = w / 4
                
                rects.add(Rect(0, 0, q, splitY))
                rects.add(Rect(q, 0, q * 3, splitY))
                rects.add(Rect(q * 3, 0, w, splitY))
                
                rects.add(Rect(0, splitY, q, effectiveH))
                rects.add(Rect(q, splitY, q * 3, effectiveH))
                rects.add(Rect(q * 3, splitY, w, effectiveH))
            }
            LAYOUT_CUSTOM_DYNAMIC -> {
                if (activeCustomRects != null) {
                    // For custom layouts, we assume they were saved WITH the desired geometry.
                    // However, if the user turns on margin, we should probably clamp them?
                    // For now, let's respect the saved rects exactly as they define absolute pixels.
                    rects.addAll(activeCustomRects!!)
                } else {
                    // Fallback if custom data missing
                    rects.add(Rect(0, 0, w/2, effectiveH))
                    rects.add(Rect(w/2, 0, w, effectiveH))
                }
            }
        }
        
        // SHIFT ALL RECTS DOWN BY TOP MARGIN
        // [FIX] Skip offset for Custom Dynamic layouts (they are absolute snapshots)
        // This prevents double-margin application when loading saved profiles.
        if (topPx > 0 && selectedLayoutType != LAYOUT_CUSTOM_DYNAMIC) {
            for (r in rects) {
                r.offset(0, topPx)
            }
        }
        
        return rects
    }

    private fun refreshQueueAndLayout(msg: String, focusPackage: String? = null) {
        uiHandler.post {
            sortAppQueue() // Ensure active apps are at the front
            updateAllUIs()

            // Auto-save queue state
            val identifiers = selectedAppsQueue.map { it.getIdentifier() }
            AppPreferences.saveLastQueue(this, identifiers)

            safeToast(msg)

            // Trigger Tiling
            if (isInstantMode) {
                applyLayoutImmediate(focusPackage)
            }
        }
    }
    // =================================================================================
    // END WINDOW MANAGER COMMAND PROCESSOR
    // =================================================================================

    private fun logSavedKeybinds() {
        Log.d("DroidOS_Keys", "=== SAVED KEYBINDS ===")
        for (cmd in AVAILABLE_COMMANDS) {
            val bind = AppPreferences.getKeybind(this, cmd.id)
            if (bind.second != 0) {
                val keyName = KeyEvent.keyCodeToString(bind.second)
                // WORKAROUND: KeyEvent.metaStateToString may be unresolved in some environments.
                // Using toString() directly on the integer for debug output.
                val modName = if (bind.first != 0) "Meta(${bind.first})" else "None"
                Log.d("DroidOS_Keys", "CMD: ${cmd.label} -> [$modName] + [$keyName] (Mod:${bind.first}, Key:${bind.second})")
            }
        }
        Log.d("DroidOS_Keys", "======================")
    }

    private fun buildAdbCommand(cmdId: String): String? {
        return when (cmdId) {
            "SWAP" -> "adb shell am broadcast -a com.katsuyamaki.DroidOSLauncher.WINDOW_MANAGER --es COMMAND SWAP --ei INDEX_A 1 --ei INDEX_B 2"
            "SWAP_ACTIVE_LEFT" -> "adb shell am broadcast -a com.katsuyamaki.DroidOSLauncher.WINDOW_MANAGER --es COMMAND SWAP_ACTIVE_LEFT"
            "SWAP_ACTIVE_RIGHT" -> "adb shell am broadcast -a com.katsuyamaki.DroidOSLauncher.WINDOW_MANAGER --es COMMAND SWAP_ACTIVE_RIGHT"
            "HIDE" -> "adb shell am broadcast -a com.katsuyamaki.DroidOSLauncher.WINDOW_MANAGER --es COMMAND HIDE --ei INDEX 1"
            "MINIMIZE" -> "adb shell am broadcast -a com.katsuyamaki.DroidOSLauncher.WINDOW_MANAGER --es COMMAND MINIMIZE --ei INDEX 1"
            "UNMINIMIZE" -> "adb shell am broadcast -a com.katsuyamaki.DroidOSLauncher.WINDOW_MANAGER --es COMMAND UNMINIMIZE --ei INDEX 1"
            "KILL" -> "adb shell am broadcast -a com.katsuyamaki.DroidOSLauncher.WINDOW_MANAGER --es COMMAND KILL --ei INDEX 1"
            "OPEN_DRAWER" -> "adb shell am broadcast -a com.katsuyamaki.DroidOSLauncher.OPEN_DRAWER"
            else -> null
        }
    }

    inner class RofiAdapter : RecyclerView.Adapter<RecyclerView.ViewHolder>() {
        inner class AppHolder(v: View) : RecyclerView.ViewHolder(v) { val icon: ImageView = v.findViewById(R.id.rofi_app_icon); val text: TextView = v.findViewById(R.id.rofi_app_text); val star: ImageView = v.findViewById(R.id.rofi_app_star) }
        // [FIX] Include all buttons in Holder to support legacy logic and prevent crashes
        inner class LayoutHolder(v: View) : RecyclerView.ViewHolder(v) { 
            val nameInput: EditText = v.findViewById(R.id.layout_name)
            val btnEdit: ImageView = v.findViewById(R.id.btn_edit_layout_name)
            val btnSave: ImageView = v.findViewById(R.id.btn_save_profile)
            val btnExtinguish: ImageView = v.findViewById(R.id.btn_extinguish_item) 
        }

        inner class DpiHolder(v: View) : RecyclerView.ViewHolder(v) { val slider: android.widget.SeekBar = v.findViewById(R.id.sb_dpi_slider); val input: EditText = v.findViewById(R.id.input_dpi_value) }

        inner class FontSizeHolder(v: View) : RecyclerView.ViewHolder(v) { val btnMinus: ImageView = v.findViewById(R.id.btn_font_minus); val btnPlus: ImageView = v.findViewById(R.id.btn_font_plus); val textVal: TextView = v.findViewById(R.id.text_font_value) }
        inner class HeightHolder(v: View) : RecyclerView.ViewHolder(v) { val btnMinus: ImageView = v.findViewById(R.id.btn_height_minus); val btnPlus: ImageView = v.findViewById(R.id.btn_height_plus); val textVal: TextView = v.findViewById(R.id.text_height_value) }
        inner class WidthHolder(v: View) : RecyclerView.ViewHolder(v) { val btnMinus: ImageView = v.findViewById(R.id.btn_width_minus); val btnPlus: ImageView = v.findViewById(R.id.btn_width_plus); val textVal: TextView = v.findViewById(R.id.text_width_value) }
        inner class ProfileRichHolder(v: View) : RecyclerView.ViewHolder(v) { val name: EditText = v.findViewById(R.id.profile_name_text); val details: TextView = v.findViewById(R.id.profile_details_text); val iconsContainer: LinearLayout = v.findViewById(R.id.profile_icons_container); val btnSave: ImageView = v.findViewById(R.id.btn_save_profile_rich) }
        inner class IconSettingHolder(v: View) : RecyclerView.ViewHolder(v) { val preview: ImageView = v.findViewById(R.id.icon_setting_preview) }
        inner class CustomResInputHolder(v: View) : RecyclerView.ViewHolder(v) { val inputW: EditText = v.findViewById(R.id.input_res_w); val inputH: EditText = v.findViewById(R.id.input_res_h); val btnSave: ImageView = v.findViewById(R.id.btn_save_res) }
        inner class KeybindHolder(v: View) : RecyclerView.ViewHolder(v) { val title: TextView = v.findViewById(R.id.kb_title); val desc: TextView = v.findViewById(R.id.kb_desc); val btnMod: android.widget.Button = v.findViewById(R.id.btn_mod); val btnKey: android.widget.Button = v.findViewById(R.id.btn_key) }
        inner class CustomModHolder(v: View) : RecyclerView.ViewHolder(v) { 
            val input: EditText = v.findViewById(R.id.input_custom_mod) 
        }
        inner class MarginHolder(v: View) : RecyclerView.ViewHolder(v) { 
            val label: TextView = v.findViewById(R.id.text_margin_label)
            val slider: android.widget.SeekBar = v.findViewById(R.id.sb_margin_slider)
            val text: TextView = v.findViewById(R.id.text_margin_value)
        }
        // Reuse item_layout_option logic for simplicity
        inner class HeaderHolder(v: View) : RecyclerView.ViewHolder(v) { val nameInput: EditText = v.findViewById(R.id.layout_name); val btnSave: View = v.findViewById(R.id.btn_save_profile); val btnExtinguish: View = v.findViewById(R.id.btn_extinguish_item) }
        inner class ActionHolder(v: View) : RecyclerView.ViewHolder(v) { val nameInput: EditText = v.findViewById(R.id.layout_name); val btnSave: View = v.findViewById(R.id.btn_save_profile); val btnExtinguish: View = v.findViewById(R.id.btn_extinguish_item) }

        override fun getItemViewType(position: Int): Int { return when (displayList[position]) { is MainActivity.AppInfo -> 0; is LayoutOption -> 1; is ResolutionOption -> 1; is DpiOption -> 2; is ProfileOption -> 4; is FontSizeOption -> 3; is IconOption -> 5; is ToggleOption -> 1; is ActionOption -> 6; is HeightOption -> 7; is WidthOption -> 8;         is CustomResInputOption -> 9; is RefreshHeaderOption -> 10; is RefreshItemOption -> 11; is KeybindOption -> 12; is CustomModConfigOption -> 13; is MarginOption -> 14; else -> 0 } }
        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder { return when (viewType) { 0 -> AppHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_app_rofi, parent, false)); 1 -> LayoutHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_layout_option, parent, false)); 2 -> DpiHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_dpi_custom, parent, false)); 3 -> FontSizeHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_font_size, parent, false)); 4 -> ProfileRichHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_profile_rich, parent, false)); 5 -> IconSettingHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_icon_setting, parent, false)); 6 -> LayoutHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_layout_option, parent, false)); 7 -> HeightHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_height_setting, parent, false)); 8 -> WidthHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_width_setting, parent, false));             9 -> CustomResInputHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_custom_resolution, parent, false));
            10 -> HeaderHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_layout_option, parent, false));
            11 -> ActionHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_layout_option, parent, false)); 12 -> KeybindHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_keybind, parent, false)); 
13 -> CustomModHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_custom_mod, parent, false));
14 -> MarginHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_margin_setting, parent, false))
else -> AppHolder(View(parent.context)) } }
        private fun startRename(editText: EditText) { editText.isEnabled = true; editText.isFocusable = true; editText.isFocusableInTouchMode = true; editText.requestFocus(); val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager; imm.showSoftInput(editText, InputMethodManager.SHOW_IMPLICIT) }
        private fun endRename(editText: EditText) { editText.isFocusable = false; editText.isFocusableInTouchMode = false; editText.isEnabled = false; val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager; imm.hideSoftInputFromWindow(editText.windowToken, 0) }

        override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
            val item = displayList[position]
            if (holder is AppHolder) holder.text.textSize = currentFontSize
            if (holder is LayoutHolder) holder.nameInput.textSize = currentFontSize
            if (holder is ProfileRichHolder) holder.name.textSize = currentFontSize

            // --- VISUAL HIGHLIGHT LOGIC ---
            // If row is selected via keyboard, force active background.
            // Otherwise, use standard pressable background.
            val isKeyboardSelected = (position == selectedListIndex)
            val bgRes = if (isKeyboardSelected) R.drawable.bg_item_active else R.drawable.bg_item_press
            
            // Only apply generic background here if not overridden by specific types below
            if (holder !is ProfileRichHolder && holder !is ActionHolder && holder !is LayoutHolder) {
                 holder.itemView.setBackgroundResource(bgRes)
            }
            // ------------------------------

            // === APP HOLDER BINDING - START ===
            // Handles app item display with proper package name extraction for icons
            if (holder is AppHolder && item is MainActivity.AppInfo) {
                holder.text.text = item.label
                if (item.packageName == PACKAGE_BLANK) {
                    holder.icon.setImageResource(R.drawable.ic_box_outline)
                } else {
                    try {
                        // Extract base package name (remove ":suffix" if present)
                        val basePkg = if (item.packageName.contains(":")) item.packageName.substringBefore(":") else item.packageName
                        holder.icon.setImageDrawable(packageManager.getApplicationIcon(basePkg))
                    } catch (e: Exception) {
                        holder.icon.setImageResource(R.drawable.ic_launcher_bubble)
                    }
                }
                // Highlight if selected in queue OR if selected via keyboard navigation
                val isSelectedInQueue = selectedAppsQueue.any { it.packageName == item.packageName }
                
                if (isSelectedInQueue || isKeyboardSelected) {
                     holder.itemView.setBackgroundResource(R.drawable.bg_item_active)
                } else {
                     holder.itemView.setBackgroundResource(R.drawable.bg_item_press)
                }
                
                holder.star.visibility = if (item.isFavorite) View.VISIBLE else View.GONE
                holder.itemView.setOnClickListener { addToSelection(item) }
                holder.itemView.setOnLongClickListener { toggleFavorite(item); refreshSearchList(); true }
            }
            // === APP HOLDER BINDING - END ===
            else if (holder is ProfileRichHolder && item is ProfileOption) { holder.name.setText(item.name); holder.iconsContainer.removeAllViews(); if (!item.isCurrent) { for (pkg in item.apps.take(5)) { val iv = ImageView(holder.itemView.context); val lp = LinearLayout.LayoutParams(60, 60); lp.marginEnd = 8; iv.layoutParams = lp; if (pkg == PACKAGE_BLANK) { iv.setImageResource(R.drawable.ic_box_outline) } else { try { iv.setImageDrawable(packageManager.getApplicationIcon(pkg)) } catch (e: Exception) { iv.setImageResource(R.drawable.ic_launcher_bubble) } }; holder.iconsContainer.addView(iv) }; val info = "${getLayoutName(item.layout)} | ${getRatioName(item.resIndex)} | ${item.dpi}dpi"; holder.details.text = info; holder.details.visibility = View.VISIBLE; holder.btnSave.visibility = View.GONE; if (activeProfileName == item.name) { holder.itemView.setBackgroundResource(R.drawable.bg_item_active) } else { holder.itemView.setBackgroundResource(0) }; holder.itemView.setOnClickListener { dismissKeyboardAndRestore(); loadProfile(item.name) }; holder.itemView.setOnLongClickListener { startRename(holder.name); true }; val saveProfileName = { val newName = holder.name.text.toString().trim(); if (newName.isNotEmpty() && newName != item.name) { if (AppPreferences.renameProfile(holder.itemView.context, item.name, newName)) { safeToast("Renamed to $newName"); switchMode(MODE_PROFILES) } }; endRename(holder.name) }; holder.name.setOnEditorActionListener { v, actionId, _ -> if (actionId == EditorInfo.IME_ACTION_DONE) { saveProfileName(); holder.name.clearFocus(); val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager; imm.hideSoftInputFromWindow(holder.name.windowToken, 0); updateDrawerHeight(false); true } else false }; holder.name.setOnFocusChangeListener { v, hasFocus -> if (autoResizeEnabled) updateDrawerHeight(hasFocus); if (!hasFocus) saveProfileName() } } else { holder.iconsContainer.removeAllViews(); holder.details.visibility = View.GONE; holder.btnSave.visibility = View.VISIBLE; holder.itemView.setBackgroundResource(0); holder.name.isEnabled = true; holder.name.isFocusable = true; holder.name.isFocusableInTouchMode = true; holder.itemView.setOnClickListener { saveProfile() }; holder.btnSave.setOnClickListener { saveProfile() } } }
            else if (holder is LayoutHolder) {
                // --- APPLY KEYBOARD HIGHLIGHT ---
                if (isKeyboardSelected) holder.itemView.setBackgroundResource(R.drawable.bg_item_active)
                else holder.itemView.setBackgroundResource(R.drawable.bg_item_press)
                
                // [FIX] Explicitly hide all buttons by default
                holder.btnEdit.visibility = View.GONE
                holder.btnSave.visibility = View.GONE
                holder.btnExtinguish.visibility = View.GONE

                // [CRITICAL FIX] CLEAR ALL LISTENERS
                // This prevents "Ghost Saves" where listeners from a previous LayoutOption
                // persist when the holder is reused for a Toggle/Action option.
                holder.nameInput.onFocusChangeListener = null
                holder.nameInput.setOnEditorActionListener(null)
                holder.itemView.setOnLongClickListener(null)
                holder.itemView.setOnClickListener(null)
                holder.nameInput.setOnClickListener(null)

                // [FIX] Reset interactivity to prevent ghost touches blocking clicks
                // LayoutOption enables these explicitly, but other types need them OFF
                holder.nameInput.isClickable = false
                holder.nameInput.isFocusable = false
                holder.nameInput.isFocusableInTouchMode = false
                holder.nameInput.background = null
                // --------------------------------
                
                                if (item is LayoutOption) { 
                                    holder.nameInput.setText(item.name)
                                    val isSelected = if (item.type == LAYOUT_CUSTOM_DYNAMIC) { item.type == selectedLayoutType && item.name == activeCustomLayoutName } else { item.type == selectedLayoutType && activeCustomLayoutName == null }
                                    
                                    if (isSelected || isKeyboardSelected) holder.itemView.setBackgroundResource(R.drawable.bg_item_active) 
                                    else holder.itemView.setBackgroundResource(R.drawable.bg_item_press)
                                    
                                    // SELECTION CLICK
                                    val selectAction = View.OnClickListener { selectLayout(item) }
                                    holder.itemView.setOnClickListener(selectAction)
                                    holder.nameInput.setOnClickListener(selectAction)
                                    
                                    // RESET STATE (Default)
                                    holder.nameInput.apply {
                                        isEnabled = true
                                        setTextColor(Color.WHITE)
                                        background = null
                                        isFocusable = false
                                        isFocusableInTouchMode = false
                                        isClickable = true
                                        isLongClickable = false
                                        inputType = 0
                                    }
                                    
                                    // EDIT BUTTON LOGIC (Renaming)
                                    // Works for BOTH Custom and Default layouts now
                                    holder.btnEdit.visibility = View.VISIBLE
                                    holder.btnEdit.setOnClickListener {
                                        // Enable Editing
                                        holder.nameInput.isFocusable = true
                                        holder.nameInput.isFocusableInTouchMode = true
                                        holder.nameInput.isClickable = true
                                        holder.nameInput.inputType = android.text.InputType.TYPE_CLASS_TEXT
                                        
                                        startRename(holder.nameInput)
                                    }
                
                                    // SAVE LOGIC
                                    val saveAction = { 
                                        // [FIX] Post to handler to avoid crashing during focus change/layout pass
                                        uiHandler.post {
                                            val newName = holder.nameInput.text.toString().trim()
                                            var changed = false
                                            
                                            if (newName.isNotEmpty() && newName != item.name) { 
                                                if (item.isCustomSaved) {
                                                    // Rename CUSTOM
                                                    if (AppPreferences.renameCustomLayout(holder.itemView.context, item.name, newName)) { 
                                                        safeToast("Renamed to $newName")
                                                        if (activeCustomLayoutName == item.name) { 
                                                            activeCustomLayoutName = newName
                                                            AppPreferences.saveLastCustomLayoutName(holder.itemView.context, newName, currentDisplayId)
                                                        }
                                                        switchMode(MODE_LAYOUTS) 
                                                        changed = true
                                                    } 
                                                } else {
                                                    // Rename DEFAULT
                                                    AppPreferences.saveDefaultLayoutName(holder.itemView.context, item.type, newName)
                                                    safeToast("Renamed to $newName")
                                                    switchMode(MODE_LAYOUTS)
                                                    changed = true
                                                }
                                            }
                                            
                                            // Only reset UI locally if we didn't refresh the whole list via switchMode
                                            if (!changed) {
                                                endRename(holder.nameInput)
                                                holder.nameInput.isEnabled = true // Keep text white
                                                holder.nameInput.isFocusable = false
                                                holder.nameInput.isClickable = true
                                                holder.nameInput.inputType = 0
                                            }
                                        }
                                    }
                                    
                                    holder.nameInput.setOnEditorActionListener { _, actionId, _ -> 
                                        if (actionId == EditorInfo.IME_ACTION_DONE) { saveAction(); true } else false 
                                    }
                                    holder.nameInput.setOnFocusChangeListener { _, hasFocus -> 
                                        if (!hasFocus) saveAction() 
                                    } 
                                }                else if (item is ResolutionOption) { 
                    holder.nameInput.setText(item.name); if (item.index >= 100) { holder.nameInput.isEnabled = false; holder.nameInput.setTextColor(Color.WHITE); holder.itemView.setOnLongClickListener { startRename(holder.nameInput); true }; val saveResName = { val newName = holder.nameInput.text.toString().trim(); if (newName.isNotEmpty() && newName != item.name) { if (AppPreferences.renameCustomResolution(holder.itemView.context, item.name, newName)) { safeToast("Renamed to $newName"); switchMode(MODE_RESOLUTION) } }; endRename(holder.nameInput) }; holder.nameInput.setOnEditorActionListener { v, actionId, _ -> if (actionId == EditorInfo.IME_ACTION_DONE) { saveResName(); true } else false }; holder.nameInput.setOnFocusChangeListener { v, hasFocus -> if (!hasFocus) saveResName() } } else { holder.nameInput.isEnabled = false; holder.nameInput.isFocusable = false; holder.nameInput.setTextColor(Color.WHITE) }; val isSelected = (item.index == selectedResolutionIndex); if (isSelected || isKeyboardSelected) holder.itemView.setBackgroundResource(R.drawable.bg_item_active) else holder.itemView.setBackgroundResource(R.drawable.bg_item_press); holder.itemView.setOnClickListener { applyResolution(item) } 
                }
                else if (item is IconOption) { holder.nameInput.setText(item.name); holder.nameInput.isEnabled = false; holder.nameInput.setTextColor(Color.WHITE); if(isKeyboardSelected) holder.itemView.setBackgroundResource(R.drawable.bg_item_active) else holder.itemView.setBackgroundResource(R.drawable.bg_item_press); holder.itemView.setOnClickListener { pickIcon() } }
                else if (item is ToggleOption) { holder.nameInput.setText(item.name); holder.nameInput.isEnabled = false; holder.nameInput.setTextColor(Color.WHITE); if (item.isEnabled || isKeyboardSelected) holder.itemView.setBackgroundResource(R.drawable.bg_item_active) else holder.itemView.setBackgroundResource(R.drawable.bg_item_press); holder.itemView.setOnClickListener { dismissKeyboardAndRestore(); item.isEnabled = !item.isEnabled; item.onToggle(item.isEnabled); notifyItemChanged(position) } } 
                else if (item is ActionOption) { holder.nameInput.setText(item.name); holder.nameInput.isEnabled = false; holder.nameInput.setTextColor(Color.WHITE); if(isKeyboardSelected) holder.itemView.setBackgroundResource(R.drawable.bg_item_active) else holder.itemView.setBackgroundResource(R.drawable.bg_item_press); holder.itemView.setOnClickListener { dismissKeyboardAndRestore(); item.action() } }
            }
            else if (holder is HeaderHolder && item is RefreshHeaderOption) {
                holder.nameInput.setText(item.text)
                holder.nameInput.isEnabled = false
                holder.nameInput.setTextColor(Color.GREEN)
                holder.nameInput.textSize = 16f
                holder.nameInput.gravity = Gravity.CENTER
                holder.itemView.setBackgroundResource(0)
                holder.btnSave.visibility = View.GONE
                holder.btnExtinguish.visibility = View.GONE
            }
// =================================================================================
            // REFRESH ITEM OPTION BINDING
            // SUMMARY: Binds refresh rate options. Available rates show white text and are
            //          clickable. Unavailable rates are greyed out and show explanation toast.
            // =================================================================================
            else if (holder is ActionHolder && item is RefreshItemOption) {
                holder.nameInput.setText(item.label)
                holder.nameInput.isEnabled = false
                holder.btnSave.visibility = View.GONE
                holder.btnExtinguish.visibility = View.GONE
                
                if (item.isAvailable) {
                    // Available rate - normal styling
                    if (item.isSelected) {
                        holder.itemView.setBackgroundResource(R.drawable.bg_item_active)
                        holder.nameInput.setTextColor(Color.WHITE)
                        holder.nameInput.setTypeface(null, android.graphics.Typeface.BOLD)
                    } else {
                        holder.itemView.setBackgroundResource(R.drawable.bg_item_press)
                        holder.nameInput.setTextColor(Color.WHITE)
                        holder.nameInput.setTypeface(null, android.graphics.Typeface.NORMAL)
                    }
                    
                    holder.itemView.alpha = 1.0f
                    holder.itemView.setOnClickListener {
                        dismissKeyboardAndRestore()
                        applyRefreshRate(item.targetRate)
                    }
                } else {
                    // Unavailable rate - greyed out styling
                    holder.itemView.setBackgroundResource(R.drawable.bg_item_press)
                    holder.nameInput.setTextColor(Color.GRAY)
                    holder.nameInput.setTypeface(null, android.graphics.Typeface.ITALIC)
                    holder.itemView.alpha = 0.5f
                    
                    holder.itemView.setOnClickListener {
                        dismissKeyboardAndRestore()
                        safeToast("${item.targetRate.toInt()}Hz not supported by this display")
                    }
                }
            }
            // =================================================================================
            // END REFRESH ITEM OPTION BINDING
            // =================================================================================
            else if (holder is CustomResInputHolder) {
                holder.btnSave.setOnClickListener { val wStr = holder.inputW.text.toString().trim(); val hStr = holder.inputH.text.toString().trim(); if (wStr.isNotEmpty() && hStr.isNotEmpty()) { val w = wStr.toIntOrNull(); val h = hStr.toIntOrNull(); if (w != null && h != null && w > 0 && h > 0) { val gcdVal = calculateGCD(w, h); val wRatio = w / gcdVal; val hRatio = h / gcdVal; val resString = "${w}x${h}"; val name = "$wRatio:$hRatio Custom ($resString)"; AppPreferences.saveCustomResolution(holder.itemView.context, name, resString); safeToast("Added $name"); dismissKeyboardAndRestore(); switchMode(MODE_RESOLUTION) } else { safeToast("Invalid numbers") } } else { safeToast("Input W and H") } }
                holder.inputW.setOnFocusChangeListener { _, hasFocus -> if (autoResizeEnabled) updateDrawerHeight(hasFocus) }; holder.inputH.setOnFocusChangeListener { _, hasFocus -> if (autoResizeEnabled) updateDrawerHeight(hasFocus) }
            }
            else if (holder is IconSettingHolder && item is IconOption) { try { val uriStr = AppPreferences.getIconUri(holder.itemView.context); if (uriStr != null) { val uri = Uri.parse(uriStr); val input = contentResolver.openInputStream(uri); val bitmap = BitmapFactory.decodeStream(input); input?.close(); holder.preview.setImageBitmap(bitmap) } else { holder.preview.setImageResource(R.drawable.ic_launcher_bubble) } } catch(e: Exception) { holder.preview.setImageResource(R.drawable.ic_launcher_bubble) }; holder.itemView.setOnClickListener { pickIcon() } }

            else if (holder is DpiHolder && item is DpiOption) { 
                // Set initial values
                val safeDpi = if (item.currentDpi > 0) item.currentDpi else 0
                holder.input.setText(safeDpi.toString())
                holder.slider.progress = safeDpi

                // Slider Listener
                holder.slider.setOnSeekBarChangeListener(object : android.widget.SeekBar.OnSeekBarChangeListener {
                    override fun onProgressChanged(seekBar: android.widget.SeekBar?, progress: Int, fromUser: Boolean) {
                        if (fromUser) {
                            // Snap to 5
                            val snapped = (progress / 5) * 5
                            val finalDpi = snapped.coerceAtLeast(72) // Minimum safe DPI
                            
                            if (holder.input.text.toString() != finalDpi.toString()) {
                                holder.input.setText(finalDpi.toString())
                                holder.input.setSelection(holder.input.text.length)
                            }
                            // Debounce actual execution slightly if needed, or run direct
                            // For DPI, usually better to wait for "StopTracking", but "Live" is requested usually
                        }
                    }
                    override fun onStartTrackingTouch(seekBar: android.widget.SeekBar?) {}
                    override fun onStopTrackingTouch(seekBar: android.widget.SeekBar?) {
                        // Apply DPI only when user lets go to avoid spamming the system
                        val valInt = holder.input.text.toString().toIntOrNull()
                        if (valInt != null) selectDpi(valInt)
                    }
                })

                // Input Listener
                holder.input.setOnEditorActionListener { v, actionId, _ -> 
                    if (actionId == EditorInfo.IME_ACTION_DONE) { 
                        val valInt = v.text.toString().toIntOrNull()
                        if (valInt != null) { 
                            holder.slider.progress = valInt
                            selectDpi(valInt)
                            safeToast("DPI set to $valInt") 
                        }
                        dismissKeyboardAndRestore()
                        true 
                    } else false 
                }
                
                holder.input.addTextChangedListener(object : TextWatcher {
                    override fun afterTextChanged(s: Editable?) {
                        val valInt = s.toString().toIntOrNull()
                        if (valInt != null && holder.slider.progress != valInt) {
                            holder.slider.progress = valInt
                        }
                    }
                    override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
                    override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}
                })

                holder.input.setOnFocusChangeListener { _, hasFocus -> 
                    if (autoResizeEnabled) updateDrawerHeight(hasFocus)
                }
            }

            else if (holder is FontSizeHolder && item is FontSizeOption) { holder.textVal.text = item.currentSize.toInt().toString(); holder.btnMinus.setOnClickListener { changeFontSize(item.currentSize - 1) }; holder.btnPlus.setOnClickListener { changeFontSize(item.currentSize + 1) } }
            else if (holder is HeightHolder && item is HeightOption) { holder.textVal.text = item.currentPercent.toString(); holder.btnMinus.setOnClickListener { changeDrawerHeight(-5) }; holder.btnPlus.setOnClickListener { changeDrawerHeight(5) } }
            else if (holder is WidthHolder && item is WidthOption) { holder.textVal.text = item.currentPercent.toString(); holder.btnMinus.setOnClickListener { changeDrawerWidth(-5) }; holder.btnPlus.setOnClickListener { changeDrawerWidth(5) } }
            else if (holder is MarginHolder && item is MarginOption) {
                holder.label.text = if (item.type == 0) "Top Margin:" else "Bottom Margin:"
                holder.text.text = "${item.currentPercent}%"
                holder.slider.progress = item.currentPercent
                
                holder.slider.setOnSeekBarChangeListener(object : android.widget.SeekBar.OnSeekBarChangeListener {
                    override fun onProgressChanged(seekBar: android.widget.SeekBar?, progress: Int, fromUser: Boolean) {
                        if (fromUser) {
                            holder.text.text = "$progress%"
                        }
                    }
                    override fun onStartTrackingTouch(seekBar: android.widget.SeekBar?) {}
                    override fun onStopTrackingTouch(seekBar: android.widget.SeekBar?) {
                        val progress = seekBar?.progress ?: 0
                        
                        if (item.type == 0) {
                            topMarginPercent = progress
                            AppPreferences.setTopMarginPercent(holder.itemView.context, currentDisplayId, progress)
                            safeToast("Top Margin: $progress% (Display $currentDisplayId)")
                        } else {
                            bottomMarginPercent = progress
                            AppPreferences.setBottomMarginPercent(holder.itemView.context, currentDisplayId, progress)
                            safeToast("Bottom Margin: $progress% (Display $currentDisplayId)")
                            
                            // Broadcast change to Dock/Trackpad
                            val intent = Intent("com.katsuyamaki.DroidOSLauncher.MARGIN_CHANGED")
                            intent.putExtra("PERCENT", progress)
                            intent.setPackage("com.katsuyamaki.DroidOSTrackpadKeyboard") // Explicit target
                            sendBroadcast(intent)
                        }
                        
                        // Recalculate visual queue pos
                        setupVisualQueue()
                        
                        // Apply layout
                        if (isInstantMode) {
                            applyLayoutImmediate()
                        }
                    }
                })
            }
            else if (holder is CustomModHolder && item is CustomModConfigOption) {
                // Set current value
                val currentStr = getCharFromKeyCode(item.currentKeyCode)
                if (holder.input.text.toString() != currentStr) {
                    holder.input.setText(currentStr)
                }

                // Save on Text Change
                holder.input.addTextChangedListener(object : TextWatcher {
                    override fun afterTextChanged(s: Editable?) {
                        if (s != null && s.isNotEmpty()) {
                            val char = s[0]
                            val code = getKeyCodeFromChar(char)
                            if (code != 0) {
                                AppPreferences.saveCustomModKey(this@FloatingLauncherService, code)
                                customModKey = code
                                safeToast("Custom Mod set to: $char (Code $code)")

sendCustomModToTrackpad() // Sync immediately
                            } else {
                                safeToast("Unsupported Key Character")
                            }
                        } else {
                            // Cleared
                            AppPreferences.saveCustomModKey(this@FloatingLauncherService, 0)
                            customModKey = 0
                            sendCustomModToTrackpad()
                        }
                    }
                    override fun beforeTextChanged(s: CharSequence?, st: Int, c: Int, a: Int) {}
                    override fun onTextChanged(s: CharSequence?, st: Int, b: Int, c: Int) {}
                })
            }
            else if (holder is KeybindHolder && item is KeybindOption) {
                holder.title.text = item.def.label
                holder.desc.text = item.def.description

                // Modifier Button (FORCE AT LEAST ONE)
                val modText = when (item.modifier) {
                    KeyEvent.META_ALT_ON -> "ALT"
                    KeyEvent.META_SHIFT_ON -> "SHIFT"
                    KeyEvent.META_CTRL_ON -> "CTRL"
                    KeyEvent.META_META_ON -> "META"
                    MOD_CUSTOM -> "CSTM" // New Custom State
                    0 -> "NONE"
                    else -> "MOD"
                }
                
                if (item.modifier == 0) holder.btnMod.setTextColor(Color.RED)
                else if (item.modifier == MOD_CUSTOM) holder.btnMod.setTextColor(Color.CYAN)
                else holder.btnMod.setTextColor(Color.GREEN)
                
                holder.btnMod.text = modText
                holder.btnMod.setOnClickListener {
                    item.modifier = when (item.modifier) {
                        0 -> KeyEvent.META_ALT_ON
                        KeyEvent.META_ALT_ON -> KeyEvent.META_SHIFT_ON
                        KeyEvent.META_SHIFT_ON -> KeyEvent.META_CTRL_ON
                        KeyEvent.META_CTRL_ON -> KeyEvent.META_META_ON
                        KeyEvent.META_META_ON -> MOD_CUSTOM // Cycle to Custom
                        MOD_CUSTOM -> KeyEvent.META_ALT_ON  // Loop back
                        else -> KeyEvent.META_ALT_ON
                    }
                    AppPreferences.saveKeybind(this@FloatingLauncherService, item.def.id, item.modifier, item.keyCode)
                    // Notify Trackpad of keybind changes
                    broadcastKeybindsToKeyboard()
                    notifyItemChanged(position)
                }

                // Key Button (Opens Picker)
                val keyName = SUPPORTED_KEYS.entries.find { it.value == item.keyCode }?.key ?: "?"
                holder.btnKey.text = keyName
                holder.btnKey.setOnClickListener {
                    // If modifier is NONE, force ALT before picking key
                    var safeMod = item.modifier
                    if (safeMod == 0) {
                        safeMod = KeyEvent.META_ALT_ON
                        AppPreferences.saveKeybind(this@FloatingLauncherService, item.def.id, safeMod, item.keyCode)
                        // Notify Trackpad of keybind changes
                        broadcastKeybindsToKeyboard()
                        safeToast("Safety: Modifier set to ALT")
                    }
                    showKeyPicker(item.def.id, safeMod)
                }

                // Long press on entire item to copy ADB command
                holder.itemView.setOnLongClickListener {
                    val adbCmd = buildAdbCommand(item.def.id)
                    if (adbCmd != null) {
                        val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as android.content.ClipboardManager
                        val clip = android.content.ClipData.newPlainText("ADB Command", adbCmd)
                        clipboard.setPrimaryClip(clip)
                        safeToast("ADB command copied!")
                    }
                    true
                }
            }
        }
        override fun getItemCount() = displayList.size
    }

    private fun getKeyCodeFromChar(c: Char): Int {
        val char = c.lowercaseChar()
        return when (char) {
            in 'a'..'z' -> KeyEvent.keyCodeFromString("KEYCODE_${char.uppercase()}")
            in '0'..'9' -> KeyEvent.keyCodeFromString("KEYCODE_$char")
            '`', '~' -> KeyEvent.KEYCODE_GRAVE
            '-', '_' -> KeyEvent.KEYCODE_MINUS
            '=', '+' -> KeyEvent.KEYCODE_EQUALS
            '[', '{' -> KeyEvent.KEYCODE_LEFT_BRACKET
            ']', '}' -> KeyEvent.KEYCODE_RIGHT_BRACKET
            '\\', '|' -> KeyEvent.KEYCODE_BACKSLASH
            ';', ':' -> KeyEvent.KEYCODE_SEMICOLON
            '\'', '"' -> KeyEvent.KEYCODE_APOSTROPHE
            ',', '<' -> KeyEvent.KEYCODE_COMMA
            '.', '>' -> KeyEvent.KEYCODE_PERIOD
            '/', '?' -> KeyEvent.KEYCODE_SLASH
            ' ' -> KeyEvent.KEYCODE_SPACE
            else -> 0
        }
    }
    
    private fun getCharFromKeyCode(code: Int): String {
        // Reverse mapping for display
        if (code == KeyEvent.KEYCODE_GRAVE) return "~"
        if (code == 0) return ""
        val str = KeyEvent.keyCodeToString(code)
        return str.replace("KEYCODE_", "")
    }
}
```
